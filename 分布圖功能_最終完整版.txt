' ============================================================
' 分佈圖功能 - 最終完整版
' 創建日期：2025-12-04
' 功能：
'   1. 每個讀值獨立成圖，圖表名稱 = 讀值名稱
'   2. 自動抓取參數 Max（紅線）和 Min（綠線）
'   3. 每張圖左側附帶完整參數表
'   4. 計算數據隱藏在圖表左側（A-E 欄）
'   5. 每個 SEQ 垂直堆疊，互不干涉
' ============================================================

' ========== 主控函數 ==========

Sub GenerateSEQDistributionCharts()
    Dim filePathArray As Variant
    Dim fileContent As String
    Dim lines() As String
    Dim startTime As Double

    startTime = Timer

    filePathArray = Application.GetOpenFilename("Text Files (*.txt), *.txt", , "選擇測試報告檔案", , MultiSelect:=True)
    If Not IsArray(filePathArray) Then Exit Sub

    Application.ScreenUpdating = False
    Application.Calculation = xlCalculationManual
    Application.EnableEvents = False
    Application.DisplayStatusBar = True
    Application.StatusBar = "讀取檔案..."

    Dim fileCount As Long
    fileCount = UBound(filePathArray) - LBound(filePathArray) + 1

    If fileCount = 1 Then
        fileContent = ReadTextFile(CStr(filePathArray(LBound(filePathArray))))
    Else
        fileContent = MergeMultipleFiles(filePathArray)
    End If

    If fileContent = "" Then
        Application.StatusBar = False
        MsgBox "讀取檔案失敗！", vbCritical, "錯誤"
        GoTo CleanupAndExit
    End If

    Application.StatusBar = "解析測試數據..."
    lines = Split(fileContent, vbCrLf)

    Application.StatusBar = "識別測試序列..."
    Dim allSequences As Object
    Set allSequences = FindAllSequences(lines)

    If allSequences.Count = 0 Then
        MsgBox "未找到測試序列！", vbWarning, "警告"
        GoTo CleanupAndExit
    End If

    Application.StatusBar = "創建分佈圖..."
    Call CreateDistributionChartsForAllSequences(allSequences, lines)

    Dim elapsedTime As Double
    elapsedTime = Timer - startTime

    Application.StatusBar = "完成！"
    MsgBox "✅ 分佈圖生成完成！" & vbCrLf & vbCrLf & _
           "總耗時：" & Format(elapsedTime, "0.00") & " 秒" & vbCrLf & _
           "共處理 " & allSequences.Count & " 個測試序列", vbInformation, "完成"

CleanupAndExit:
    Application.StatusBar = False
    Application.ScreenUpdating = True
    Application.Calculation = xlCalculationAutomatic
    Application.EnableEvents = True
End Sub

' ========== 主函數 ==========

Sub CreateDistributionChartsForAllSequences(allSequences As Object, lines() As String)
    Dim ws As Worksheet
    On Error Resume Next
    Set ws = ActiveWorkbook.Worksheets("分佈圖")
    On Error GoTo 0

    If ws Is Nothing Then
        Set ws = ActiveWorkbook.Worksheets.Add(After:=ActiveWorkbook.Sheets(ActiveWorkbook.Sheets.Count))
        ws.Name = "分佈圖"
    Else
        ws.Cells.EntireColumn.Hidden = False
        ws.Cells.Clear
        ws.ChartObjects.Delete
    End If

    Dim chartStartRow As Long
    chartStartRow = 2

    Dim seqIndex As Variant
    Dim seqInfo As Object
    Dim blockHeight As Long

    For Each seqIndex In allSequences.Keys
        Set seqInfo = allSequences(seqIndex)
        Application.StatusBar = "生成分佈圖：" & seqInfo("type") & " - " & seqInfo("loadName")

        Select Case seqInfo("type")
            Case "LoadRegulation"
                blockHeight = CreateLoadRegulationDistributionCharts(ws, seqInfo, lines, chartStartRow)
            Case "TurnOn"
                blockHeight = CreateTurnOnDistributionCharts(ws, seqInfo, lines, chartStartRow)
            Case "HoldUp"
                blockHeight = CreateHoldUpDistributionCharts(ws, seqInfo, lines, chartStartRow)
            Case "ShortCircuit"
                blockHeight = CreateShortCircuitDistributionCharts(ws, seqInfo, lines, chartStartRow)
            Case "Combine"
                blockHeight = CreateCombineDistributionCharts(ws, seqInfo, lines, chartStartRow)
            Case "OLP"
                blockHeight = CreateOLPDistributionCharts(ws, seqInfo, lines, chartStartRow)
            Case "Dynamic"
                blockHeight = CreateDynamicDistributionCharts(ws, seqInfo, lines, chartStartRow)
            Case "InputOutput_Iin", "InputOutput_Pin", "InputOutput_Eff", "InputOutput_General"
                blockHeight = CreateInputOutputDistributionCharts(ws, seqInfo, lines, chartStartRow)
        End Select

        chartStartRow = chartStartRow + blockHeight + 3
    Next seqIndex

    ' 隱藏計算數據欄位（A-E 欄）
    ws.Range("A:E").Hidden = True

    ws.Cells.Font.Name = "Calibri"
    ws.Cells.Font.Size = 10
    ws.Activate
    ws.Range("F1").Select
End Sub

' ========== 測試類型專用函數 ==========

Function CreateLoadRegulationDistributionCharts(ws As Worksheet, seqInfo As Object, _
                                                 lines() As String, startRow As Long) As Long
    Dim params As Object
    Set params = ExtractLoadRegulationParams(lines, seqInfo("startLine"), seqInfo("loadName"))

    Dim readData As Object
    Set readData = ExtractAllLoadRegulationReads(lines, seqInfo("title"))

    If readData.Count = 0 Then
        CreateLoadRegulationDistributionCharts = 0
        Exit Function
    End If

    ' SEQ 標題
    ws.Cells(startRow, 6).Value = seqInfo("title")
    ws.Cells(startRow, 6).Font.Bold = True
    ws.Cells(startRow, 6).Font.Size = 14
    ws.Cells(startRow, 6).Font.Color = RGB(68, 114, 196)
    ws.Range(ws.Cells(startRow, 6), ws.Cells(startRow, 15)).Merge
    ws.Cells(startRow, 6).HorizontalAlignment = xlCenter

    Dim currentRow As Long
    currentRow = startRow + 2

    Dim readingNames As Variant
    readingNames = Array("VdcRead1", "VppRead1", "VnRead1", _
                         "VdcRead2", "VppRead2", "VnRead2", _
                         "VdcRead3", "VppRead3", "VnRead3", _
                         "AvgVdc", "AvgVpp")

    Dim readingName As Variant
    Dim blockHeight As Long

    For Each readingName In readingNames
        blockHeight = CreateSingleDistributionChart_Final(ws, CStr(readingName), readData, currentRow, params)
        currentRow = currentRow + blockHeight + 2
    Next readingName

    CreateLoadRegulationDistributionCharts = currentRow - startRow
End Function

Function CreateTurnOnDistributionCharts(ws As Worksheet, seqInfo As Object, _
                                        lines() As String, startRow As Long) As Long
    Dim params As Object
    Set params = ExtractTurnOnParams(lines, seqInfo("startLine"), seqInfo("loadName"))

    Dim readData As Object
    Set readData = ExtractAllTonReads(lines, seqInfo("title"))

    If readData.Count = 0 Then
        CreateTurnOnDistributionCharts = 0
        Exit Function
    End If

    ws.Cells(startRow, 6).Value = seqInfo("title")
    ws.Cells(startRow, 6).Font.Bold = True
    ws.Cells(startRow, 6).Font.Size = 14
    ws.Cells(startRow, 6).Font.Color = RGB(68, 114, 196)
    ws.Range(ws.Cells(startRow, 6), ws.Cells(startRow, 15)).Merge
    ws.Cells(startRow, 6).HorizontalAlignment = xlCenter

    Dim currentRow As Long
    currentRow = startRow + 2

    Dim blockHeight As Long
    blockHeight = CreateSingleDistributionChart_Final(ws, "Reading", readData, currentRow, params)

    CreateTurnOnDistributionCharts = currentRow + blockHeight - startRow
End Function

Function CreateHoldUpDistributionCharts(ws As Worksheet, seqInfo As Object, _
                                        lines() As String, startRow As Long) As Long
    Dim params As Object
    Set params = ExtractHoldUpParams(lines, seqInfo("startLine"), seqInfo("loadName"))

    Dim readData As Object
    Set readData = ExtractAllHoldUpReads(lines, seqInfo("title"))

    If readData.Count = 0 Then
        CreateHoldUpDistributionCharts = 0
        Exit Function
    End If

    ws.Cells(startRow, 6).Value = seqInfo("title")
    ws.Cells(startRow, 6).Font.Bold = True
    ws.Cells(startRow, 6).Font.Size = 14
    ws.Cells(startRow, 6).Font.Color = RGB(68, 114, 196)
    ws.Range(ws.Cells(startRow, 6), ws.Cells(startRow, 15)).Merge
    ws.Cells(startRow, 6).HorizontalAlignment = xlCenter

    Dim currentRow As Long
    currentRow = startRow + 2

    Dim readingNames As Variant
    readingNames = Array("Tds", "Tdl")

    Dim readingName As Variant
    Dim blockHeight As Long

    For Each readingName In readingNames
        blockHeight = CreateSingleDistributionChart_Final(ws, CStr(readingName), readData, currentRow, params)
        currentRow = currentRow + blockHeight + 2
    Next readingName

    CreateHoldUpDistributionCharts = currentRow - startRow
End Function

Function CreateShortCircuitDistributionCharts(ws As Worksheet, seqInfo As Object, _
                                              lines() As String, startRow As Long) As Long
    Dim params As Object
    Set params = ExtractShortCircuitParams(lines, seqInfo("startLine"), seqInfo("loadName"))

    Dim readData As Object
    Set readData = ExtractAllPinReads(lines, seqInfo("title"))

    If readData.Count = 0 Then
        CreateShortCircuitDistributionCharts = 0
        Exit Function
    End If

    ws.Cells(startRow, 6).Value = seqInfo("title")
    ws.Cells(startRow, 6).Font.Bold = True
    ws.Cells(startRow, 6).Font.Size = 14
    ws.Cells(startRow, 6).Font.Color = RGB(68, 114, 196)
    ws.Range(ws.Cells(startRow, 6), ws.Cells(startRow, 15)).Merge
    ws.Cells(startRow, 6).HorizontalAlignment = xlCenter

    Dim currentRow As Long
    currentRow = startRow + 2

    Dim blockHeight As Long
    blockHeight = CreateSingleDistributionChart_Final(ws, "Pin", readData, currentRow, params)

    CreateShortCircuitDistributionCharts = currentRow + blockHeight - startRow
End Function

Function CreateCombineDistributionCharts(ws As Worksheet, seqInfo As Object, _
                                         lines() As String, startRow As Long) As Long
    Dim params As Object
    Set params = ExtractCombineParams(lines, seqInfo("startLine"), seqInfo("loadName"))

    Dim readData As Object
    Set readData = ExtractAllCombineReads(lines, seqInfo("title"))

    If readData.Count = 0 Then
        CreateCombineDistributionCharts = 0
        Exit Function
    End If

    ws.Cells(startRow, 6).Value = seqInfo("title")
    ws.Cells(startRow, 6).Font.Bold = True
    ws.Cells(startRow, 6).Font.Size = 14
    ws.Cells(startRow, 6).Font.Color = RGB(68, 114, 196)
    ws.Range(ws.Cells(startRow, 6), ws.Cells(startRow, 15)).Merge
    ws.Cells(startRow, 6).HorizontalAlignment = xlCenter

    Dim currentRow As Long
    currentRow = startRow + 2

    Dim readingNames As Variant
    readingNames = Array("Vdc1", "Vpp1", "Vdc2", "Vpp2", "Vdc3", "Vpp3")

    Dim readingName As Variant
    Dim blockHeight As Long

    For Each readingName In readingNames
        blockHeight = CreateSingleDistributionChart_Final(ws, CStr(readingName), readData, currentRow, params)
        currentRow = currentRow + blockHeight + 2
    Next readingName

    CreateCombineDistributionCharts = currentRow - startRow
End Function

Function CreateOLPDistributionCharts(ws As Worksheet, seqInfo As Object, _
                                     lines() As String, startRow As Long) As Long
    Dim params As Object
    Set params = ExtractOLPParams(lines, seqInfo("startLine"), seqInfo("loadName"))

    Dim readData As Object
    Set readData = ExtractAllOLPReads(lines, seqInfo("title"))

    If readData.Count = 0 Then
        CreateOLPDistributionCharts = 0
        Exit Function
    End If

    ws.Cells(startRow, 6).Value = seqInfo("title")
    ws.Cells(startRow, 6).Font.Bold = True
    ws.Cells(startRow, 6).Font.Size = 14
    ws.Cells(startRow, 6).Font.Color = RGB(68, 114, 196)
    ws.Range(ws.Cells(startRow, 6), ws.Cells(startRow, 15)).Merge
    ws.Cells(startRow, 6).HorizontalAlignment = xlCenter

    Dim currentRow As Long
    currentRow = startRow + 2

    Dim blockHeight As Long
    blockHeight = CreateSingleDistributionChart_Final(ws, "Reading", readData, currentRow, params)

    CreateOLPDistributionCharts = currentRow + blockHeight - startRow
End Function

Function CreateDynamicDistributionCharts(ws As Worksheet, seqInfo As Object, _
                                         lines() As String, startRow As Long) As Long
    Dim params As Object
    Set params = ExtractDynamicParams(lines, seqInfo("startLine"), seqInfo("loadName"))

    Dim readData As Object
    Set readData = ExtractAllDynamicReads(lines, seqInfo("title"))

    If readData.Count = 0 Then
        CreateDynamicDistributionCharts = 0
        Exit Function
    End If

    ws.Cells(startRow, 6).Value = seqInfo("title")
    ws.Cells(startRow, 6).Font.Bold = True
    ws.Cells(startRow, 6).Font.Size = 14
    ws.Cells(startRow, 6).Font.Color = RGB(68, 114, 196)
    ws.Range(ws.Cells(startRow, 6), ws.Cells(startRow, 15)).Merge
    ws.Cells(startRow, 6).HorizontalAlignment = xlCenter

    Dim currentRow As Long
    currentRow = startRow + 2

    Dim readingNames As Variant
    readingNames = Array("Vs1", "Vs2")

    Dim readingName As Variant
    Dim blockHeight As Long

    For Each readingName In readingNames
        blockHeight = CreateSingleDistributionChart_Final(ws, CStr(readingName), readData, currentRow, params)
        currentRow = currentRow + blockHeight + 2
    Next readingName

    CreateDynamicDistributionCharts = currentRow - startRow
End Function

Function CreateInputOutputDistributionCharts(ws As Worksheet, seqInfo As Object, _
                                             lines() As String, startRow As Long) As Long
    Dim params As Object
    Set params = ExtractInputOutputParams(lines, seqInfo("startLine"), seqInfo("loadName"), seqInfo("type"))

    Dim readData As Object
    Set readData = ExtractAllInputOutputReads(lines, seqInfo("title"), seqInfo("type"))

    If readData.Count = 0 Then
        CreateInputOutputDistributionCharts = 0
        Exit Function
    End If

    ws.Cells(startRow, 6).Value = seqInfo("title")
    ws.Cells(startRow, 6).Font.Bold = True
    ws.Cells(startRow, 6).Font.Size = 14
    ws.Cells(startRow, 6).Font.Color = RGB(68, 114, 196)
    ws.Range(ws.Cells(startRow, 6), ws.Cells(startRow, 15)).Merge
    ws.Cells(startRow, 6).HorizontalAlignment = xlCenter

    Dim currentRow As Long
    currentRow = startRow + 2

    Dim readingNames As Variant
    readingNames = Array("Idc", "Vin", "Pin", "Eff", "PF", "VinRead")

    Dim readingName As Variant
    Dim blockHeight As Long

    For Each readingName In readingNames
        Dim hasReading As Boolean
        hasReading = False

        Dim snKey As Variant
        For Each snKey In readData.Keys
            If readData(snKey).Exists(CStr(readingName)) Then
                hasReading = True
                Exit For
            End If
        Next snKey

        If hasReading Then
            blockHeight = CreateSingleDistributionChart_Final(ws, CStr(readingName), readData, currentRow, params)
            currentRow = currentRow + blockHeight + 2
        End If
    Next readingName

    CreateInputOutputDistributionCharts = currentRow - startRow
End Function

' ========== 核心圖表生成函數（最終版）==========

Function CreateSingleDistributionChart_Final(ws As Worksheet, readingName As String, _
                                             readData As Object, blockRow As Long, _
                                             params As Object) As Long
    ' === 1. 收集讀值數據 ===
    Dim readingValues As Collection
    Set readingValues = CollectReadingValues(readData, readingName)

    If readingValues.Count = 0 Then
        CreateSingleDistributionChart_Final = 0
        Exit Function
    End If

    ' === 2. 自動抓取對應的 Max/Min 參數 ===
    Dim specMax As Variant, specMin As Variant
    specMax = ""
    specMin = ""

    ' 根據讀值名稱智能匹配參數
    Call GetSpecForReading(readingName, params, specMax, specMin)

    ' === 3. 數據處理 ===
    Dim processedData As Collection
    Set processedData = ProcessReadingValues(readingValues)

    If processedData.Count = 0 Then
        CreateSingleDistributionChart_Final = 0
        Exit Function
    End If

    Dim freqData As Object
    Set freqData = CalculateFrequencyData(readingValues, processedData)

    ' === 4. 左側計算數據表（A-E 欄，隱藏）===
    Call WriteDistributionDataToSheet(ws, freqData, specMax, specMin, blockRow, 1)

    ' === 5. 中間參數表（F-G 欄）===
    ws.Cells(blockRow, 6).Value = "Condition"
    ws.Cells(blockRow, 6).Font.Bold = True
    ws.Cells(blockRow, 6).Interior.Color = RGB(255, 224, 178)
    ws.Cells(blockRow, 6).HorizontalAlignment = xlCenter
    ws.Columns(6).ColumnWidth = 18

    ws.Cells(blockRow, 7).Value = "Value"
    ws.Cells(blockRow, 7).Font.Bold = True
    ws.Cells(blockRow, 7).Interior.Color = RGB(255, 249, 196)
    ws.Cells(blockRow, 7).HorizontalAlignment = xlCenter
    ws.Columns(7).ColumnWidth = 12

    ' 寫入所有參數
    Dim paramRow As Long
    paramRow = blockRow + 1

    Dim key As Variant
    For Each key In params.Keys
        ws.Cells(paramRow, 6).Value = CStr(key)
        ws.Cells(paramRow, 7).Value = params(key)
        paramRow = paramRow + 1
    Next key

    ' 加入 Spec Max/Min（高亮顯示）
    If specMax <> "" And specMax <> "*" Then
        ws.Cells(paramRow, 6).Value = readingName & " Max"
        ws.Cells(paramRow, 7).Value = specMax
        ws.Cells(paramRow, 6).Font.Color = RGB(255, 0, 0)
        ws.Cells(paramRow, 6).Font.Bold = True
        ws.Cells(paramRow, 7).Font.Color = RGB(255, 0, 0)
        ws.Cells(paramRow, 7).Font.Bold = True
        paramRow = paramRow + 1
    End If

    If specMin <> "" And specMin <> "*" Then
        ws.Cells(paramRow, 6).Value = readingName & " Min"
        ws.Cells(paramRow, 7).Value = specMin
        ws.Cells(paramRow, 6).Font.Color = RGB(0, 176, 80)
        ws.Cells(paramRow, 6).Font.Bold = True
        ws.Cells(paramRow, 7).Font.Color = RGB(0, 176, 80)
        ws.Cells(paramRow, 7).Font.Bold = True
        paramRow = paramRow + 1
    End If

    Dim paramTableHeight As Long
    paramTableHeight = paramRow - blockRow

    ' === 6. 右側分佈圖（H-O 欄）===
    Dim chartObj As ChartObject
    On Error Resume Next

    Set chartObj = ws.ChartObjects.Add( _
        Left:=ws.Columns(8).Left, _
        Top:=ws.Rows(blockRow).Top, _
        Width:=450, _
        Height:=280)

    If Err.Number <> 0 Then
        Debug.Print "圖表創建錯誤：" & Err.Description
        Err.Clear
        CreateSingleDistributionChart_Final = paramTableHeight
        Exit Function
    End If
    On Error GoTo 0

    ' 設定圖表（圖表名稱 = 讀值名稱）
    Call ConfigureDistributionChart(chartObj.Chart, ws, readingName, blockRow, 1, freqData.Count, specMax, specMin)

    ' 返回使用的行數
    Dim chartRowHeight As Long
    chartRowHeight = 18

    If chartRowHeight > paramTableHeight Then
        CreateSingleDistributionChart_Final = chartRowHeight
    Else
        CreateSingleDistributionChart_Final = paramTableHeight
    End If
End Function

' ========== 智能參數匹配函數 ==========

Sub GetSpecForReading(readingName As String, params As Object, ByRef specMax As Variant, ByRef specMin As Variant)
    ' 根據讀值名稱智能匹配對應的 Max/Min 參數

    ' 去除數字後綴（如 "Vdc1" -> "Vdc"）
    Dim baseName As String
    baseName = readingName

    ' 移除尾部數字
    Dim i As Integer
    For i = Len(baseName) To 1 Step -1
        If Not IsNumeric(Mid(baseName, i, 1)) Then
            baseName = Left(baseName, i)
            Exit For
        End If
    Next i

    ' 特殊處理 Read 結尾的名稱
    If Right(baseName, 4) = "Read" Then
        baseName = Left(baseName, Len(baseName) - 4)
    End If

    ' 嘗試匹配參數
    Dim maxKey As String, minKey As String

    ' 常見參數名稱映射
    Select Case baseName
        Case "Vdc", "VdcRead"
            maxKey = "VdcMax": minKey = "VdcMin"
        Case "Vpp", "VppRead"
            maxKey = "VppMax": minKey = "VppMin"
        Case "Vn", "VnRead"
            maxKey = "VnMax": minKey = "VnMin"
        Case "Tds"
            maxKey = "TdsMax": minKey = "TdsMin"
        Case "Tdl"
            maxKey = "TdlMax": minKey = "TdlMin"
        Case "Pin"
            maxKey = "PinMax": minKey = "PinMin"
        Case "Vs"
            maxKey = "VsMax": minKey = "VsMin"
        Case "Reading"
            maxKey = "ReadingMax": minKey = "ReadingMin"
        Case "Idc"
            maxKey = "IinrmsMax": minKey = ""
        Case "Eff"
            maxKey = "": minKey = "EffMin"
        Case "Vin", "VinRead"
            maxKey = "VinMax": minKey = "VinMin"
        Case Else
            ' 嘗試通用匹配
            maxKey = baseName & "Max"
            minKey = baseName & "Min"
    End Select

    ' 從參數字典中獲取值
    If maxKey <> "" And params.Exists(maxKey) Then
        specMax = params(maxKey)
    End If

    If minKey <> "" And params.Exists(minKey) Then
        specMin = params(minKey)
    End If
End Sub

' ========== 輔助函數 ==========

Function CollectReadingValues(readData As Object, readingName As String) As Collection
    Dim values As New Collection
    Dim snKey As Variant

    For Each snKey In readData.Keys
        If readData(snKey).Exists(readingName) Then
            Dim Value As Variant
            Value = readData(snKey)(readingName)

            If Not IsEmpty(Value) And Value <> "" Then
                Dim cleanValue As String
                cleanValue = CleanNumericValue(CStr(Value))
                If IsNumeric(cleanValue) And cleanValue <> "" Then
                    values.Add CDbl(cleanValue)
                End If
            End If
        End If
    Next snKey

    Set CollectReadingValues = values
End Function

Function ProcessReadingValues(values As Collection) As Collection
    Dim processed As New Collection
    Dim uniqueDict As Object
    Set uniqueDict = CreateObject("Scripting.Dictionary")

    Dim Value As Variant
    For Each Value In values
        Dim rounded As Double
        rounded = RoundByValueRange(CDbl(Value))

        If Not uniqueDict.Exists(rounded) Then
            uniqueDict.Add rounded, True
            processed.Add rounded
        End If
    Next Value

    Set ProcessReadingValues = SortCollection(processed)
End Function

Function RoundByValueRange(Value As Double) As Double
    Dim absValue As Double
    absValue = Abs(Value)

    If absValue >= 1 Then
        RoundByValueRange = Round(Value, 2)
    Else
        Dim valueStr As String
        valueStr = CStr(Value)

        If InStr(valueStr, ".") = 0 Then
            RoundByValueRange = Value
            Exit Function
        End If

        Dim decimalPart As String
        decimalPart = Split(valueStr, ".")(1)

        If Len(decimalPart) <= 3 Then
            RoundByValueRange = Value
        Else
            RoundByValueRange = Round(Value, 3)
        End If
    End If
End Function

Function SortCollection(coll As Collection) As Collection
    Dim sorted As New Collection
    Dim arr() As Double
    Dim i As Long, j As Long
    Dim temp As Double

    ReDim arr(1 To coll.Count)
    For i = 1 To coll.Count
        arr(i) = coll(i)
    Next i

    For i = 1 To UBound(arr) - 1
        For j = i + 1 To UBound(arr)
            If arr(i) > arr(j) Then
                temp = arr(i)
                arr(i) = arr(j)
                arr(j) = temp
            End If
        Next j
    Next i

    For i = 1 To UBound(arr)
        sorted.Add arr(i)
    Next i

    Set SortCollection = sorted
End Function

Function CalculateFrequencyData(originalValues As Collection, uniqueValues As Collection) As Object
    Dim freqDict As Object
    Set freqDict = CreateObject("Scripting.Dictionary")

    Dim uniqueVal As Variant
    Dim origVal As Variant
    Dim count As Long

    For Each uniqueVal In uniqueValues
        count = 0
        For Each origVal In originalValues
            Dim roundedOrigVal As Double
            roundedOrigVal = RoundByValueRange(CDbl(origVal))
            If Abs(roundedOrigVal - CDbl(uniqueVal)) < 0.0001 Then
                count = count + 1
            End If
        Next origVal
        freqDict.Add uniqueVal, count
    Next uniqueVal

    Set CalculateFrequencyData = freqDict
End Function

Sub WriteDistributionDataToSheet(ws As Worksheet, freqData As Object, _
                                  specMax As Variant, specMin As Variant, _
                                  startRow As Long, startCol As Long)
    Dim maxFreq As Long
    maxFreq = 0
    Dim key As Variant
    For Each key In freqData.Keys
        If freqData(key) > maxFreq Then maxFreq = freqData(key)
    Next key

    ws.Cells(startRow, startCol).Value = "Value"
    ws.Cells(startRow, startCol + 1).Value = "Frequency"
    ws.Cells(startRow, startCol + 2).Value = "SpecMinBar"
    ws.Cells(startRow, startCol + 3).Value = "SpecMaxBar"
    ws.Cells(startRow, startCol + 4).Value = "FreqLine"

    Dim row As Long
    row = startRow + 1

    For Each key In freqData.Keys
        ws.Cells(row, startCol).Value = CDbl(key)
        ws.Cells(row, startCol + 1).Value = freqData(key)

        If specMin <> "" And specMin <> "*" Then
            If Abs(CDbl(key) - CDbl(specMin)) < 0.01 Then
                ws.Cells(row, startCol + 2).Value = maxFreq
            End If
        End If

        If specMax <> "" And specMax <> "*" Then
            If Abs(CDbl(key) - CDbl(specMax)) < 0.01 Then
                ws.Cells(row, startCol + 3).Value = maxFreq
            End If
        End If

        ws.Cells(row, startCol + 4).Value = freqData(key)
        row = row + 1
    Next key
End Sub

Sub ConfigureDistributionChart(Chart As Chart, ws As Worksheet, readingName As String, _
                               dataStartRow As Long, dataStartCol As Long, dataCount As Long, _
                               specMax As Variant, specMin As Variant)
    On Error Resume Next

    Do While Chart.SeriesCollection.Count > 0
        Chart.SeriesCollection(1).Delete
    Loop

    Dim valueRange As String, freqRange As String, specMinRange As String, specMaxRange As String, freqLineRange As String

    valueRange = ws.Range(ws.Cells(dataStartRow + 1, dataStartCol), ws.Cells(dataStartRow + dataCount, dataStartCol)).Address
    freqRange = ws.Range(ws.Cells(dataStartRow + 1, dataStartCol + 1), ws.Cells(dataStartRow + dataCount, dataStartCol + 1)).Address
    specMinRange = ws.Range(ws.Cells(dataStartRow + 1, dataStartCol + 2), ws.Cells(dataStartRow + dataCount, dataStartCol + 2)).Address
    specMaxRange = ws.Range(ws.Cells(dataStartRow + 1, dataStartCol + 3), ws.Cells(dataStartRow + dataCount, dataStartCol + 3)).Address
    freqLineRange = ws.Range(ws.Cells(dataStartRow + 1, dataStartCol + 4), ws.Cells(dataStartRow + dataCount, dataStartCol + 4)).Address

    ' 1. Frequency（藍色柱狀圖）
    Dim series1 As Series
    Set series1 = Chart.SeriesCollection.NewSeries
    series1.Name = "Frequency"
    series1.ChartType = xlColumnClustered
    series1.values = "=" & ws.Name & "!" & freqRange
    series1.XValues = "=" & ws.Name & "!" & valueRange
    series1.Format.Fill.ForeColor.RGB = RGB(68, 114, 196)

    ' 2. Freq Line（黃/橘色折線）
    Dim series2 As Series
    Set series2 = Chart.SeriesCollection.NewSeries
    series2.Name = "Freq Line"
    series2.ChartType = xlLineMarkers
    series2.values = "=" & ws.Name & "!" & freqLineRange
    series2.XValues = "=" & ws.Name & "!" & valueRange
    series2.Format.Line.ForeColor.RGB = RGB(255, 192, 0)
    series2.Format.Line.Weight = 2.5
    series2.MarkerStyle = xlMarkerStyleCircle
    series2.MarkerSize = 6
    series2.MarkerForegroundColor = RGB(255, 192, 0)

    ' 3. Spec Min（綠線）
    If specMin <> "" And specMin <> "*" Then
        Dim series3 As Series
        Set series3 = Chart.SeriesCollection.NewSeries
        series3.Name = "Spec Min " & specMin
        series3.ChartType = xlColumnClustered
        series3.values = "=" & ws.Name & "!" & specMinRange
        series3.XValues = "=" & ws.Name & "!" & valueRange
        series3.Format.Line.ForeColor.RGB = RGB(0, 176, 80)  ' 綠色
        series3.Format.Line.Weight = 2.5
        series3.Format.Fill.Transparency = 1
    End If

    ' 4. Spec Max（紅線）
    If specMax <> "" And specMax <> "*" Then
        Dim series4 As Series
        Set series4 = Chart.SeriesCollection.NewSeries
        series4.Name = "Spec Max " & specMax
        series4.ChartType = xlColumnClustered
        series4.values = "=" & ws.Name & "!" & specMaxRange
        series4.XValues = "=" & ws.Name & "!" & valueRange
        series4.Format.Line.ForeColor.RGB = RGB(255, 0, 0)  ' 紅色
        series4.Format.Line.Weight = 2.5
        series4.Format.Fill.Transparency = 1
    End If

    ' 圖表標題 = 讀值名稱
    Chart.HasTitle = True
    Chart.ChartTitle.Text = readingName
    Chart.ChartTitle.Font.Size = 12
    Chart.ChartTitle.Font.Bold = True

    Chart.Axes(xlCategory).HasTitle = True
    Chart.Axes(xlCategory).AxisTitle.Text = "Value"
    Chart.Axes(xlValue).HasTitle = True
    Chart.Axes(xlValue).AxisTitle.Text = "Frequency"

    Chart.ChartStyle = 201
    Chart.Legend.Position = xlLegendPositionBottom

    On Error GoTo 0
End Sub

' ========== 取消隱藏輔助函數 ==========

Sub UnhideDataColumns()
    Dim ws As Worksheet
    On Error Resume Next
    Set ws = ActiveWorkbook.Worksheets("分佈圖")
    On Error GoTo 0

    If Not ws Is Nothing Then
        ws.Range("A:E").Hidden = False
        MsgBox "已取消隱藏計算數據欄位（A-E）", vbInformation, "完成"
    End If
End Sub

Sub HideDataColumns()
    Dim ws As Worksheet
    On Error Resume Next
    Set ws = ActiveWorkbook.Worksheets("分佈圖")
    On Error GoTo 0

    If Not ws Is Nothing Then
        ws.Range("A:E").Hidden = True
        MsgBox "已隱藏計算數據欄位（A-E）", vbInformation, "完成"
    End If
End Sub
