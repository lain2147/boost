' ============================================================
' 分佈圖功能 - 完整修正乾淨版
' 最後更新：2025-12-07
'
' 主要功能：
'   1. 自動讀取 TXT 測試報告
'   2. 識別所有測試序列（Turn On, Hold Up, Combine, etc.）
'   3. 生成水平三區塊分佈圖：
'      - 左側（A-E欄，隱藏）：圖表資料
'      - 中間（F-G欄）：Spec 參數表
'      - 右側（H-O欄）：分佈圖
'   4. 智能 Spec 線條顯示（Max紅線/Min綠線）
'   5. Y軸整數刻度
'
' 使用方式：
'   執行 GenerateSEQDistributionCharts
'   選擇 TXT 測試報告檔案
'   自動生成分佈圖並儲存
' ============================================================

Option Explicit

' ========== 主控函數 ==========

Sub GenerateSEQDistributionCharts()
    Dim filePathArray As Variant
    Dim fileContent As String
    Dim lines() As String
    Dim startTime As Double

    startTime = Timer

    ' 選擇檔案
    filePathArray = Application.GetOpenFilename("Text Files (*.txt), *.txt", , "選擇測試報告檔案", , MultiSelect:=True)
    If Not IsArray(filePathArray) Then Exit Sub

    Application.ScreenUpdating = False
    Application.Calculation = xlCalculationManual
    Application.EnableEvents = False
    Application.DisplayStatusBar = True
    Application.StatusBar = "讀取檔案..."

    ' 讀取並合併檔案
    Dim fileCount As Long
    fileCount = UBound(filePathArray) - LBound(filePathArray) + 1

    If fileCount = 1 Then
        fileContent = ReadTextFile(CStr(filePathArray(LBound(filePathArray))))
    Else
        fileContent = MergeMultipleFiles(filePathArray)
    End If

    If fileContent = "" Then
        Application.StatusBar = False
        MsgBox "讀取檔案失敗！", vbCritical, "錯誤"
        GoTo CleanupAndExit
    End If

    Application.StatusBar = "解析測試數據..."
    lines = Split(fileContent, vbCrLf)

    Application.StatusBar = "識別測試序列..."
    Dim allSequences As Object
    Set allSequences = FindAllSequences(lines)

    If allSequences.count = 0 Then
        MsgBox "未找到測試序列！", vbExclamation, "警告"
        GoTo CleanupAndExit
    End If

    ' 創建新工作簿
    Application.StatusBar = "創建新工作簿..."
    Dim newWb As Workbook
    Set newWb = Workbooks.Add

    ' 創建分佈圖工作表
    Dim ws As Worksheet
    Set ws = newWb.Worksheets(1)
    ws.Name = "分佈圖"

    ' 生成所有序列的分佈圖
    Call CreateDistributionChartsForAllSequences(allSequences, lines, ws)

    ' 另存新檔
    Application.StatusBar = "準備存檔..."
    Dim modelName As String, customer As String, testDate As String, unitCount As Long
    Call ExtractHeaderInfo(lines, modelName, customer, "", testDate, unitCount)

    Dim savePath As String
    savePath = SaveDistributionChartFile(newWb, modelName, customer, testDate, unitCount)

    ' 顯示完成訊息
    Dim elapsedTime As Double
    elapsedTime = Timer - startTime
    Application.StatusBar = False

    If savePath <> "" Then
        MsgBox "分佈圖生成完成！" & vbCrLf & _
               "處理時間：" & Format(elapsedTime, "0.00") & " 秒" & vbCrLf & _
               "存檔路徑：" & savePath, _
               vbInformation, "完成"
    Else
        MsgBox "分佈圖生成完成！" & vbCrLf & _
               "處理時間：" & Format(elapsedTime, "0.00") & " 秒", _
               vbInformation, "完成"
    End If

CleanupAndExit:
    Application.ScreenUpdating = True
    Application.Calculation = xlCalculationAutomatic
    Application.EnableEvents = True
    Application.StatusBar = False
End Sub

' ========== 創建所有序列的分佈圖 ==========

Sub CreateDistributionChartsForAllSequences(allSequences As Object, lines() As String, ws As Worksheet)
    ' 清空工作表
    ws.Cells.Clear
    ws.ChartObjects.Delete

    ' SEQ 顏色陣列
    Dim seqColors As Variant
    seqColors = Array(RGB(68, 114, 196), RGB(112, 173, 71), RGB(255, 192, 0), _
                      RGB(91, 155, 213), RGB(237, 125, 49), RGB(165, 165, 165))

    Dim seqIndex As Variant
    Dim seqInfo As Object
    Dim currentRow As Long
    Dim seqCount As Long

    currentRow = 1
    seqCount = 0

    ' 逐一處理每個 SEQ
    For Each seqIndex In allSequences.Keys
        Set seqInfo = allSequences(seqIndex)
        Application.StatusBar = "生成分佈圖：" & seqInfo("type") & " - " & seqInfo("loadName")

        ' 選擇 SEQ 顏色
        Dim seqColor As Long
        seqColor = seqColors(seqCount Mod (UBound(seqColors) + 1))

        ' SEQ 標題（橫跨 A-O 欄）
        ws.Cells(currentRow, 1).Value = seqInfo("title")
        ws.Range(ws.Cells(currentRow, 1), ws.Cells(currentRow, 15)).Merge
        With ws.Cells(currentRow, 1)
            .Font.Bold = True
            .Font.Size = 14
            .Font.Color = seqColor
            .HorizontalAlignment = xlCenter
            .Interior.Color = RGB(242, 242, 242)
        End With
        ws.Rows(currentRow).RowHeight = 30

        currentRow = currentRow + 2  ' 標題後空1行

        ' 根據測試類型生成分佈圖
        Dim blockHeight As Long
        blockHeight = 0

        Select Case seqInfo("type")
            Case "LoadRegulation"
                blockHeight = CreateLoadRegulationDistributionCharts(ws, seqInfo, lines, currentRow)
            Case "TurnOn"
                blockHeight = CreateTurnOnDistributionCharts(ws, seqInfo, lines, currentRow)
            Case "HoldUp"
                blockHeight = CreateHoldUpDistributionCharts(ws, seqInfo, lines, currentRow)
            Case "ShortCircuit"
                blockHeight = CreateShortCircuitDistributionCharts(ws, seqInfo, lines, currentRow)
            Case "Combine"
                blockHeight = CreateCombineDistributionCharts(ws, seqInfo, lines, currentRow)
            Case "OLP"
                blockHeight = CreateOLPDistributionCharts(ws, seqInfo, lines, currentRow)
            Case "Dynamic"
                blockHeight = CreateDynamicDistributionCharts(ws, seqInfo, lines, currentRow)
            Case "InputOutput_Iin", "InputOutput_Pin", "InputOutput_Eff", "InputOutput_General"
                blockHeight = CreateInputOutputDistributionCharts(ws, seqInfo, lines, currentRow)
        End Select

        currentRow = currentRow + blockHeight + 3  ' 每個 SEQ 間隔 3 行
        seqCount = seqCount + 1
    Next seqIndex

    ' 隱藏計算數據欄位（A-E）
    ws.Columns("A:E").Hidden = True

    ' 設定基本格式
    ws.Cells.Font.Name = "Calibri"
    ws.Cells.Font.Size = 10
    ws.Activate
    ws.Range("F1").Select
End Sub

' ========== 各測試類型的分佈圖生成函數 ==========

Function CreateLoadRegulationDistributionCharts(ws As Worksheet, seqInfo As Object, lines() As String, startRow As Long) As Long
    Dim params As Object
    Set params = ExtractLoadRegulationParams(lines, seqInfo("startLine"), seqInfo("loadName"))
    Dim readData As Object
    Set readData = ExtractAllLoadRegulationReads(lines, seqInfo("title"))
    If readData.count = 0 Then
        CreateLoadRegulationDistributionCharts = 0
        Exit Function
    End If

    Dim currentRow As Long
    currentRow = startRow
    Dim readingNames As Variant
    readingNames = Array("VdcRead1", "VppRead1", "VnRead1", "VdcRead2", "VppRead2", "VnRead2", _
                        "VdcRead3", "VppRead3", "VnRead3", "dV21", "dV31")
    Dim readingName As Variant
    Dim blockHeight As Long

    For Each readingName In readingNames
        blockHeight = CreateSingleDistributionChart(ws, CStr(readingName), readData, currentRow, 1, params)
        If blockHeight > 0 Then currentRow = currentRow + blockHeight + 2
    Next readingName

    CreateLoadRegulationDistributionCharts = currentRow - startRow
End Function

Function CreateTurnOnDistributionCharts(ws As Worksheet, seqInfo As Object, lines() As String, startRow As Long) As Long
    Dim params As Object
    Set params = ExtractTurnOnParams(lines, seqInfo("startLine"), seqInfo("loadName"))
    Dim readData As Object
    Set readData = ExtractAllTonReads(lines, seqInfo("title"))
    If readData.count = 0 Then
        CreateTurnOnDistributionCharts = 0
        Exit Function
    End If

    Dim blockHeight As Long
    blockHeight = CreateSingleDistributionChart(ws, "Reading", readData, startRow, 1, params)
    CreateTurnOnDistributionCharts = blockHeight
End Function

Function CreateHoldUpDistributionCharts(ws As Worksheet, seqInfo As Object, lines() As String, startRow As Long) As Long
    Dim params As Object
    Set params = ExtractHoldUpParams(lines, seqInfo("startLine"), seqInfo("loadName"))
    Dim readData As Object
    Set readData = ExtractAllHoldUpReads(lines, seqInfo("title"))
    If readData.count = 0 Then
        CreateHoldUpDistributionCharts = 0
        Exit Function
    End If

    Dim currentRow As Long
    currentRow = startRow
    Dim readingNames As Variant
    readingNames = Array("Tds", "Tdl")
    Dim readingName As Variant
    Dim blockHeight As Long

    For Each readingName In readingNames
        blockHeight = CreateSingleDistributionChart(ws, CStr(readingName), readData, currentRow, 1, params)
        If blockHeight > 0 Then currentRow = currentRow + blockHeight + 2
    Next readingName

    CreateHoldUpDistributionCharts = currentRow - startRow
End Function

Function CreateShortCircuitDistributionCharts(ws As Worksheet, seqInfo As Object, lines() As String, startRow As Long) As Long
    Dim params As Object
    Set params = ExtractShortCircuitParams(lines, seqInfo("startLine"), seqInfo("loadName"))
    Dim readData As Object
    Set readData = ExtractAllPinReads(lines, seqInfo("title"))
    If readData.count = 0 Then
        CreateShortCircuitDistributionCharts = 0
        Exit Function
    End If

    Dim blockHeight As Long
    blockHeight = CreateSingleDistributionChart(ws, "Pin", readData, startRow, 1, params)
    CreateShortCircuitDistributionCharts = blockHeight
End Function

Function CreateCombineDistributionCharts(ws As Worksheet, seqInfo As Object, lines() As String, startRow As Long) As Long
    Dim params As Object
    Set params = ExtractCombineParams(lines, seqInfo("startLine"), seqInfo("loadName"))
    Dim readData As Object
    Set readData = ExtractAllCombineReads(lines, seqInfo("title"))
    If readData.count = 0 Then
        CreateCombineDistributionCharts = 0
        Exit Function
    End If

    Dim currentRow As Long
    currentRow = startRow
    Dim readingNames As Variant
    readingNames = Array("Vdc1", "Vpp1", "Vdc2", "Vpp2", "Vdc3", "Vpp3")
    Dim readingName As Variant
    Dim blockHeight As Long

    For Each readingName In readingNames
        blockHeight = CreateSingleDistributionChart(ws, CStr(readingName), readData, currentRow, 1, params)
        If blockHeight > 0 Then currentRow = currentRow + blockHeight + 2
    Next readingName

    CreateCombineDistributionCharts = currentRow - startRow
End Function

Function CreateOLPDistributionCharts(ws As Worksheet, seqInfo As Object, lines() As String, startRow As Long) As Long
    Dim params As Object
    Set params = ExtractOLPParams(lines, seqInfo("startLine"), seqInfo("loadName"))
    Dim readData As Object
    Set readData = ExtractAllOLPReads(lines, seqInfo("title"))
    If readData.count = 0 Then
        CreateOLPDistributionCharts = 0
        Exit Function
    End If

    Dim blockHeight As Long
    blockHeight = CreateSingleDistributionChart(ws, "Reading", readData, startRow, 1, params)
    CreateOLPDistributionCharts = blockHeight
End Function

Function CreateDynamicDistributionCharts(ws As Worksheet, seqInfo As Object, lines() As String, startRow As Long) As Long
    Dim params As Object
    Set params = ExtractDynamicParams(lines, seqInfo("startLine"), seqInfo("loadName"))
    Dim readData As Object
    Set readData = ExtractAllDynamicReads(lines, seqInfo("title"))
    If readData.count = 0 Then
        CreateDynamicDistributionCharts = 0
        Exit Function
    End If

    Dim currentRow As Long
    currentRow = startRow
    Dim readingNames As Variant
    readingNames = Array("Vs1", "Vs2")
    Dim readingName As Variant
    Dim blockHeight As Long

    For Each readingName In readingNames
        blockHeight = CreateSingleDistributionChart(ws, CStr(readingName), readData, currentRow, 1, params)
        If blockHeight > 0 Then currentRow = currentRow + blockHeight + 2
    Next readingName

    CreateDynamicDistributionCharts = currentRow - startRow
End Function

Function CreateInputOutputDistributionCharts(ws As Worksheet, seqInfo As Object, lines() As String, startRow As Long) As Long
    Dim params As Object
    Set params = ExtractInputOutputParams(lines, seqInfo("startLine"), seqInfo("loadName"), seqInfo("type"))
    Dim readData As Object
    Set readData = ExtractAllInputOutputReads(lines, seqInfo("title"), seqInfo("type"))
    If readData.count = 0 Then
        CreateInputOutputDistributionCharts = 0
        Exit Function
    End If

    Dim currentRow As Long
    currentRow = startRow
    Dim readingNames As Variant
    readingNames = Array("Iinrms", "Pin", "Pdc", "Eff", "Pf", "Idc", "Vdc", "Vpp", "VinRead")
    Dim readingName As Variant
    Dim blockHeight As Long

    For Each readingName In readingNames
        ' 檢查是否有該讀值
        Dim hasReading As Boolean
        hasReading = False
        Dim snKey As Variant
        For Each snKey In readData.Keys
            If readData(snKey).Exists(CStr(readingName)) Then
                Dim val As Variant
                val = readData(snKey)(CStr(readingName))
                If val <> "" And val <> "*" Then
                    hasReading = True
                    Exit For
                End If
            End If
        Next snKey

        If hasReading Then
            blockHeight = CreateSingleDistributionChart(ws, CStr(readingName), readData, currentRow, 1, params)
            If blockHeight > 0 Then currentRow = currentRow + blockHeight + 2
        End If
    Next readingName

    CreateInputOutputDistributionCharts = currentRow - startRow
End Function

' ========== 核心圖表生成函數 ==========

Function CreateSingleDistributionChart(ws As Worksheet, _
                                      readingName As String, _
                                      readData As Object, _
                                      blockRow As Long, _
                                      blockCol As Long, _
                                      params As Object) As Long
    ' 返回值：佔用的列數

    On Error Resume Next

    ' 收集讀值
    Dim readingValues As Collection
    Set readingValues = CollectReadingValues(readData, readingName)
    If readingValues.count = 0 Then
        CreateSingleDistributionChart = 0
        Exit Function
    End If

    ' 取得 Spec
    Dim specMax As Variant, specMin As Variant
    specMax = ""
    specMin = ""
    Call GetSpecForReading(readingName, params, specMax, specMin)

    ' 處理數據
    Dim processedData As Collection
    Set processedData = ProcessReadingValues(readingValues)
    If processedData.count = 0 Then
        CreateSingleDistributionChart = 0
        Exit Function
    End If

    ' 計算頻率
    Dim freqData As Object
    Set freqData = CalculateFrequencyData(readingValues, processedData)

    ' 寫入資料表（A-E欄 + F-G欄參數表）
    Dim tableHeight As Long
    tableHeight = WriteDistributionDataToSheet(ws, freqData, specMax, specMin, blockRow, blockCol, readingName)

    ' 創建圖表（H欄開始）
    Dim chartTopLeftCell As Range
    Set chartTopLeftCell = ws.Cells(blockRow, blockCol + 7)  ' 第8欄（H欄）

    Dim chartObj As ChartObject
    Set chartObj = CreateChartSafely(ws, chartTopLeftCell, 450, 280)

    If chartObj Is Nothing Then
        CreateSingleDistributionChart = tableHeight
        Exit Function
    End If

    ' 配置圖表
    Call ConfigureDistributionChart(chartObj.Chart, ws, readingName, blockRow, blockCol, tableHeight, specMax, specMin)

    ' 返回最大高度
    Dim chartRowHeight As Long
    chartRowHeight = 18

    If chartRowHeight > tableHeight Then
        CreateSingleDistributionChart = chartRowHeight
    Else
        CreateSingleDistributionChart = tableHeight
    End If
End Function

' ========== 圖表創建函數 ==========

Function CreateChartSafely(ws As Worksheet, _
                          topLeftCell As Range, _
                          chartWidth As Double, _
                          chartHeight As Double) As ChartObject
    ' 使用儲存格錨點方式創建圖表（最穩定）

    On Error Resume Next

    Dim chartObj As ChartObject
    Set chartObj = ws.ChartObjects.Add( _
        Left:=topLeftCell.Left, _
        Top:=topLeftCell.Top, _
        Width:=chartWidth, _
        Height:=chartHeight)

    If Err.Number <> 0 Then
        Debug.Print "CreateChartSafely 錯誤：" & Err.Description
        Set CreateChartSafely = Nothing
    Else
        Set CreateChartSafely = chartObj
    End If

    On Error GoTo 0
End Function

' ========== 資料表生成函數 ==========

Function WriteDistributionDataToSheet(ws As Worksheet, _
                                      freqData As Object, _
                                      specMax As Variant, _
                                      specMin As Variant, _
                                      startRow As Long, _
                                      startCol As Long, _
                                      readingName As String) As Long
    ' 返回值：佔用的列數（最大高度）

    On Error Resume Next

    ' ===== 1. 建立完整數據集合 =====
    Dim allData As Object
    Set allData = CreateObject("Scripting.Dictionary")

    ' 添加頻率數據
    Dim key As Variant
    For Each key In freqData.Keys
        Dim valueLabel As String
        valueLabel = Format(CDbl(key), "0.000")
        allData.Add valueLabel, Array(CDbl(key), freqData(key), "normal", 0, 0)
        ' 格式：(數值, 頻率, 類型, SpecMaxBar, SpecMinBar)
    Next key

    ' 計算最大頻率
    Dim maxFreq As Long
    maxFreq = 0
    For Each key In freqData.Keys
        If freqData(key) > maxFreq Then maxFreq = freqData(key)
    Next key

    ' 添加 Spec Max 特殊點
    If specMax <> "" And specMax <> "*" Then
        Dim maxLabel As String
        maxLabel = Format(CDbl(specMax), "0.000")

        If Not allData.Exists(maxLabel) Then
            allData.Add maxLabel, Array(CDbl(specMax), 0, "max", maxFreq, 0)
        Else
            Dim existData As Variant
            existData = allData(maxLabel)
            allData(maxLabel) = Array(existData(0), existData(1), "max", maxFreq, 0)
        End If
    End If

    ' 添加 Spec Min 特殊點
    If specMin <> "" And specMin <> "*" Then
        Dim minLabel As String
        minLabel = Format(CDbl(specMin), "0.000")

        If Not allData.Exists(minLabel) Then
            allData.Add minLabel, Array(CDbl(specMin), 0, "min", 0, maxFreq)
        Else
            existData = allData(minLabel)
            allData(minLabel) = Array(existData(0), existData(1), "min", 0, maxFreq)
        End If
    End If

    ' ===== 2. 排序（從大到小）=====
    Dim sortedLabels() As String
    Dim sortedValues() As Double
    ReDim sortedLabels(1 To allData.count)
    ReDim sortedValues(1 To allData.count)

    Dim idx As Long
    idx = 1
    For Each key In allData.Keys
        sortedLabels(idx) = CStr(key)
        sortedValues(idx) = allData(key)(0)
        idx = idx + 1
    Next key

    ' 氣泡排序
    Dim i As Long, j As Long
    Dim tempLabel As String, tempValue As Double
    For i = 1 To UBound(sortedValues) - 1
        For j = i + 1 To UBound(sortedValues)
            If sortedValues(i) < sortedValues(j) Then
                tempLabel = sortedLabels(i)
                sortedLabels(i) = sortedLabels(j)
                sortedLabels(j) = tempLabel

                tempValue = sortedValues(i)
                sortedValues(i) = sortedValues(j)
                sortedValues(j) = tempValue
            End If
        Next j
    Next i

    ' ===== 3. 寫入區塊1：圖表資料（5欄）=====
    Dim dataCol As Long
    dataCol = startCol

    ' 表頭
    ws.Cells(startRow, dataCol).Value = "Value"
    ws.Cells(startRow, dataCol + 1).Value = "Frequency"
    ws.Cells(startRow, dataCol + 2).Value = "SpecMaxBar"
    ws.Cells(startRow, dataCol + 3).Value = "SpecMinBar"
    ws.Cells(startRow, dataCol + 4).Value = "FreqLine"

    With ws.Range(ws.Cells(startRow, dataCol), ws.Cells(startRow, dataCol + 4))
        .Font.Bold = True
        .Interior.Color = RGB(68, 114, 196)
        .Font.Color = RGB(255, 255, 255)
        .HorizontalAlignment = xlCenter
    End With

    ' 設置欄寬
    ws.Columns(dataCol).ColumnWidth = 12
    ws.Columns(dataCol + 1).ColumnWidth = 10
    ws.Columns(dataCol + 2).ColumnWidth = 10
    ws.Columns(dataCol + 3).ColumnWidth = 10
    ws.Columns(dataCol + 4).ColumnWidth = 10

    ' 寫入數據
    Dim row As Long
    row = startRow + 1

    For i = 1 To UBound(sortedLabels)
        Dim dataLabel As String
        dataLabel = sortedLabels(i)

        Dim dataInfo As Variant
        dataInfo = allData(dataLabel)

        ws.Cells(row, dataCol).Value = dataInfo(0)
        ws.Cells(row, dataCol + 1).Value = dataInfo(1)
        ws.Cells(row, dataCol + 2).Value = dataInfo(3)
        ws.Cells(row, dataCol + 3).Value = dataInfo(4)
        ws.Cells(row, dataCol + 4).Value = dataInfo(1)

        Dim dataType As String
        dataType = dataInfo(2)

        If dataType = "max" Then
            ws.Cells(row, dataCol).Font.Color = RGB(255, 0, 0)
            ws.Cells(row, dataCol).Font.Bold = True
        ElseIf dataType = "min" Then
            ws.Cells(row, dataCol).Font.Color = RGB(0, 176, 80)
            ws.Cells(row, dataCol).Font.Bold = True
        End If

        row = row + 1
    Next i

    Dim dataTableHeight As Long
    dataTableHeight = row - startRow

    ' ===== 4. 寫入區塊2：參數表（F-G欄）=====
    Dim hasParams As Boolean
    hasParams = (specMax <> "" And specMax <> "*") Or (specMin <> "" And specMin <> "*")

    Dim paramTableHeight As Long
    paramTableHeight = 0

    If hasParams Then
        Dim paramCol As Long
        paramCol = dataCol + 5  ' A-E 後的第 6 欄（F欄）

        ' 表頭
        ws.Cells(startRow, paramCol).Value = "Condition"
        ws.Cells(startRow, paramCol + 1).Value = "Value"

        With ws.Range(ws.Cells(startRow, paramCol), ws.Cells(startRow, paramCol + 1))
            .Font.Bold = True
            .Interior.Color = RGB(255, 224, 178)
            .HorizontalAlignment = xlCenter
        End With

        ws.Columns(paramCol).ColumnWidth = 15
        ws.Columns(paramCol + 1).ColumnWidth = 12

        Dim paramRow As Long
        paramRow = startRow + 1

        ' 根據讀值名稱確定參數名稱
        Dim maxParamName As String, minParamName As String
        Call GetParamNamesForReading(readingName, maxParamName, minParamName)

        ' 寫入 Max 參數
        If specMax <> "" And specMax <> "*" Then
            ws.Cells(paramRow, paramCol).Value = maxParamName
            ws.Cells(paramRow, paramCol + 1).Value = specMax

            ws.Cells(paramRow, paramCol).Font.Color = RGB(255, 0, 0)
            ws.Cells(paramRow, paramCol + 1).Font.Color = RGB(255, 0, 0)
            ws.Cells(paramRow, paramCol).Font.Bold = True
            ws.Cells(paramRow, paramCol + 1).Font.Bold = True

            paramRow = paramRow + 1
        End If

        ' 寫入 Min 參數
        If specMin <> "" And specMin <> "*" Then
            ws.Cells(paramRow, paramCol).Value = minParamName
            ws.Cells(paramRow, paramCol + 1).Value = specMin

            ws.Cells(paramRow, paramCol).Font.Color = RGB(0, 176, 80)
            ws.Cells(paramRow, paramCol + 1).Font.Color = RGB(0, 176, 80)
            ws.Cells(paramRow, paramCol).Font.Bold = True
            ws.Cells(paramRow, paramCol + 1).Font.Bold = True

            paramRow = paramRow + 1
        End If

        paramTableHeight = paramRow - startRow
    End If

    ' 返回最大高度
    If paramTableHeight > dataTableHeight Then
        WriteDistributionDataToSheet = paramTableHeight
    Else
        WriteDistributionDataToSheet = dataTableHeight
    End If
End Function

' ========== 圖表配置函數 ==========

Sub ConfigureDistributionChart(ch As Chart, _
                               ws As Worksheet, _
                               readingName As String, _
                               dataStartRow As Long, _
                               dataStartCol As Long, _
                               dataCount As Long, _
                               specMax As Variant, _
                               specMin As Variant)

    On Error GoTo ErrorHandler

    ' 清除預設 Series
    Do While ch.SeriesCollection.count > 0
        ch.SeriesCollection(1).Delete
    Loop

    ' 確定資料範圍
    Dim lastRow As Long
    lastRow = dataStartRow + dataCount - 1

    If lastRow <= dataStartRow Then Exit Sub

    ' 定義範圍
    Dim valueRng As Range, freqRng As Range, specMaxRng As Range, specMinRng As Range, freqLineRng As Range

    Set valueRng = ws.Range(ws.Cells(dataStartRow + 1, dataStartCol), ws.Cells(lastRow, dataStartCol))
    Set freqRng = ws.Range(ws.Cells(dataStartRow + 1, dataStartCol + 1), ws.Cells(lastRow, dataStartCol + 1))
    Set specMaxRng = ws.Range(ws.Cells(dataStartRow + 1, dataStartCol + 2), ws.Cells(lastRow, dataStartCol + 2))
    Set specMinRng = ws.Range(ws.Cells(dataStartRow + 1, dataStartCol + 3), ws.Cells(lastRow, dataStartCol + 3))
    Set freqLineRng = ws.Range(ws.Cells(dataStartRow + 1, dataStartCol + 4), ws.Cells(lastRow, dataStartCol + 4))

    ' ===== 1. 柱狀圖：Frequency =====
    Dim s As Series
    Set s = ch.SeriesCollection.NewSeries
    s.Name = "Frequency"
    s.values = freqRng
    s.XValues = valueRng
    s.ChartType = xlColumnClustered
    s.AxisGroup = xlPrimary
    s.Format.Fill.ForeColor.RGB = RGB(68, 114, 196)

    ' ===== 2. 折線：FreqLine =====
    Set s = ch.SeriesCollection.NewSeries
    s.Name = "Trend"
    s.values = freqLineRng
    s.XValues = valueRng
    s.ChartType = xlLine
    s.AxisGroup = xlPrimary
    With s.Format.Line
        .Weight = 2
        .ForeColor.RGB = RGB(237, 125, 49)
    End With
    s.MarkerStyle = xlMarkerStyleCircle
    s.MarkerSize = 5

    ' ===== 3. Spec Max 紅線 =====
    If specMax <> "" And specMax <> "*" Then
        Dim hasMaxData As Boolean
        hasMaxData = False
        Dim i As Long
        For i = dataStartRow + 1 To lastRow
            If ws.Cells(i, dataStartCol + 2).Value > 0 Then
                hasMaxData = True
                Exit For
            End If
        Next i

        If hasMaxData Then
            Set s = ch.SeriesCollection.NewSeries
            s.Name = "Spec Max = " & specMax
            s.values = specMaxRng
            s.XValues = valueRng
            s.ChartType = xlLine
            s.AxisGroup = xlPrimary
            With s.Format.Line
                .Weight = 2.5
                .ForeColor.RGB = RGB(255, 0, 0)
                .DashStyle = msoLineDash
            End With
            s.MarkerStyle = xlMarkerStyleNone
        End If
    End If

    ' ===== 4. Spec Min 綠線 =====
    If specMin <> "" And specMin <> "*" Then
        Dim hasMinData As Boolean
        hasMinData = False
        For i = dataStartRow + 1 To lastRow
            If ws.Cells(i, dataStartCol + 3).Value > 0 Then
                hasMinData = True
                Exit For
            End If
        Next i

        If hasMinData Then
            Set s = ch.SeriesCollection.NewSeries
            s.Name = "Spec Min = " & specMin
            s.values = specMinRng
            s.XValues = valueRng
            s.ChartType = xlLine
            s.AxisGroup = xlPrimary
            With s.Format.Line
                .Weight = 2.5
                .ForeColor.RGB = RGB(0, 176, 80)
                .DashStyle = msoLineDash
            End With
            s.MarkerStyle = xlMarkerStyleNone
        End If
    End If

    ' ===== 5. 設定圖表標題與座標軸 =====
    ch.HasTitle = True
    ch.chartTitle.text = readingName & " Distribution"
    ch.chartTitle.Font.Size = 12
    ch.chartTitle.Font.Bold = True

    ' X 軸
    With ch.Axes(xlCategory)
        .HasTitle = True
        .AxisTitle.text = "Value"
        .AxisTitle.Font.Size = 10
    End With

    ' Y 軸（整數刻度）
    With ch.Axes(xlValue, xlPrimary)
        .HasTitle = True
        .AxisTitle.text = "Frequency"
        .AxisTitle.Font.Size = 10
        .MinimumScale = 0
        .MajorUnit = 1
        .MinorUnit = 1
        .TickLabels.NumberFormat = "0"
    End With

    ' 圖例
    ch.HasLegend = True
    ch.Legend.Position = xlLegendPositionBottom
    ch.Legend.Font.Size = 9

    Exit Sub

ErrorHandler:
    Debug.Print "ConfigureDistributionChart 錯誤：" & Err.Description
End Sub

' ========== 智能參數匹配函數 ==========

Sub GetSpecForReading(readingName As String, params As Object, ByRef specMax As Variant, ByRef specMin As Variant)
    Dim baseName As String
    baseName = readingName
    Dim i As Integer
    For i = Len(baseName) To 1 Step -1
        If Not IsNumeric(Mid(baseName, i, 1)) Then
            baseName = Left(baseName, i)
            Exit For
        End If
    Next i
    If Right(baseName, 4) = "Read" Then baseName = Left(baseName, Len(baseName) - 4)

    Dim maxKey As String, minKey As String
    Select Case baseName
        Case "Vdc", "VdcRead": maxKey = "VdcMax": minKey = "VdcMin"
        Case "Vpp", "VppRead": maxKey = "VppMax": minKey = "VppMin"
        Case "Vn", "VnRead": maxKey = "VnMax": minKey = "VnMin"
        Case "Tds": maxKey = "TdsMax": minKey = "TdsMin"
        Case "Tdl": maxKey = "TdlMax": minKey = "TdlMin"
        Case "Pin": maxKey = "PinMax": minKey = "PinMin"
        Case "Vs": maxKey = "VsMax": minKey = "VsMin"
        Case "Reading": maxKey = "TonMax": minKey = ""
        Case "Idc", "Iinrms": maxKey = "IinrmsMax": minKey = ""
        Case "Eff": maxKey = "": minKey = "EffMin"
        Case "Vin", "VinRead": maxKey = "VinMax": minKey = "VinMin"
        Case "dV21", "dV31": maxKey = "": minKey = ""
        Case Else: maxKey = baseName & "Max": minKey = baseName & "Min"
    End Select

    If maxKey <> "" And params.Exists(maxKey) Then specMax = params(maxKey)
    If minKey <> "" And params.Exists(minKey) Then specMin = params(minKey)
End Sub

Sub GetParamNamesForReading(readingName As String, _
                            ByRef maxParamName As String, _
                            ByRef minParamName As String)
    Dim baseName As String
    baseName = readingName
    Dim i As Integer
    For i = Len(baseName) To 1 Step -1
        If Not IsNumeric(Mid(baseName, i, 1)) Then
            baseName = Left(baseName, i)
            Exit For
        End If
    Next i
    If Right(baseName, 4) = "Read" Then baseName = Left(baseName, Len(baseName) - 4)

    Select Case baseName
        Case "Vdc", "VdcRead": maxParamName = "VdcMax": minParamName = "VdcMin"
        Case "Vpp", "VppRead": maxParamName = "VppMax": minParamName = "VppMin"
        Case "Vn", "VnRead": maxParamName = "VnMax": minParamName = "VnMin"
        Case "Tds": maxParamName = "TdsMax": minParamName = "TdsMin"
        Case "Tdl": maxParamName = "TdlMax": minParamName = "TdlMin"
        Case "Pin": maxParamName = "PinMax": minParamName = "PinMin"
        Case "Vs": maxParamName = "VsMax": minParamName = "VsMin"
        Case "Reading": maxParamName = "TonMax": minParamName = ""
        Case "Idc", "Iinrms": maxParamName = "IinrmsMax": minParamName = ""
        Case "Eff": maxParamName = "": minParamName = "EffMin"
        Case "Vin", "VinRead": maxParamName = "VinMax": minParamName = "VinMin"
        Case "dV21", "dV31": maxParamName = "": minParamName = ""
        Case Else: maxParamName = baseName & "Max": minParamName = baseName & "Min"
    End Select
End Sub

' ========== 輔助函數 ==========

Function CollectReadingValues(readData As Object, readingName As String) As Collection
    Dim values As New Collection
    Dim snKey As Variant
    For Each snKey In readData.Keys
        Dim Value As Variant
        Dim cleanValue As String

        On Error Resume Next
        Dim isDict As Boolean
        isDict = False
        If TypeName(readData(snKey)) = "Dictionary" Then
            isDict = True
        End If
        On Error GoTo 0

        If isDict Then
            If readData(snKey).Exists(readingName) Then
                Value = readData(snKey)(readingName)
                If Not IsEmpty(Value) And Value <> "" Then
                    cleanValue = CleanNumericValue(CStr(Value))
                    If IsNumeric(cleanValue) And cleanValue <> "" Then
                        values.Add CDbl(cleanValue)
                    End If
                End If
            End If
        Else
            Value = readData(snKey)
            If Not IsEmpty(Value) And Value <> "" Then
                cleanValue = CleanNumericValue(CStr(Value))
                If IsNumeric(cleanValue) And cleanValue <> "" Then
                    values.Add CDbl(cleanValue)
                End If
            End If
        End If
    Next snKey
    Set CollectReadingValues = values
End Function

Function ProcessReadingValues(values As Collection) As Collection
    Dim processed As New Collection
    Dim uniqueDict As Object
    Set uniqueDict = CreateObject("Scripting.Dictionary")
    Dim Value As Variant
    For Each Value In values
        Dim rounded As Double
        rounded = RoundByValueRange(CDbl(Value))
        If Not uniqueDict.Exists(rounded) Then
            uniqueDict.Add rounded, True
            processed.Add rounded
        End If
    Next Value
    Set ProcessReadingValues = SortCollection(processed)
End Function

Function RoundByValueRange(Value As Double) As Double
    Dim absValue As Double
    absValue = Abs(Value)
    If absValue >= 1 Then
        RoundByValueRange = Round(Value, 2)
    Else
        Dim valueStr As String
        valueStr = CStr(Value)
        If InStr(valueStr, ".") = 0 Then
            RoundByValueRange = Value
            Exit Function
        End If
        Dim decimalPart As String
        decimalPart = Split(valueStr, ".")(1)
        If Len(decimalPart) <= 3 Then
            RoundByValueRange = Value
        Else
            RoundByValueRange = Round(Value, 3)
        End If
    End If
End Function

Function SortCollection(coll As Collection) As Collection
    Dim sorted As New Collection
    Dim arr() As Double
    Dim i As Long, j As Long, temp As Double
    ReDim arr(1 To coll.count)
    For i = 1 To coll.count
        arr(i) = coll(i)
    Next i
    For i = 1 To UBound(arr) - 1
        For j = i + 1 To UBound(arr)
            If arr(i) > arr(j) Then
                temp = arr(i): arr(i) = arr(j): arr(j) = temp
            End If
        Next j
    Next i
    For i = 1 To UBound(arr)
        sorted.Add arr(i)
    Next i
    Set SortCollection = sorted
End Function

Function CalculateFrequencyData(originalValues As Collection, uniqueValues As Collection) As Object
    Dim freqDict As Object
    Set freqDict = CreateObject("Scripting.Dictionary")
    Dim uniqueVal As Variant, origVal As Variant, count As Long
    For Each uniqueVal In uniqueValues
        count = 0
        For Each origVal In originalValues
            Dim roundedOrigVal As Double
            roundedOrigVal = RoundByValueRange(CDbl(origVal))
            If Abs(roundedOrigVal - CDbl(uniqueVal)) < 0.0001 Then count = count + 1
        Next origVal
        freqDict.Add uniqueVal, count
    Next uniqueVal
    Set CalculateFrequencyData = freqDict
End Function

Function CleanNumericValue(Value As String) As String
    Dim cleaned As String
    cleaned = Trim(Value)
    cleaned = Replace(cleaned, "?", "")
    cleaned = Trim(cleaned)
    CleanNumericValue = cleaned
End Function

' ========== 存檔函數 ==========

Function SaveDistributionChartFile(wb As Workbook, modelName As String, customer As String, testDate As String, unitCount As Long) As String
    Dim fileName As String, savePath As String, baseFileName As String
    Dim dirPath As String, finalPath As String
    Dim parts() As String
    Dim partCount As Integer

    partCount = 0
    ReDim parts(0 To 3)

    If IsValidFieldValue(modelName) Then
        parts(partCount) = Trim(modelName)
        partCount = partCount + 1
    End If

    If IsValidFieldValue(customer) Then
        parts(partCount) = Trim(customer)
        partCount = partCount + 1
    End If

    If testDate <> "" Then
        parts(partCount) = Trim(testDate)
        partCount = partCount + 1
    End If

    parts(partCount) = CStr(unitCount) & "pcs_DistributionChart"
    partCount = partCount + 1

    ReDim Preserve parts(0 To partCount - 1)
    baseFileName = Join(parts, "_")
    baseFileName = CleanFileName(baseFileName)
    fileName = baseFileName & ".xlsx"

    savePath = Application.GetSaveAsFilename( _
        InitialFileName:=fileName, _
        FileFilter:="Excel Files (*.xlsx), *.xlsx", _
        Title:="儲存分佈圖檔案")

    If savePath = "False" Then
        SaveDistributionChartFile = ""
        wb.Close SaveChanges:=False
        Exit Function
    End If

    Dim lastSlash As Long
    lastSlash = InStrRev(savePath, "\")
    If lastSlash = 0 Then lastSlash = InStrRev(savePath, "/")

    If lastSlash > 0 Then
        dirPath = Left(savePath, lastSlash)
        fileName = Mid(savePath, lastSlash + 1)
    Else
        dirPath = ""
        fileName = savePath
    End If

    fileName = CleanFileName(fileName)
    finalPath = dirPath & fileName
    savePath = finalPath

    Dim counter As Integer, basePath As String, ext As String
    basePath = Left(savePath, InStrRev(savePath, ".") - 1)
    ext = Mid(savePath, InStrRev(savePath, "."))
    counter = 1

    While Dir(savePath) <> ""
        counter = counter + 1
        savePath = basePath & "_" & counter & ext
    Wend

    On Error Resume Next
    wb.SaveAs fileName:=savePath, FileFormat:=xlOpenXMLWorkbook

    If Err.Number = 0 Then
        SaveDistributionChartFile = savePath
    Else
        MsgBox "存檔錯誤: " & Err.Description, vbCritical, "Error"
        SaveDistributionChartFile = ""
        wb.Close SaveChanges:=False
    End If
    On Error GoTo 0
End Function

Function IsValidFieldValue(fieldValue As String) As Boolean
    If Trim(fieldValue) = "" Then
        IsValidFieldValue = False
        Exit Function
    End If

    Dim cleaned As String
    cleaned = fieldValue
    cleaned = Replace(cleaned, "/", "")
    cleaned = Replace(cleaned, "\", "")
    cleaned = Replace(cleaned, ":", "")
    cleaned = Replace(cleaned, "*", "")
    cleaned = Replace(cleaned, "?", "")
    cleaned = Replace(cleaned, """", "")
    cleaned = Replace(cleaned, "<", "")
    cleaned = Replace(cleaned, ">", "")
    cleaned = Trim(cleaned)

    If cleaned = "" Then
        IsValidFieldValue = False
    Else
        IsValidFieldValue = True
    End If
End Function

Function CleanFileName(fileName As String) As String
    Dim invalidChars As String, i As Integer, result As String

    result = Trim(fileName)
    invalidChars = "\/:*?""<>|"
    For i = 1 To Len(invalidChars)
        result = Replace(result, Mid(invalidChars, i, 1), "_")
    Next i

    While InStr(result, "  ") > 0
        result = Replace(result, "  ", " ")
    Wend

    While InStr(result, "__") > 0
        result = Replace(result, "__", "_")
    Wend

    result = Replace(result, "_ ", "_")
    result = Replace(result, " _", "_")

    While Left(result, 1) = "_"
        result = Mid(result, 2)
    Wend
    While Right(result, 1) = "_"
        result = Left(result, Len(result) - 1)
    Wend

    If Len(result) > 100 Then result = Left(result, 100)

    CleanFileName = result
End Function


' ========== TXT 解析函數（從原檔案整合）==========

Function FindAllSequences(lines() As String) As Object
    Dim seqList As Object
    Set seqList = CreateObject("Scripting.Dictionary")
    
    Dim i As Long
    Dim serialCount As Integer
    Dim inFirstUnit As Boolean
    Dim seqTitle As String
    Dim seqStartLine As Long
    Dim loadName As String
    Dim seqType As String
    
    serialCount = 0
    inFirstUnit = False
    
    For i = 0 To UBound(lines)
        If InStr(lines(i), "Serial No") > 0 Then
            serialCount = serialCount + 1
            If serialCount = 1 Then
                inFirstUnit = True
            ElseIf serialCount = 2 Then
                inFirstUnit = False
                Exit For
            End If
        End If
        
        If inFirstUnit And InStr(lines(i), "Turn On") > 0 And InStr(lines(i), "SEQ.") > 0 Then
            If InStr(UCase(lines(i)), "INRUSH") = 0 Then
                seqTitle = Trim(lines(i))
                seqStartLine = i
                seqType = "TurnOn"
                loadName = ExtractLoadNameFromSeq(lines, seqStartLine)
                
                Dim seqInfo As Object
                Set seqInfo = CreateObject("Scripting.Dictionary")
                seqInfo("title") = seqTitle
                seqInfo("startLine") = seqStartLine
                seqInfo("loadName") = loadName
                seqInfo("type") = seqType
                Set seqInfo("params") = ExtractTurnOnParams(lines, seqStartLine, loadName)
                seqList.Add seqList.count, seqInfo
            End If
        End If
        
        If inFirstUnit And InStr(lines(i), "Hold Up") > 0 And InStr(lines(i), "SEQ.") > 0 Then
            seqTitle = Trim(lines(i))
            seqStartLine = i
            seqType = "HoldUp"
            loadName = ExtractLoadNameFromSeq(lines, seqStartLine)
            
            Set seqInfo = CreateObject("Scripting.Dictionary")
            seqInfo("title") = seqTitle
            seqInfo("startLine") = seqStartLine
            seqInfo("loadName") = loadName
            seqInfo("type") = seqType
            Set seqInfo("params") = ExtractHoldUpParams(lines, seqStartLine, loadName)
            seqList.Add seqList.count, seqInfo
        End If
        
        If inFirstUnit And InStr(lines(i), "Short Circuit") > 0 And InStr(lines(i), "SEQ.") > 0 Then
            seqTitle = Trim(lines(i))
            seqStartLine = i
            seqType = "ShortCircuit"
            loadName = ExtractLoadNameFromSeq(lines, seqStartLine)
            
            Set seqInfo = CreateObject("Scripting.Dictionary")
            seqInfo("title") = seqTitle
            seqInfo("startLine") = seqStartLine
            seqInfo("loadName") = loadName
            seqInfo("type") = seqType
            Set seqInfo("params") = ExtractShortCircuitParams(lines, seqStartLine, loadName)
            seqList.Add seqList.count, seqInfo
        End If
        
        If inFirstUnit And InStr(lines(i), "Combine") > 0 And InStr(lines(i), "SEQ.") > 0 Then
            seqTitle = Trim(lines(i))
            seqStartLine = i
            seqType = "Combine"
            loadName = ExtractLoadNameFromSeq(lines, seqStartLine)
            
            Set seqInfo = CreateObject("Scripting.Dictionary")
            seqInfo("title") = seqTitle
            seqInfo("startLine") = seqStartLine
            seqInfo("loadName") = loadName
            seqInfo("type") = seqType
            Set seqInfo("params") = ExtractCombineParams(lines, seqStartLine, loadName)
            seqList.Add seqList.count, seqInfo
        End If
        
        If inFirstUnit And InStr(lines(i), "OLP") > 0 And InStr(lines(i), "SEQ.") > 0 Then
            seqTitle = Trim(lines(i))
            seqStartLine = i
            seqType = "OLP"
            loadName = ExtractLoadNameFromSeq(lines, seqStartLine)
            
            Set seqInfo = CreateObject("Scripting.Dictionary")
            seqInfo("title") = seqTitle
            seqInfo("startLine") = seqStartLine
            seqInfo("loadName") = loadName
            seqInfo("type") = seqType
            Set seqInfo("params") = ExtractOLPParams(lines, seqStartLine, loadName)
            seqList.Add seqList.count, seqInfo
        End If
        
        If inFirstUnit And InStr(lines(i), "Dynamic") > 0 And InStr(lines(i), "SEQ.") > 0 Then
            seqTitle = Trim(lines(i))
            seqStartLine = i
            seqType = "Dynamic"
            loadName = ExtractLoadNameFromSeq(lines, seqStartLine)
            
            Set seqInfo = CreateObject("Scripting.Dictionary")
            seqInfo("title") = seqTitle
            seqInfo("startLine") = seqStartLine
            seqInfo("loadName") = loadName
            seqInfo("type") = seqType
            Set seqInfo("params") = ExtractDynamicParams(lines, seqStartLine, loadName)
            seqList.Add seqList.count, seqInfo
        End If
        
        ' Load Regulation Test: 寬鬆匹配（支援 "Load Regulation"、"LoadRegulation"、"Load regulation" 等變形）
        ' 但要排除 "Combine Regulation Test"（應由 Combine 邏輯處理）
        Dim isLoadReg As Boolean
        isLoadReg = False
        If inFirstUnit And InStr(lines(i), "SEQ.") > 0 Then
            Dim upperLine As String
            upperLine = UCase(lines(i))
            ' 寬鬆匹配：包含 "LOAD" 且包含 "REGULATION" 或 "REG"，但不包含 "COMBINE"
            If (InStr(upperLine, "LOAD") > 0) And (InStr(upperLine, "REGULATION") > 0 Or InStr(upperLine, "REG") > 0) _
               And InStr(upperLine, "COMBINE") = 0 Then
                isLoadReg = True
            End If
        End If
        
        If isLoadReg Then
            seqTitle = Trim(lines(i))
            seqStartLine = i
            seqType = "LoadRegulation"
            loadName = ExtractLoadNameFromSeq(lines, seqStartLine)
            
            Set seqInfo = CreateObject("Scripting.Dictionary")
            seqInfo("title") = seqTitle
            seqInfo("startLine") = seqStartLine
            seqInfo("loadName") = loadName
            seqInfo("type") = seqType
            Set seqInfo("params") = ExtractLoadRegulationParams(lines, seqStartLine, loadName)
            seqList.Add seqList.count, seqInfo
        End If
        
        ' ========== Input/Output 雙層判斷機制 ==========
        If inFirstUnit And InStr(lines(i), "Input/Output") > 0 And InStr(lines(i), "SEQ.") > 0 Then
            seqTitle = Trim(lines(i))
            seqStartLine = i
            loadName = ExtractLoadNameFromSeq(lines, seqStartLine)

            ' 第一層：標題關鍵字判斷（優先）
            If InStr(lines(i), "Iin<") > 0 Or InStr(lines(i), "Iin <") > 0 Then
                seqType = "InputOutput_Iin"
            ElseIf InStr(lines(i), "Pin<") > 0 Or InStr(lines(i), "Pin <") > 0 Then
                seqType = "InputOutput_Pin"
            ElseIf InStr(lines(i), "Eff.") > 0 Or (InStr(lines(i), "Eff") > 0 And InStr(lines(i), "Eff>") > 0) Then
                seqType = "InputOutput_Eff"
            Else
                ' 第二層：數據內容判斷（後備方案）
                seqType = DetectInputOutputTypeFromData(lines, seqStartLine)
            End If
            
            Set seqInfo = CreateObject("Scripting.Dictionary")
            seqInfo("title") = seqTitle
            seqInfo("startLine") = seqStartLine
            seqInfo("loadName") = loadName
            seqInfo("type") = seqType
            Set seqInfo("params") = ExtractInputOutputParams(lines, seqStartLine, loadName, seqType)
            seqList.Add seqList.count, seqInfo
        End If
    Next i
    
    Set FindAllSequences = seqList
End Function

Function ExtractLoadNameFromSeq(lines() As String, startLine As Long) As String
    Dim i As Long
    Dim lineText As String
    Dim parts() As String
    
    For i = startLine To startLine + 50
        If i > UBound(lines) Then Exit For
        lineText = Trim(lines(i))
        If Left(lineText, 2) = "1." And InStr(lineText, "Load Name") = 0 Then
            parts = SplitLine(lineText)
            If UBound(parts) >= 1 Then
                ExtractLoadNameFromSeq = Trim(parts(1))
                Exit Function
            End If
        End If
    Next i
    ExtractLoadNameFromSeq = "12V"
End Function

Sub CreateSummarySectionInSheet(ws As Worksheet, customer As String, inspector As String, testDate As String, unitCount As Long)
    Dim row As Long
    ws.Columns("A:A").ColumnWidth = 15
    ws.Columns("B:B").ColumnWidth = 25
    row = 1
    
    ws.Range("A" & row).Value = "Customer"
    ws.Range("B" & row).Value = customer
    With ws.Range("A" & row)
        .Font.Bold = True
        .Interior.Color = RGB(252, 228, 214)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    With ws.Range("B" & row)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    ws.Rows(row).RowHeight = 25
    
    row = row + 1
    ws.Range("A" & row).Value = "Inspector"
    ws.Range("B" & row).Value = inspector
    With ws.Range("A" & row)
        .Font.Bold = True
        .Interior.Color = RGB(255, 242, 204)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    With ws.Range("B" & row)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    ws.Rows(row).RowHeight = 25
    
    row = row + 1
    ws.Range("A" & row).Value = "Date"
    ws.Range("B" & row).Value = testDate
    With ws.Range("A" & row)
        .Font.Bold = True
        .Interior.Color = RGB(217, 225, 242)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    With ws.Range("B" & row)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    ws.Rows(row).RowHeight = 25
    
    row = row + 1
    ws.Range("A" & row).Value = "UnitCount"
    ws.Range("B" & row).Value = unitCount
    With ws.Range("A" & row)
        .Font.Bold = True
        .Interior.Color = RGB(198, 224, 180)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    With ws.Range("B" & row)
        .HorizontalAlignmnt = xlCenter
        .VerticalAlignmente = xlCenter
    End With
    ws.Rows(row).RowHeight = 25
    
    With ws.Range("A1:B" & row)
        .Borders.LineStyle = xlContinuous
        .Borders.Weight = xlThin
    End With
End Sub

Sub CreateAllSectionsInSheet(ws As Worksheet, seqList As Object, lines() As String, unitCount As Long)
    Dim startCol As Integer
    Dim seqIdx As Integer
    Dim seqInfo As Object
    
    startCol = 2
    
    Dim maxParamRows As Long
    maxParamRows = 0
    
    For seqIdx = 0 To seqList.count - 1
        Set seqInfo = seqList(seqIdx)
        Dim paramRowCount As Long
        paramRowCount = GetParamRowCount(seqInfo("type"))
        
        If paramRowCount > maxParamRows Then
            maxParamRows = paramRowCount
        End If
    Next seqIdx
    
    Dim snRowPosition As Long
    snRowPosition = 2 + maxParamRows + 1
    
    For seqIdx = 0 To seqList.count - 2
        Set seqInfo = seqList(seqIdx)
        
        If seqInfo("type") = "TurnOn" Then
            CreateOneTurnOnSection ws, seqInfo, lines, unitCount, startCol, snRowPosition
            startCol = startCol + 3
        ElseIf seqInfo("type") = "HoldUp" Then
            CreateOneHoldUpSection ws, seqInfo, lines, unitCount, startCol, snRowPosition
            startCol = startCol + 4
        ElseIf seqInfo("type") = "ShortCircuit" Then
            CreateOneShortCircuitSection ws, seqInfo, lines, unitCount, startCol, snRowPosition
            startCol = startCol + 3
        ElseIf seqInfo("type") = "Combine" Then
            CreateOneCombineSection ws, seqInfo, lines, unitCount, startCol, snRowPosition
            startCol = startCol + 8
        ElseIf seqInfo("type") = "OLP" Then
            CreateOneOLPSection ws, seqInfo, lines, unitCount, startCol, snRowPosition
            startCol = startCol + 3
        ElseIf seqInfo("type") = "Dynamic" Then
            CreateOneDynamicSection ws, seqInfo, lines, unitCount, startCol, snRowPosition
            startCol = startCol + 4
        ElseIf seqInfo("type") = "LoadRegulation" Then
            CreateOneLoadRegulationSection ws, seqInfo, lines, unitCount, startCol, snRowPosition
            startCol = startCol + 13  ' S/N + 11 讀值欄位 + 間隔欄
        ElseIf seqInfo("type") = "InputOutput_Iin" Or seqInfo("type") = "InputOutput_Pin" Or _
               seqInfo("type") = "InputOutput_Eff" Or seqInfo("type") = "InputOutput_General" Then
            CreateOneInputOutputSection ws, seqInfo, lines, unitCount, startCol, snRowPosition
            startCol = startCol + 10
        End If
    Next seqIdx
End Sub

Sub CreateOneTurnOnSection(ws As Worksheet, seqInfo As Object, lines() As String, unitCount As Long, startCol As Integer, snRowTarget As Long)
    Dim row As Long, col1 As Integer, col2 As Integer
    Dim seqTitle As String, seqStartLine As Long, params As Object
    
    seqTitle = seqInfo("title")
    seqStartLine = seqInfo("startLine")
    Set params = seqInfo("params")  ' 直接使用快取的參數，而不是重新解析
    col1 = startCol
    col2 = startCol + 1
    
    ws.Columns(col1).ColumnWidth = 18
    ws.Columns(col2).ColumnWidth = 18
    ws.Columns(col2 + 1).ColumnWidth = 2
    
    ' ========== 標題區（保持不變）==========
    row = 1
    ws.Range(ws.Cells(row, col1), ws.Cells(row, col2)).Merge
    ws.Cells(row, col1).Value = seqTitle
    With ws.Cells(row, col1)
        .Font.Size = 11
        .Font.Bold = True
        .Interior.Color = RGB(198, 224, 180)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
        .WrapText = True
    End With
    ws.Rows(row).RowHeight = 35
    row = row + 1
    
    ws.Cells(row, col1).Value = "Condition"
    ws.Cells(row, col2).Value = "Value"
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col2))
        .Font.Bold = True
        .Interior.Color = RGB(252, 228, 214)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    row = row + 1
    
    ' ========== 參數區（分組美化）==========
    Dim actualLoadName As String
    actualLoadName = params("LoadName")
    
    ' ?? 組1：Phase Delay 設定（淺藍色）
    Dim group1Params As Variant, group1Keys As Variant
    group1Params = Array("ON Phase delay", "OFF Phase delay")
    group1Keys = Array("ONPhaseDelay", "OFFPhaseDelay")
    Call AddParamGroup(ws, row, col1, col2, group1Params, group1Keys, params, RGB(232, 244, 248))
    
    ' ?? 組2：輸入設定（淺綠色）
    Dim group2Params As Variant, group2Keys As Variant
    group2Params = Array("Vin", "Fin")
    group2Keys = Array("Vin", "Fin")
    Call AddParamGroup(ws, row, col1, col2, group2Params, group2Keys, params, RGB(232, 248, 240))
    
    ' ?? 組3：負載參數（淺黃色）
    Dim group3Params As Variant, group3Keys As Variant
    group3Params = Array(actualLoadName & "_Load Name", actualLoadName & "_MODE", _
                         actualLoadName & "_Ifs", actualLoadName & "_Vfs")
    group3Keys = Array("LoadName", "Mode", "Ifs", "Vfs")
    Call AddParamGroup(ws, row, col1, col2, group3Params, group3Keys, params, RGB(255, 249, 230))
    
    ' ?? 組4：測試規格（淺橙色）
    Dim group4Params As Variant, group4Keys As Variant
    group4Params = Array(actualLoadName & "_Von", actualLoadName & "_I/R", _
                         actualLoadName & "_Va", actualLoadName & "_Ton Max")
    group4Keys = Array("Von", "IR", "Va", "TonMax")
    Call AddParamGroup(ws, row, col1, col2, group4Params, group4Keys, params, RGB(255, 232, 214))
    
    ' ========== 讀值區（保持不變）==========
    row = snRowTarget
    ws.Cells(row, col1).Value = "S/N"
    ws.Cells(row, col2).Value = actualLoadName & "_Ton Read"
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col2))
        .Font.Bold = True
        .Interior.Color = RGB(189, 215, 238)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    row = row + 1
    
    ' 讀值數據（批量陣列寫入優化）
    Dim tonReadData As Object
    Set tonReadData = ExtractAllTonReads(lines, seqTitle)

    Dim snKey As Variant, maxValue As Double, minValue As Double, firstValue As Boolean
    firstValue = True

    ' ========== 批量寫入優化：建立資料陣列 ==========
    If tonReadData.count > 0 Then
        Dim dataArray() As Variant
        ReDim dataArray(1 To tonReadData.count, 1 To 2)

        Dim idx As Long
        idx = 1
        For Each snKey In tonReadData.Keys
            dataArray(idx, 1) = snKey
            dataArray(idx, 2) = tonReadData(snKey)

            ' 計算 MAX/MIN
            Dim cleanedValue As String
            cleanedValue = CleanNumericValue(CStr(tonReadData(snKey)))
            If IsNumeric(cleanedValue) And cleanedValue <> "" Then
                Dim currentValue As Double
                currentValue = CDbl(cleanedValue)
                If firstValue Then
                    maxValue = currentValue
                    minValue = currentValue
                    firstValue = False
                Else
                    If currentValue > maxValue Then maxValue = currentValue
                    If currentValue < minValue Then minValue = currentValue
                End If
            End If

            idx = idx + 1
        Next snKey

        ' 一次性寫入整個陣列（效能提升關鍵）
        ws.Range(ws.Cells(row, col1), ws.Cells(row + tonReadData.count - 1, col2)).Value = dataArray

        ' 批量設定格式
        With ws.Range(ws.Cells(row, col1), ws.Cells(row + tonReadData.count - 1, col2))
            .Interior.Color = RGB(217, 225, 242)
            .HorizontalAlignment = xlCenter
            .VerticalAlignment = xlCenter
        End With

        ' 標記異常值（必須逐一檢查）
        Dim dataRow As Long
        For dataRow = row To row + tonReadData.count - 1
            If InStr(CStr(ws.Cells(dataRow, col2).Value), "?") > 0 Then
                ws.Cells(dataRow, col2).Font.Color = RGB(255, 0, 0)
                ws.Cells(dataRow, col2).Font.Bold = True
            End If
        Next dataRow

        row = row + tonReadData.count
    End If
    
    ws.Cells(row, col1).Value = "Maximum"
    If Not firstValue Then ws.Cells(row, col2).Value = maxValue
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col2))
        .Font.Bold = True
        .Interior.Color = RGB(255, 218, 224)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    row = row + 1
    
    ws.Cells(row, col1).Value = "Minimum"
    If Not firstValue Then ws.Cells(row, col2).Value = minValue
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col2))
        .Font.Bold = True
        .Interior.Color = RGB(198, 224, 180)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    
    With ws.Range(ws.Cells(1, col1), ws.Cells(row, col2))
        .Borders.LineStyle = xlContinuous
        .Borders.Weight = xlThin
    End With
End Sub


Sub CreateOneHoldUpSection(ws As Worksheet, seqInfo As Object, lines() As String, unitCount As Long, startCol As Integer, snRowTarget As Long)
    Dim row As Long, col1 As Integer, col2 As Integer
    Dim seqTitle As String, seqStartLine As Long, params As Object
    
    seqTitle = seqInfo("title")
    seqStartLine = seqInfo("startLine")
    Set params = seqInfo("params")  ' 直接使用快取的參數
    col1 = startCol
    col2 = startCol + 1
    
    ws.Columns(col1).ColumnWidth = 18
    ws.Columns(col2).ColumnWidth = 18
    ws.Columns(col2 + 1).ColumnWidth = 18
    ws.Columns(col2 + 2).ColumnWidth = 2
    
    ' ========== 標題區（保持不變）==========
    row = 1
    ws.Range(ws.Cells(row, col1), ws.Cells(row, col2 + 1)).Merge
    ws.Cells(row, col1).Value = seqTitle
    With ws.Cells(row, col1)
        .Font.Size = 11
        .Font.Bold = True
        .Interior.Color = RGB(255, 218, 224)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
        .WrapText = True
    End With
    ws.Rows(row).RowHeight = 35
    row = row + 1
    
    ws.Cells(row, col1).Value = "Condition"
    ws.Cells(row, col2).Value = "Value"
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col2))
        .Font.Bold = True
        .Interior.Color = RGB(252, 228, 214)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    row = row + 1
    
    ' ========== 參數區（分組美化）==========
    Dim actualLoadName As String
    actualLoadName = params("LoadName")
    
    ' ?? 組1：輸入設定（淺藍色）
    Dim group1Params As Variant, group1Keys As Variant
    group1Params = Array("Vin", "Fin")
    group1Keys = Array("Vin", "Fin")
    Call AddParamGroup(ws, row, col1, col2, group1Params, group1Keys, params, RGB(232, 244, 248))
    
    ' ?? 組2：負載參數（淺綠色）
    Dim group2Params As Variant, group2Keys As Variant
    group2Params = Array(actualLoadName & "_Load Name", actualLoadName & "_MODE", _
                         actualLoadName & "_Ifs", actualLoadName & "_Vfs")
    group2Keys = Array("LoadName", "Mode", "Ifs", "Vfs")
    Call AddParamGroup(ws, row, col1, col2, group2Params, group2Keys, params, RGB(232, 248, 240))
    
    ' ?? 組3：觸發設定（淺黃色）
    Dim group3Params As Variant, group3Keys As Variant
    group3Params = Array(actualLoadName & "_Von", actualLoadName & "_I/R", actualLoadName & "_Va")
    group3Keys = Array("Von", "IR", "Va")
    Call AddParamGroup(ws, row, col1, col2, group3Params, group3Keys, params, RGB(255, 249, 230))
    
    ' ?? 組4：保持時間規格（淺橙色）
    Dim group4Params As Variant, group4Keys As Variant
    group4Params = Array(actualLoadName & "_Thd Min")
    group4Keys = Array("ThdMin")
    Call AddParamGroup(ws, row, col1, col2, group4Params, group4Keys, params, RGB(255, 232, 214))
    
    ' ========== 讀值區（保持不變）==========
    row = snRowTarget
    ws.Cells(row, col1).Value = "S/N"
    ws.Cells(row, col2).Value = actualLoadName & "_Tds"
    ws.Cells(row, col2 + 1).Value = actualLoadName & "_Tdl"
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col2 + 1))
        .Font.Bold = True
        .Interior.Color = RGB(189, 215, 238)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    row = row + 1
    
    ' 讀值數據（批量陣列寫入優化）
    Dim readData As Object
    Set readData = ExtractAllHoldUpReads(lines, seqTitle)

    Dim snKey As Variant, maxTdsValue As Double, minTdsValue As Double
    Dim maxTdlValue As Double, minTdlValue As Double, firstValue As Boolean
    firstValue = True

    ' ========== 批量寫入優化：建立資料陣列 ==========
    If readData.count > 0 Then
        Dim dataArray() As Variant
        ReDim dataArray(1 To readData.count, 1 To 3)

        Dim idx As Long
        idx = 1
        For Each snKey In readData.Keys
            Dim readValues As Object
            Set readValues = readData(snKey)

            dataArray(idx, 1) = snKey
            dataArray(idx, 2) = readValues("Tds")
            dataArray(idx, 3) = readValues("Tdl")

            ' 計算 MAX/MIN
            Dim currentTds As Double, currentTdl As Double
            If IsNumeric(readValues("Tds")) Then
                currentTds = CDbl(readValues("Tds"))
                If firstValue Then
                    maxTdsValue = currentTds
                    minTdsValue = currentTds
                Else
                    If currentTds > maxTdsValue Then maxTdsValue = currentTds
                    If currentTds < minTdsValue Then minTdsValue = currentTds
                End If
            End If

            If IsNumeric(readValues("Tdl")) Then
                currentTdl = CDbl(readValues("Tdl"))
                If firstValue Then
                    maxTdlValue = currentTdl
                    minTdlValue = currentTdl
                    firstValue = False
                Else
                    If currentTdl > maxTdlValue Then maxTdlValue = currentTdl
                    If currentTdl < minTdlValue Then minTdlValue = currentTdl
                End If
            End If

            idx = idx + 1
        Next snKey

        ' 一次性寫入整個陣列（效能提升關鍵）
        ws.Range(ws.Cells(row, col1), ws.Cells(row + readData.count - 1, col2 + 1)).Value = dataArray

        ' 批量設定格式
        With ws.Range(ws.Cells(row, col1), ws.Cells(row + readData.count - 1, col2 + 1))
            .Interior.Color = RGB(217, 225, 242)
            .HorizontalAlignment = xlCenter
            .VerticalAlignment = xlCenter
        End With

        ' 標記異常值（必須逐一檢查）
        Dim dataRow As Long
        For dataRow = row To row + readData.count - 1
            If InStr(CStr(ws.Cells(dataRow, col2).Value), "?") > 0 Then
                ws.Cells(dataRow, col2).Font.Color = RGB(255, 0, 0)
                ws.Cells(dataRow, col2).Font.Bold = True
            End If
            If InStr(CStr(ws.Cells(dataRow, col2 + 1).Value), "?") > 0 Then
                ws.Cells(dataRow, col2 + 1).Font.Color = RGB(255, 0, 0)
                ws.Cells(dataRow, col2 + 1).Font.Bold = True
            End If
        Next dataRow

        row = row + readData.count
    End If
    
    ws.Cells(row, col1).Value = "Maximum"
    If Not firstValue Then
        ws.Cells(row, col2).Value = maxTdsValue
        ws.Cells(row, col2 + 1).Value = maxTdlValue
    End If
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col2 + 1))
        .Font.Bold = True
        .Interior.Color = RGB(255, 218, 224)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    row = row + 1
    
    ws.Cells(row, col1).Value = "Minimum"
    If Not firstValue Then
        ws.Cells(row, col2).Value = minTdsValue
        ws.Cells(row, col2 + 1).Value = minTdlValue
    End If
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col2 + 1))
        .Font.Bold = True
        .Interior.Color = RGB(198, 224, 180)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    
    With ws.Range(ws.Cells(1, col1), ws.Cells(row, col2 + 1))
        .Borders.LineStyle = xlContinuous
        .Borders.Weight = xlThin
    End With
End Sub

Sub CreateOneShortCircuitSection(ws As Worksheet, seqInfo As Object, lines() As String, unitCount As Long, startCol As Integer, snRowTarget As Long)
    Dim row As Long, col1 As Integer, col2 As Integer
    Dim seqTitle As String, seqStartLine As Long, params As Object
    
    seqTitle = seqInfo("title")
    seqStartLine = seqInfo("startLine")
    Set params = seqInfo("params")  ' 直接使用快取的參數
    col1 = startCol
    col2 = startCol + 1
    
    ws.Columns(col1).ColumnWidth = 18
    ws.Columns(col2).ColumnWidth = 18
    ws.Columns(col2 + 1).ColumnWidth = 2
    
    ' ========== 標題區（保持不變）==========
    row = 1
    ws.Range(ws.Cells(row, col1), ws.Cells(row, col2)).Merge
    ws.Cells(row, col1).Value = seqTitle
    With ws.Cells(row, col1)
        .Font.Size = 11
        .Font.Bold = True
        .Interior.Color = RGB(189, 215, 238)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
        .WrapText = True
    End With
    ws.Rows(row).RowHeight = 35
    row = row + 1
    
    ws.Cells(row, col1).Value = "Condition"
    ws.Cells(row, col2).Value = "Value"
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col2))
        .Font.Bold = True
        .Interior.Color = RGB(252, 228, 214)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    row = row + 1
    
    ' ========== 參數區（分組美化）==========
    Dim actualLoadName As String
    actualLoadName = params("LoadName")
    
    ' ?? 組1：輸入設定（淺藍色）
    Dim group1Params As Variant, group1Keys As Variant
    group1Params = Array("Vin", "Fin")
    group1Keys = Array("Vin", "Fin")
    Call AddParamGroup(ws, row, col1, col2, group1Params, group1Keys, params, RGB(232, 244, 248))
    
    ' ?? 組2：測試設定（淺綠色）
    Dim group2Params As Variant, group2Keys As Variant
    group2Params = Array("Which Load")
    group2Keys = Array("WhichLoad")
    Call AddParamGroup(ws, row, col1, col2, group2Params, group2Keys, params, RGB(232, 248, 240))
    
    ' ?? 組3：負載參數（淺黃色）
    Dim group3Params As Variant, group3Keys As Variant
    group3Params = Array(actualLoadName & "_Load Name", actualLoadName & "_MODE", _
                         actualLoadName & "_Ifs", actualLoadName & "_Vfs", _
                         actualLoadName & "_I/R")
    group3Keys = Array("LoadName", "Mode", "Ifs", "Vfs", "IR")
    Call AddParamGroup(ws, row, col1, col2, group3Params, group3Keys, params, RGB(255, 249, 230))
    
    ' ========== 讀值區（保持不變）==========
    row = snRowTarget
    ws.Cells(row, col1).Value = "S/N"
    ws.Cells(row, col2).Value = actualLoadName & "_Pin"
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col2))
        .Font.Bold = True
        .Interior.Color = RGB(189, 215, 238)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    row = row + 1
    
    ' 讀值數據（批量陣列寫入優化）
    Dim pinReadData As Object
    Set pinReadData = ExtractAllPinReads(lines, seqTitle)

    Dim snKey As Variant, maxValue As Double, minValue As Double, firstValue As Boolean
    firstValue = True

    ' ========== 批量寫入優化：建立資料陣列 ==========
    If pinReadData.count > 0 Then
        Dim dataArray() As Variant
        ReDim dataArray(1 To pinReadData.count, 1 To 2)

        Dim idx As Long
        idx = 1
        For Each snKey In pinReadData.Keys
            dataArray(idx, 1) = snKey
            dataArray(idx, 2) = pinReadData(snKey)

            ' 計算 MAX/MIN
            Dim cleanedValue As String
            cleanedValue = CleanNumericValue(CStr(pinReadData(snKey)))
            If IsNumeric(cleanedValue) And cleanedValue <> "" Then
                Dim currentValue As Double
                currentValue = CDbl(cleanedValue)
                If firstValue Then
                    maxValue = currentValue
                    minValue = currentValue
                    firstValue = False
                Else
                    If currentValue > maxValue Then maxValue = currentValue
                    If currentValue < minValue Then minValue = currentValue
                End If
            End If

            idx = idx + 1
        Next snKey

        ' 一次性寫入整個陣列（效能提升關鍵）
        ws.Range(ws.Cells(row, col1), ws.Cells(row + pinReadData.count - 1, col2)).Value = dataArray

        ' 批量設定格式
        With ws.Range(ws.Cells(row, col1), ws.Cells(row + pinReadData.count - 1, col2))
            .Interior.Color = RGB(217, 225, 242)
            .HorizontalAlignment = xlCenter
            .VerticalAlignment = xlCenter
        End With

        ' 標記異常值（必須逐一檢查）
        Dim dataRow As Long
        For dataRow = row To row + pinReadData.count - 1
            If InStr(CStr(ws.Cells(dataRow, col2).Value), "?") > 0 Then
                ws.Cells(dataRow, col2).Font.Color = RGB(255, 0, 0)
                ws.Cells(dataRow, col2).Font.Bold = True
            End If
        Next dataRow

        row = row + pinReadData.count
    End If
    
    ws.Cells(row, col1).Value = "Maximum"
    If Not firstValue Then ws.Cells(row, col2).Value = maxValue
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col2))
        .Font.Bold = True
        .Interior.Color = RGB(255, 218, 224)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    row = row + 1
    
    ws.Cells(row, col1).Value = "Minimum"
    If Not firstValue Then ws.Cells(row, col2).Value = minValue
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col2))
        .Font.Bold = True
        .Interior.Color = RGB(198, 224, 180)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    
    With ws.Range(ws.Cells(1, col1), ws.Cells(row, col2))
        .Borders.LineStyle = xlContinuous
        .Borders.Weight = xlThin
    End With
End Sub
Sub CreateOneCombineSection(ws As Worksheet, seqInfo As Object, lines() As String, unitCount As Long, startCol As Integer, snRowTarget As Long)
    Dim row As Long, col1 As Integer
    Dim seqTitle As String, seqStartLine As Long, params As Object
    
    seqTitle = seqInfo("title")
    seqStartLine = seqInfo("startLine")
    Set params = seqInfo("params")  ' 直接使用快取的參數
    col1 = startCol
    
    ' ?置列?
    ws.Columns(col1).ColumnWidth = 18
    Dim i As Integer
    For i = 1 To 6
        ws.Columns(col1 + i).ColumnWidth = 18
    Next i
    ws.Columns(col1 + 7).ColumnWidth = 2
    
    ' ??行
    row = 1
    ws.Range(ws.Cells(row, col1), ws.Cells(row, col1 + 6)).Merge
    ws.Cells(row, col1).Value = seqTitle
    With ws.Cells(row, col1)
        .Font.Size = 11
        .Font.Bold = True
        .Interior.Color = RGB(230, 184, 175)  ' ??色
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
        .WrapText = True
    End With
    ws.Rows(row).RowHeight = 35
    row = row + 1
    
    ' 提取??
    Dim actualLoadName As String
    actualLoadName = params("LoadName")
    
    ' ============================================
    ' Value-1, Value-2, Value-3 ??行（??色分?）
    ' ============================================
    ws.Cells(row, col1).Value = "Condition"
    ws.Cells(row, col1).Interior.Color = RGB(255, 242, 204)  ' ??色
    
    ' Value-1 (??色?)
    ws.Range(ws.Cells(row, col1 + 1), ws.Cells(row, col1 + 2)).Merge
    ws.Cells(row, col1 + 1).Value = "Value-1"
    ws.Cells(row, col1 + 1).Interior.Color = RGB(189, 215, 238)  ' ??色
    
    ' Value-2 (??色?)
    ws.Range(ws.Cells(row, col1 + 3), ws.Cells(row, col1 + 4)).Merge
    ws.Cells(row, col1 + 3).Value = "Value-2"
    ws.Cells(row, col1 + 3).Interior.Color = RGB(198, 224, 180)  ' ??色
    
    ' Value-3 (?橙色?)
    ws.Range(ws.Cells(row, col1 + 5), ws.Cells(row, col1 + 6)).Merge
    ws.Cells(row, col1 + 5).Value = "Value-3"
    ws.Cells(row, col1 + 5).Interior.Color = RGB(255, 228, 181)  ' ?橙色
    
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col1 + 6))
        .Font.Bold = True
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    row = row + 1
    
    ' ============================================
    ' Vin ??行（??色分?）
    ' ============================================
    ws.Cells(row, col1).Value = "Vin"
    ws.Cells(row, col1).Interior.Color = RGB(255, 242, 204)  ' ??色
    
    ' Value-1 ?的 Vin
    ws.Range(ws.Cells(row, col1 + 1), ws.Cells(row, col1 + 2)).Merge
    ws.Cells(row, col1 + 1).Value = params("Vin1")
    ws.Cells(row, col1 + 1).Interior.Color = RGB(189, 215, 238)  ' ??色
    
    ' Value-2 ?的 Vin
    ws.Range(ws.Cells(row, col1 + 3), ws.Cells(row, col1 + 4)).Merge
    ws.Cells(row, col1 + 3).Value = params("Vin2")
    ws.Cells(row, col1 + 3).Interior.Color = RGB(198, 224, 180)  ' ??色
    
    ' Value-3 ?的 Vin
    ws.Range(ws.Cells(row, col1 + 5), ws.Cells(row, col1 + 6)).Merge
    ws.Cells(row, col1 + 5).Value = params("Vin3")
    ws.Cells(row, col1 + 5).Interior.Color = RGB(255, 228, 181)  ' ?橙色
    
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col1 + 6))
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    row = row + 1
    
    ' ============================================
    ' Fac ??行（??色分?）
    ' ============================================
    ws.Cells(row, col1).Value = "Fac"
    ws.Cells(row, col1).Interior.Color = RGB(255, 242, 204)  ' ??色
    
    ' Value-1 ?的 Fac
    ws.Range(ws.Cells(row, col1 + 1), ws.Cells(row, col1 + 2)).Merge
    ws.Cells(row, col1 + 1).Value = params("Fac1")
    ws.Cells(row, col1 + 1).Interior.Color = RGB(189, 215, 238)  ' ??色
    
    ' Value-2 ?的 Fac
    ws.Range(ws.Cells(row, col1 + 3), ws.Cells(row, col1 + 4)).Merge
    ws.Cells(row, col1 + 3).Value = params("Fac2")
    ws.Cells(row, col1 + 3).Interior.Color = RGB(198, 224, 180)  ' ??色
    
    ' Value-3 ?的 Fac
    ws.Range(ws.Cells(row, col1 + 5), ws.Cells(row, col1 + 6)).Merge
    ws.Cells(row, col1 + 5).Value = params("Fac3")
    ws.Cells(row, col1 + 5).Interior.Color = RGB(255, 228, 181)  ' ?橙色
    
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col1 + 6))
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    row = row + 1
    
    ' ============================================
    ' I/R ??行（??色分?，?似Vin和Fac）
    ' ============================================
    ws.Cells(row, col1).Value = actualLoadName & "_I/R"
    ws.Cells(row, col1).Interior.Color = RGB(255, 242, 204)  ' ??色
    
    ' Value-1 ?的 I/R
    ws.Range(ws.Cells(row, col1 + 1), ws.Cells(row, col1 + 2)).Merge
    ws.Cells(row, col1 + 1).Value = params("IR1")
    ws.Cells(row, col1 + 1).Interior.Color = RGB(189, 215, 238)  ' ??色
    
    ' Value-2 ?的 I/R
    ws.Range(ws.Cells(row, col1 + 3), ws.Cells(row, col1 + 4)).Merge
    ws.Cells(row, col1 + 3).Value = params("IR2")
    ws.Cells(row, col1 + 3).Interior.Color = RGB(198, 224, 180)  ' ??色
    
    ' Value-3 ?的 I/R
    ws.Range(ws.Cells(row, col1 + 5), ws.Cells(row, col1 + 6)).Merge
    ws.Cells(row, col1 + 5).Value = params("IR3")
    ws.Cells(row, col1 + 5).Interior.Color = RGB(255, 228, 181)  ' ?橙色
    
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col1 + 6))
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    row = row + 1
    
    ' ============================================
    ' 通用??（跨所有Value列合并，米?色）
    ' ============================================
    Dim paramNames As Variant, paramKeys As Variant
    paramNames = Array(actualLoadName & "_Load Name", actualLoadName & "_MODE", _
                       actualLoadName & "_Ifs", actualLoadName & "_Vfs", _
                       actualLoadName & "_Noise Filter", _
                       actualLoadName & "_Vdc Max", actualLoadName & "_Vdc Min", _
                       actualLoadName & "_Vpp Max")
    paramKeys = Array("LoadName", "Mode", "Ifs", "Vfs", "NoiseFilter", _
                      "VdcMax", "VdcMin", "VppMax")
    
    For i = 0 To UBound(paramNames)
        ws.Cells(row, col1).Value = paramNames(i)
        ws.Cells(row, col1).Interior.Color = RGB(255, 242, 204)  ' ??色
        
        ' 值跨所有列合并
        ws.Range(ws.Cells(row, col1 + 1), ws.Cells(row, col1 + 6)).Merge
        ws.Cells(row, col1 + 1).Value = params(paramKeys(i))
        ws.Cells(row, col1 + 1).Interior.Color = RGB(255, 242, 204)  ' 統一參數背景色（淺米色）
        
        With ws.Range(ws.Cells(row, col1), ws.Cells(row, col1 + 6))
            .HorizontalAlignment = xlCenter
            .VerticalAlignment = xlCenter
        End With
        row = row + 1
    Next i
    
    ' ============================================
    ' ?值部分（S/N行，??色分?）
    ' ============================================
    row = snRowTarget
    ws.Cells(row, col1).Value = "S/N"
    ws.Cells(row, col1).Interior.Color = RGB(217, 225, 242)  ' 淡?色
    
    ' Value-1 ?的列??（??色）
    ws.Cells(row, col1 + 1).Value = actualLoadName & "_Vdc-1 RD"
    ws.Cells(row, col1 + 1).Interior.Color = RGB(189, 215, 238)
    ws.Cells(row, col1 + 2).Value = actualLoadName & "_Vpp-1 RD"
    ws.Cells(row, col1 + 2).Interior.Color = RGB(189, 215, 238)
    
    ' Value-2 ?的列??（??色）
    ws.Cells(row, col1 + 3).Value = actualLoadName & "_Vdc-2 RD"
    ws.Cells(row, col1 + 3).Interior.Color = RGB(198, 224, 180)
    ws.Cells(row, col1 + 4).Value = actualLoadName & "_Vpp-2 RD"
    ws.Cells(row, col1 + 4).Interior.Color = RGB(198, 224, 180)
    
    ' Value-3 ?的列??（?橙色）
    ws.Cells(row, col1 + 5).Value = actualLoadName & "_Vdc-3 RD"
    ws.Cells(row, col1 + 5).Interior.Color = RGB(255, 228, 181)
    ws.Cells(row, col1 + 6).Value = actualLoadName & "_Vpp-3 RD"
    ws.Cells(row, col1 + 6).Interior.Color = RGB(255, 228, 181)
    
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col1 + 6))
        .Font.Bold = True
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    row = row + 1
    
    ' ============================================
    ' 數據行（批量寫入優化）
    ' ============================================
    Dim combineData As Object
    Set combineData = ExtractAllCombineReads(lines, seqTitle)

    Dim maxVdc1 As Double, minVdc1 As Double
    Dim maxVdc2 As Double, minVdc2 As Double
    Dim maxVdc3 As Double, minVdc3 As Double
    Dim maxVpp1 As Double, minVpp1 As Double
    Dim maxVpp2 As Double, minVpp2 As Double
    Dim maxVpp3 As Double, minVpp3 As Double

    Dim firstVdc1 As Boolean, firstVdc2 As Boolean, firstVdc3 As Boolean
    Dim firstVpp1 As Boolean, firstVpp2 As Boolean, firstVpp3 As Boolean
    firstVdc1 = True
    firstVdc2 = True
    firstVdc3 = True
    firstVpp1 = True
    firstVpp2 = True
    firstVpp3 = True

    Dim snKey As Variant

    ' ========== 優化：使用批量陣列寫入 ==========
    If combineData.count > 0 Then
        ' 建立 7 欄陣列 (S/N, Vdc1, Vpp1, Vdc2, Vpp2, Vdc3, Vpp3)
        Dim dataArray() As Variant
        ReDim dataArray(1 To combineData.count, 1 To 7)

        Dim idx As Long
        idx = 1
        Dim startRow As Long
        startRow = row

        For Each snKey In combineData.Keys
            Dim readVals As Object
            Set readVals = combineData(snKey)

            ' 填充陣列
            dataArray(idx, 1) = snKey
            dataArray(idx, 2) = readVals("Vdc1")
            dataArray(idx, 3) = readVals("Vpp1")
            dataArray(idx, 4) = readVals("Vdc2")
            dataArray(idx, 5) = readVals("Vpp2")
            dataArray(idx, 6) = readVals("Vdc3")
            dataArray(idx, 7) = readVals("Vpp3")

            ' 清理數值並計算最大最小值（使用獨立 firstValue 旗標）
            Dim cleanVdc1 As String, cleanVdc2 As String, cleanVdc3 As String
            Dim cleanVpp1 As String, cleanVpp2 As String, cleanVpp3 As String

            cleanVdc1 = CleanNumericValue(CStr(readVals("Vdc1")))
            cleanVdc2 = CleanNumericValue(CStr(readVals("Vdc2")))
            cleanVdc3 = CleanNumericValue(CStr(readVals("Vdc3")))
            cleanVpp1 = CleanNumericValue(CStr(readVals("Vpp1")))
            cleanVpp2 = CleanNumericValue(CStr(readVals("Vpp2")))
            cleanVpp3 = CleanNumericValue(CStr(readVals("Vpp3")))

            ' 處理 Vdc1
            If IsNumeric(cleanVdc1) And cleanVdc1 <> "" Then
                If firstVdc1 Then
                    maxVdc1 = CDbl(cleanVdc1)
                    minVdc1 = CDbl(cleanVdc1)
                    firstVdc1 = False
                Else
                    If CDbl(cleanVdc1) > maxVdc1 Then maxVdc1 = CDbl(cleanVdc1)
                    If CDbl(cleanVdc1) < minVdc1 Then minVdc1 = CDbl(cleanVdc1)
                End If
            End If

            ' 處理 Vdc2
            If IsNumeric(cleanVdc2) And cleanVdc2 <> "" Then
                If firstVdc2 Then
                    maxVdc2 = CDbl(cleanVdc2)
                    minVdc2 = CDbl(cleanVdc2)
                    firstVdc2 = False
                Else
                    If CDbl(cleanVdc2) > maxVdc2 Then maxVdc2 = CDbl(cleanVdc2)
                    If CDbl(cleanVdc2) < minVdc2 Then minVdc2 = CDbl(cleanVdc2)
                End If
            End If

            ' 處理 Vdc3
            If IsNumeric(cleanVdc3) And cleanVdc3 <> "" Then
                If firstVdc3 Then
                    maxVdc3 = CDbl(cleanVdc3)
                    minVdc3 = CDbl(cleanVdc3)
                    firstVdc3 = False
                Else
                    If CDbl(cleanVdc3) > maxVdc3 Then maxVdc3 = CDbl(cleanVdc3)
                    If CDbl(cleanVdc3) < minVdc3 Then minVdc3 = CDbl(cleanVdc3)
                End If
            End If

            ' 處理 Vpp1
            If IsNumeric(cleanVpp1) And cleanVpp1 <> "" Then
                If firstVpp1 Then
                    maxVpp1 = CDbl(cleanVpp1)
                    minVpp1 = CDbl(cleanVpp1)
                    firstVpp1 = False
                Else
                    If CDbl(cleanVpp1) > maxVpp1 Then maxVpp1 = CDbl(cleanVpp1)
                    If CDbl(cleanVpp1) < minVpp1 Then minVpp1 = CDbl(cleanVpp1)
                End If
            End If

            ' 處理 Vpp2
            If IsNumeric(cleanVpp2) And cleanVpp2 <> "" Then
                If firstVpp2 Then
                    maxVpp2 = CDbl(cleanVpp2)
                    minVpp2 = CDbl(cleanVpp2)
                    firstVpp2 = False
                Else
                    If CDbl(cleanVpp2) > maxVpp2 Then maxVpp2 = CDbl(cleanVpp2)
                    If CDbl(cleanVpp2) < minVpp2 Then minVpp2 = CDbl(cleanVpp2)
                End If
            End If

            ' 處理 Vpp3
            If IsNumeric(cleanVpp3) And cleanVpp3 <> "" Then
                If firstVpp3 Then
                    maxVpp3 = CDbl(cleanVpp3)
                    minVpp3 = CDbl(cleanVpp3)
                    firstVpp3 = False
                Else
                    If CDbl(cleanVpp3) > maxVpp3 Then maxVpp3 = CDbl(cleanVpp3)
                    If CDbl(cleanVpp3) < minVpp3 Then minVpp3 = CDbl(cleanVpp3)
                End If
            End If

            idx = idx + 1
        Next snKey

        ' 一次性寫入所有資料
        ws.Range(ws.Cells(startRow, col1), ws.Cells(startRow + combineData.count - 1, col1 + 6)).Value = dataArray

        ' 批量設定格式（分組顏色）
        ' S/N 欄（淡藍色）
        With ws.Range(ws.Cells(startRow, col1), ws.Cells(startRow + combineData.count - 1, col1))
            .Interior.Color = RGB(217, 225, 242)
            .HorizontalAlignment = xlCenter
            .VerticalAlignment = xlCenter
        End With

        ' Value-1 欄（藍色）
        With ws.Range(ws.Cells(startRow, col1 + 1), ws.Cells(startRow + combineData.count - 1, col1 + 2))
            .Interior.Color = RGB(189, 215, 238)
            .HorizontalAlignment = xlCenter
            .VerticalAlignment = xlCenter
        End With

        ' Value-2 欄（綠色）
        With ws.Range(ws.Cells(startRow, col1 + 3), ws.Cells(startRow + combineData.count - 1, col1 + 4))
            .Interior.Color = RGB(198, 224, 180)
            .HorizontalAlignment = xlCenter
            .VerticalAlignment = xlCenter
        End With

        ' Value-3 欄（橙色）
        With ws.Range(ws.Cells(startRow, col1 + 5), ws.Cells(startRow + combineData.count - 1, col1 + 6))
            .Interior.Color = RGB(255, 228, 181)
            .HorizontalAlignment = xlCenter
            .VerticalAlignment = xlCenter
        End With

        ' 僅在必要時標記異常值（紅色）
        Dim checkRow As Long
        checkRow = startRow
        Dim colIdx As Integer
        For Each snKey In combineData.Keys
            Set readVals = combineData(snKey)
            For colIdx = 1 To 6
                If InStr(CStr(ws.Cells(checkRow, col1 + colIdx).Value), "?") > 0 Then
                    ws.Cells(checkRow, col1 + colIdx).Font.Color = RGB(255, 0, 0)
                    ws.Cells(checkRow, col1 + colIdx).Font.Bold = True
                End If
            Next colIdx
            checkRow = checkRow + 1
        Next snKey

        row = startRow + combineData.count
    End If
    
    ' ============================================
    ' Maximum 行（??色分?）
    ' ============================================
    ws.Cells(row, col1).Value = "Maximum"
    ws.Cells(row, col1).Interior.Color = RGB(255, 218, 224)  ' 粉?色
    
    ' Value-1 ?
    If Not firstVdc1 Then ws.Cells(row, col1 + 1).Value = maxVdc1
    ws.Cells(row, col1 + 1).Interior.Color = RGB(255, 218, 224)
    If Not firstVpp1 Then ws.Cells(row, col1 + 2).Value = maxVpp1
    ws.Cells(row, col1 + 2).Interior.Color = RGB(255, 218, 224)
    
    ' Value-2 ?
    If Not firstVdc2 Then ws.Cells(row, col1 + 3).Value = maxVdc2
    ws.Cells(row, col1 + 3).Interior.Color = RGB(255, 218, 224)
    If Not firstVpp2 Then ws.Cells(row, col1 + 4).Value = maxVpp2
    ws.Cells(row, col1 + 4).Interior.Color = RGB(255, 218, 224)
    
    ' Value-3 ?
    If Not firstVdc3 Then ws.Cells(row, col1 + 5).Value = maxVdc3
    ws.Cells(row, col1 + 5).Interior.Color = RGB(255, 218, 224)
    If Not firstVpp3 Then ws.Cells(row, col1 + 6).Value = maxVpp3
    ws.Cells(row, col1 + 6).Interior.Color = RGB(255, 218, 224)
    
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col1 + 6))
        .Font.Bold = True
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    row = row + 1
    
    ' ============================================
    ' Minimum 行（??色分?）
    ' ============================================
    ws.Cells(row, col1).Value = "Minimum"
    ws.Cells(row, col1).Interior.Color = RGB(198, 224, 180)  ' ??色
    
    ' Value-1 ?
    If Not firstVdc1 Then ws.Cells(row, col1 + 1).Value = minVdc1
    ws.Cells(row, col1 + 1).Interior.Color = RGB(198, 224, 180)
    If Not firstVpp1 Then ws.Cells(row, col1 + 2).Value = minVpp1
    ws.Cells(row, col1 + 2).Interior.Color = RGB(198, 224, 180)
    
    ' Value-2 ?
    If Not firstVdc2 Then ws.Cells(row, col1 + 3).Value = minVdc2
    ws.Cells(row, col1 + 3).Interior.Color = RGB(198, 224, 180)
    If Not firstVpp2 Then ws.Cells(row, col1 + 4).Value = minVpp2
    ws.Cells(row, col1 + 4).Interior.Color = RGB(198, 224, 180)
    
    ' Value-3 ?
    If Not firstVdc3 Then ws.Cells(row, col1 + 5).Value = minVdc3
    ws.Cells(row, col1 + 5).Interior.Color = RGB(198, 224, 180)
    If Not firstVpp3 Then ws.Cells(row, col1 + 6).Value = minVpp3
    ws.Cells(row, col1 + 6).Interior.Color = RGB(198, 224, 180)
    
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col1 + 6))
        .Font.Bold = True
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    
    ' 添加?框
    With ws.Range(ws.Cells(1, col1), ws.Cells(row, col1 + 6))
        .Borders.LineStyle = xlContinuous
        .Borders.Weight = xlThin
    End With
End Sub


Sub CreateOneOLPSection(ws As Worksheet, seqInfo As Object, lines() As String, unitCount As Long, startCol As Integer, snRowTarget As Long)
    Dim row As Long, col1 As Integer, col2 As Integer
    Dim seqTitle As String, seqStartLine As Long, params As Object
    
    seqTitle = seqInfo("title")
    seqStartLine = seqInfo("startLine")
    Set params = seqInfo("params")  ' 直接使用快取的參數
    col1 = startCol
    col2 = startCol + 1
    
    ws.Columns(col1).ColumnWidth = 18
    ws.Columns(col2).ColumnWidth = 18
    ws.Columns(col2 + 1).ColumnWidth = 2
    
    ' ========== 標題區（保持不變）==========
    row = 1
    ws.Range(ws.Cells(row, col1), ws.Cells(row, col2)).Merge
    ws.Cells(row, col1).Value = seqTitle
    With ws.Cells(row, col1)
        .Font.Size = 11
        .Font.Bold = True
        .Interior.Color = RGB(256, 228, 181)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
        .WrapText = True
    End With
    ws.Rows(row).RowHeight = 35
    row = row + 1
    
    ws.Cells(row, col1).Value = "Condition"
    ws.Cells(row, col2).Value = "Value"
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col2))
        .Font.Bold = True
        .Interior.Color = RGB(252, 228, 214)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    row = row + 1
    
    ' ========== 參數區（分組美化）==========
    Dim actualLoadName As String
    actualLoadName = params("LoadName")
    
    ' ?? 組1：輸入設定（淺藍色）
    Dim group1Params As Variant, group1Keys As Variant
    group1Params = Array("Vin", "Fin")
    group1Keys = Array("Vin", "Fin")
    Call AddParamGroup(ws, row, col1, col2, group1Params, group1Keys, params, RGB(232, 244, 248))
    
    ' ?? 組2：測試設定（淺綠色）
    Dim group2Params As Variant, group2Keys As Variant
    group2Params = Array("Test on LOAD")
    group2Keys = Array("TestOnLoad")
    Call AddParamGroup(ws, row, col1, col2, group2Params, group2Keys, params, RGB(232, 248, 240))
    
    ' ?? 組3：負載參數（淺黃色）
    Dim group3Params As Variant, group3Keys As Variant
    group3Params = Array(actualLoadName & "_Load Name", actualLoadName & "_MODE", _
                         actualLoadName & "_Ifs", actualLoadName & "_Vfs", _
                         actualLoadName & "_I/R")
    group3Keys = Array("LoadName", "Mode", "Ifs", "Vfs", "IR")
    Call AddParamGroup(ws, row, col1, col2, group3Params, group3Keys, params, RGB(255, 249, 230))
    
    ' ?? 組4：跳脫規格（淺橙色）
    Dim group4Params As Variant, group4Keys As Variant
    group4Params = Array(actualLoadName & "_Trip Point_Max", actualLoadName & "_Trip Point_Min")
    group4Keys = Array("TripPointMax", "TripPointMin")
    Call AddParamGroup(ws, row, col1, col2, group4Params, group4Keys, params, RGB(255, 232, 214))
    
    ' ========== 讀值區（保持不變）==========
    row = snRowTarget
    ws.Cells(row, col1).Value = "S/N"
    ws.Cells(row, col2).Value = actualLoadName & "_Trip Point_Min_Reading"
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col2))
        .Font.Bold = True
        .Interior.Color = RGB(189, 215, 238)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    row = row + 1
    
    ' 讀值數據（批量寫入優化）
    Dim olpReadData As Object
    Set olpReadData = ExtractAllOLPReads(lines, seqTitle)

    Dim snKey As Variant, maxValue As Double, minValue As Double, firstValue As Boolean
    firstValue = True

    ' ========== 優化：使用批量陣列寫入 ==========
    If olpReadData.count > 0 Then
        ' 建立 2D 陣列
        Dim dataArray() As Variant
        ReDim dataArray(1 To olpReadData.count, 1 To 2)

        Dim idx As Long
        idx = 1
        Dim startRow As Long
        startRow = row

        For Each snKey In olpReadData.Keys
            ' 填充陣列
            dataArray(idx, 1) = snKey
            dataArray(idx, 2) = olpReadData(snKey)

            ' 計算 MAX/MIN（使用清理後的數值）
            Dim cleanedValue As String
            cleanedValue = CleanNumericValue(CStr(olpReadData(snKey)))
            If IsNumeric(cleanedValue) And cleanedValue <> "" Then
                Dim currentValue As Double
                currentValue = CDbl(cleanedValue)
                If firstValue Then
                    maxValue = currentValue
                    minValue = currentValue
                    firstValue = False
                Else
                    If currentValue > maxValue Then maxValue = currentValue
                    If currentValue < minValue Then minValue = currentValue
                End If
            End If

            idx = idx + 1
        Next snKey

        ' 一次性寫入所有資料
        ws.Range(ws.Cells(startRow, col1), ws.Cells(startRow + olpReadData.count - 1, col2)).Value = dataArray

        ' 批量設定格式
        With ws.Range(ws.Cells(startRow, col1), ws.Cells(startRow + olpReadData.count - 1, col2))
            .Interior.Color = RGB(217, 225, 242)
            .HorizontalAlignment = xlCenter
            .VerticalAlignment = xlCenter
        End With

        ' 僅在必要時標記異常值（紅色）
        Dim checkRow As Long
        checkRow = startRow
        For Each snKey In olpReadData.Keys
            If InStr(CStr(olpReadData(snKey)), "?") > 0 Then
                ws.Cells(checkRow, col2).Font.Color = RGB(255, 0, 0)
                ws.Cells(checkRow, col2).Font.Bold = True
            End If
            checkRow = checkRow + 1
        Next snKey

        row = startRow + olpReadData.count
    End If
    
    ws.Cells(row, col1).Value = "Maximum"
    If Not firstValue Then ws.Cells(row, col2).Value = maxValue
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col2))
        .Font.Bold = True
        .Interior.Color = RGB(255, 218, 224)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    row = row + 1
    
    ws.Cells(row, col1).Value = "Minimum"
    If Not firstValue Then ws.Cells(row, col2).Value = minValue
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col2))
        .Font.Bold = True
        .Interior.Color = RGB(198, 224, 180)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    
    With ws.Range(ws.Cells(1, col1), ws.Cells(row, col2))
        .Borders.LineStyle = xlContinuous
        .Borders.Weight = xlThin
    End With
End Sub
Sub CreateOneDynamicSection(ws As Worksheet, seqInfo As Object, lines() As String, unitCount As Long, startCol As Integer, snRowTarget As Long)
    Dim row As Long, col1 As Integer, col2 As Integer
    Dim seqTitle As String, seqStartLine As Long, params As Object
    
    seqTitle = seqInfo("title")
    seqStartLine = seqInfo("startLine")
    Set params = seqInfo("params")  ' 直接使用快取的參數
    col1 = startCol
    col2 = startCol + 1
    
    ws.Columns(col1).ColumnWidth = 18
    ws.Columns(col2).ColumnWidth = 18
    ws.Columns(col2 + 1).ColumnWidth = 18
    ws.Columns(col2 + 2).ColumnWidth = 2
    
    row = 1
    ws.Range(ws.Cells(row, col1), ws.Cells(row, col2 + 1)).Merge
    ws.Cells(row, col1).Value = seqTitle
    With ws.Cells(row, col1)
        .Font.Size = 11
        .Font.Bold = True
        .Interior.Color = RGB(224, 255, 255)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
        .WrapText = True
    End With
    ws.Rows(row).RowHeight = 35
    row = row + 1
    
    ws.Cells(row, col1).Value = "Condition"
    ws.Cells(row, col2).Value = "Value"
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col2))
        .Font.Bold = True
        .Interior.Color = RGB(252, 228, 214)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    row = row + 1
    
    Dim actualLoadName As String
    actualLoadName = params("LoadName")
    
    Dim paramNames As Variant, paramKeys As Variant, i As Integer
    paramNames = Array("Vin", "Fin", _
                       actualLoadName & "_Load Name", actualLoadName & "_MODE", actualLoadName & "_Ifs", actualLoadName & "_Vfs", _
                       actualLoadName & "_Noise Filter", _
                       actualLoadName & "_Period-1", actualLoadName & "_Period-2", _
                       actualLoadName & "_Rise", actualLoadName & "_Fall", _
                       actualLoadName & "_I/R-1", actualLoadName & "_I/R-2", _
                       actualLoadName & "_Vs Max", actualLoadName & "_Vs Min")
    paramKeys = Array("Vin", "Fin", "LoadName", "Mode", "Ifs", "Vfs", "NoiseFilter", _
                      "Period1", "Period2", "Rise", "Fall", "IR1", "IR2", "VsMax", "VsMin")
    
    For i = 0 To UBound(paramNames)
        ws.Cells(row, col1).Value = paramNames(i)
        ws.Cells(row, col2).Value = params(paramKeys(i))
        With ws.Range(ws.Cells(row, col1), ws.Cells(row, col2))
            .Interior.Color = RGB(255, 242, 204)
            .HorizontalAlignment = xlCenter
            .VerticalAlignment = xlCenter
        End With
        row = row + 1
    Next i
    row = snRowTarget
    ws.Cells(row, col1).Value = "S/N"
    ws.Cells(row, col2).Value = actualLoadName & "_Vs-1 Rd"
    ws.Cells(row, col2 + 1).Value = actualLoadName & "_Vs-2 Rd"
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col2 + 1))
        .Font.Bold = True
        .Interior.Color = RGB(189, 215, 238)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    row = row + 1
    
    Dim readData As Object
    Set readData = ExtractAllDynamicReads(lines, seqTitle)

    Dim snKey As Variant, maxVs1Value As Double, minVs1Value As Double
    Dim maxVs2Value As Double, minVs2Value As Double, firstValue As Boolean
    firstValue = True

    ' ========== 優化：使用批量陣列寫入 ==========
    If readData.count > 0 Then
        ' 建立 3 欄陣列 (S/N, Vs1, Vs2)
        Dim dataArray() As Variant
        ReDim dataArray(1 To readData.count, 1 To 3)

        Dim idx As Long
        idx = 1
        Dim startRow As Long
        startRow = row

        For Each snKey In readData.Keys
            Dim readValues As Object
            Set readValues = readData(snKey)

            ' 填充陣列
            dataArray(idx, 1) = snKey
            dataArray(idx, 2) = readValues("Vs1")
            dataArray(idx, 3) = readValues("Vs2")

            ' 計算 MAX/MIN（使用清理後的數值）
            Dim cleanVs1 As String, cleanVs2 As String
            cleanVs1 = CleanNumericValue(CStr(readValues("Vs1")))
            cleanVs2 = CleanNumericValue(CStr(readValues("Vs2")))

            Dim currentVs1 As Double, currentVs2 As Double
            If IsNumeric(cleanVs1) And cleanVs1 <> "" Then
                currentVs1 = CDbl(cleanVs1)
                If firstValue Then
                    maxVs1Value = currentVs1
                    minVs1Value = currentVs1
                Else
                    If currentVs1 > maxVs1Value Then maxVs1Value = currentVs1
                    If currentVs1 < minVs1Value Then minVs1Value = currentVs1
                End If
            End If

            If IsNumeric(cleanVs2) And cleanVs2 <> "" Then
                currentVs2 = CDbl(cleanVs2)
                If firstValue Then
                    maxVs2Value = currentVs2
                    minVs2Value = currentVs2
                    firstValue = False
                Else
                    If currentVs2 > maxVs2Value Then maxVs2Value = currentVs2
                    If currentVs2 < minVs2Value Then minVs2Value = currentVs2
                End If
            End If

            idx = idx + 1
        Next snKey

        ' 一次性寫入所有資料
        ws.Range(ws.Cells(startRow, col1), ws.Cells(startRow + readData.count - 1, col2 + 1)).Value = dataArray

        ' 批量設定格式
        With ws.Range(ws.Cells(startRow, col1), ws.Cells(startRow + readData.count - 1, col2 + 1))
            .Interior.Color = RGB(217, 225, 242)
            .HorizontalAlignment = xlCenter
            .VerticalAlignment = xlCenter
        End With

        ' 僅在必要時標記異常值（紅色）
        Dim checkRow As Long
        checkRow = startRow
        For Each snKey In readData.Keys
            Set readValues = readData(snKey)
            If InStr(CStr(readValues("Vs1")), "?") > 0 Then
                ws.Cells(checkRow, col2).Font.Color = RGB(255, 0, 0)
                ws.Cells(checkRow, col2).Font.Bold = True
            End If
            If InStr(CStr(readValues("Vs2")), "?") > 0 Then
                ws.Cells(checkRow, col2 + 1).Font.Color = RGB(255, 0, 0)
                ws.Cells(checkRow, col2 + 1).Font.Bold = True
            End If
            checkRow = checkRow + 1
        Next snKey

        row = startRow + readData.count
    End If
    
    ws.Cells(row, col1).Value = "Maximum"
    If Not firstValue Then
        ws.Cells(row, col2).Value = maxVs1Value
        ws.Cells(row, col2 + 1).Value = maxVs2Value
    End If
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col2 + 1))
        .Font.Bold = True
        .Interior.Color = RGB(255, 218, 224)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    row = row + 1
    
    ws.Cells(row, col1).Value = "Minimum"
    If Not firstValue Then
        ws.Cells(row, col2).Value = minVs1Value
        ws.Cells(row, col2 + 1).Value = minVs2Value
    End If
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col2 + 1))
        .Font.Bold = True
        .Interior.Color = RGB(198, 224, 180)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    
    With ws.Range(ws.Cells(1, col1), ws.Cells(row, col2 + 1))
        .Borders.LineStyle = xlContinuous
        .Borders.Weight = xlThin
    End With
End Sub

Sub CreateOneLoadRegulationSection(ws As Worksheet, seqInfo As Object, lines() As String, unitCount As Long, startCol As Integer, snRowTarget As Long)
    Dim row As Long, col1 As Integer, col2 As Integer
    Dim seqTitle As String, seqStartLine As Long, params As Object

    seqTitle = seqInfo("title")
    seqStartLine = seqInfo("startLine")
    Set params = seqInfo("params")
    col1 = startCol
    col2 = startCol + 1

    ' 設定欄寬：12 欄總計 (S/N + VdcRead1-3 + VppRead1-3 + VnRead1-3 + dV21 + dV31)
    ws.Columns(col1).ColumnWidth = 14
    Dim c As Integer
    For c = col2 To col2 + 10
        ws.Columns(c).ColumnWidth = 12
    Next c
    ws.Columns(col2 + 11).ColumnWidth = 2

    ' 標題列
    row = 1
    ws.Range(ws.Cells(row, col1), ws.Cells(row, col2 + 10)).Merge
    ws.Cells(row, col1).Value = seqTitle
    With ws.Cells(row, col1)
        .Font.Size = 11
        .Font.Bold = True
        .Interior.Color = RGB(189, 215, 238)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
        .WrapText = True
    End With
    ws.Rows(row).RowHeight = 35
    row = row + 1

    ' Condition/Value 標題
    ws.Cells(row, col1).Value = "Condition"
    ws.Cells(row, col2).Value = "Value"
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col2))
        .Font.Bold = True
        .Interior.Color = RGB(255, 224, 178)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    row = row + 1

    Dim actualLoadName As String
    actualLoadName = params("LoadName")

    ' 19 個參數（已移除 BITS-1、BITS-2、BITS-3）
    Dim paramNames As Variant, paramKeys As Variant, i As Integer
    paramNames = Array("Vin", "Fin", "Delay Time", "Meas. Time", _
                       actualLoadName & "_Load Name", actualLoadName & "_MODE", _
                       actualLoadName & "_Ifs", actualLoadName & "_Vfs", actualLoadName & "_Meas", _
                       actualLoadName & "_Vdc Filter", actualLoadName & "_Noise Filter", actualLoadName & "_Von", _
                       actualLoadName & "_SLEW Rate", _
                       actualLoadName & "_I/R-1", actualLoadName & "_I/R-2", actualLoadName & "_I/R-3", _
                       actualLoadName & "_Vdc Max", actualLoadName & "_Vdc Min", actualLoadName & "_Vpp Max")
    paramKeys = Array("Vin", "Fin", "DelayTime", "MeasTime", _
                      "LoadName", "Mode", "Ifs", "Vfs", "Meas", _
                      "VdcFilter", "NoiseFilter", "Von", _
                      "SlewRate", _
                      "IR1", "IR2", "IR3", _
                      "VdcMax", "VdcMin", "VppMax")

    For i = 0 To UBound(paramNames)
        ws.Cells(row, col1).Value = paramNames(i)
        ws.Cells(row, col2).Value = params(paramKeys(i))
        With ws.Range(ws.Cells(row, col1), ws.Cells(row, col2))
            .Interior.Color = RGB(255, 249, 196)
            .HorizontalAlignment = xlCenter
            .VerticalAlignment = xlCenter
        End With
        row = row + 1
    Next i

    ' S/N 行（對齊到 snRowTarget）
    row = snRowTarget
    ws.Cells(row, col1).Value = "S/N"
    ws.Cells(row, col2).Value = actualLoadName & "_VdcRead1"
    ws.Cells(row, col2 + 1).Value = actualLoadName & "_VdcRead2"
    ws.Cells(row, col2 + 2).Value = actualLoadName & "_VdcRead3"
    ws.Cells(row, col2 + 3).Value = actualLoadName & "_VppRead1"
    ws.Cells(row, col2 + 4).Value = actualLoadName & "_VppRead2"
    ws.Cells(row, col2 + 5).Value = actualLoadName & "_VppRead3"
    ws.Cells(row, col2 + 6).Value = actualLoadName & "_VnRead1"
    ws.Cells(row, col2 + 7).Value = actualLoadName & "_VnRead2"
    ws.Cells(row, col2 + 8).Value = actualLoadName & "_VnRead3"
    ws.Cells(row, col2 + 9).Value = actualLoadName & "_dV21"
    ws.Cells(row, col2 + 10).Value = actualLoadName & "_dV31"
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col2 + 10))
        .Font.Bold = True
        .Interior.Color = RGB(179, 229, 252)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    row = row + 1

    ' 提取讀值資料
    Dim readData As Object
    Set readData = ExtractAllLoadRegulationReads(lines, seqTitle)

    ' 11 個獨立的 firstValue 標記（避免初始化衝突）
    Dim firstVdc1 As Boolean, firstVdc2 As Boolean, firstVdc3 As Boolean
    Dim firstVpp1 As Boolean, firstVpp2 As Boolean, firstVpp3 As Boolean
    Dim firstVn1 As Boolean, firstVn2 As Boolean, firstVn3 As Boolean
    Dim firstDv21 As Boolean, firstDv31 As Boolean
    firstVdc1 = True: firstVdc2 = True: firstVdc3 = True
    firstVpp1 = True: firstVpp2 = True: firstVpp3 = True
    firstVn1 = True: firstVn2 = True: firstVn3 = True
    firstDv21 = True: firstDv31 = True

    Dim maxVdc1 As Double, minVdc1 As Double, maxVdc2 As Double, minVdc2 As Double, maxVdc3 As Double, minVdc3 As Double
    Dim maxVpp1 As Double, minVpp1 As Double, maxVpp2 As Double, minVpp2 As Double, maxVpp3 As Double, minVpp3 As Double
    Dim maxVn1 As Double, minVn1 As Double, maxVn2 As Double, minVn2 As Double, maxVn3 As Double, minVn3 As Double
    Dim maxDv21 As Double, minDv21 As Double, maxDv31 As Double, minDv31 As Double

    ' 批量陣列寫入優化
    If readData.count > 0 Then
        Dim dataArray() As Variant
        ReDim dataArray(1 To readData.count, 1 To 12)

        Dim idx As Long, snKey As Variant
        idx = 1
        Dim startRow As Long
        startRow = row

        For Each snKey In readData.Keys
            Dim readVals As Object
            Set readVals = readData(snKey)

            dataArray(idx, 1) = snKey
            dataArray(idx, 2) = readVals("VdcRead1")
            dataArray(idx, 3) = readVals("VdcRead2")
            dataArray(idx, 4) = readVals("VdcRead3")
            dataArray(idx, 5) = readVals("VppRead1")
            dataArray(idx, 6) = readVals("VppRead2")
            dataArray(idx, 7) = readVals("VppRead3")
            dataArray(idx, 8) = readVals("VnRead1")
            dataArray(idx, 9) = readVals("VnRead2")
            dataArray(idx, 10) = readVals("VnRead3")
            dataArray(idx, 11) = readVals("dV21")
            dataArray(idx, 12) = readVals("dV31")

            ' 計算 MAX/MIN（使用 CleanNumericValue）
            Dim cleanVal As String, currentVal As Double

            ' VdcRead1
            cleanVal = CleanNumericValue(CStr(readVals("VdcRead1")))
            If IsNumeric(cleanVal) And cleanVal <> "" Then
                currentVal = CDbl(cleanVal)
                If firstVdc1 Then
                    maxVdc1 = currentVal: minVdc1 = currentVal: firstVdc1 = False
                Else
                    If currentVal > maxVdc1 Then maxVdc1 = currentVal
                    If currentVal < minVdc1 Then minVdc1 = currentVal
                End If
            End If

            ' VdcRead2
            cleanVal = CleanNumericValue(CStr(readVals("VdcRead2")))
            If IsNumeric(cleanVal) And cleanVal <> "" Then
                currentVal = CDbl(cleanVal)
                If firstVdc2 Then
                    maxVdc2 = currentVal: minVdc2 = currentVal: firstVdc2 = False
                Else
                    If currentVal > maxVdc2 Then maxVdc2 = currentVal
                    If currentVal < minVdc2 Then minVdc2 = currentVal
                End If
            End If

            ' VdcRead3
            cleanVal = CleanNumericValue(CStr(readVals("VdcRead3")))
            If IsNumeric(cleanVal) And cleanVal <> "" Then
                currentVal = CDbl(cleanVal)
                If firstVdc3 Then
                    maxVdc3 = currentVal: minVdc3 = currentVal: firstVdc3 = False
                Else
                    If currentVal > maxVdc3 Then maxVdc3 = currentVal
                    If currentVal < minVdc3 Then minVdc3 = currentVal
                End If
            End If

            ' VppRead1
            cleanVal = CleanNumericValue(CStr(readVals("VppRead1")))
            If IsNumeric(cleanVal) And cleanVal <> "" Then
                currentVal = CDbl(cleanVal)
                If firstVpp1 Then
                    maxVpp1 = currentVal: minVpp1 = currentVal: firstVpp1 = False
                Else
                    If currentVal > maxVpp1 Then maxVpp1 = currentVal
                    If currentVal < minVpp1 Then minVpp1 = currentVal
                End If
            End If

            ' VppRead2
            cleanVal = CleanNumericValue(CStr(readVals("VppRead2")))
            If IsNumeric(cleanVal) And cleanVal <> "" Then
                currentVal = CDbl(cleanVal)
                If firstVpp2 Then
                    maxVpp2 = currentVal: minVpp2 = currentVal: firstVpp2 = False
                Else
                    If currentVal > maxVpp2 Then maxVpp2 = currentVal
                    If currentVal < minVpp2 Then minVpp2 = currentVal
                End If
            End If

            ' VppRead3
            cleanVal = CleanNumericValue(CStr(readVals("VppRead3")))
            If IsNumeric(cleanVal) And cleanVal <> "" Then
                currentVal = CDbl(cleanVal)
                If firstVpp3 Then
                    maxVpp3 = currentVal: minVpp3 = currentVal: firstVpp3 = False
                Else
                    If currentVal > maxVpp3 Then maxVpp3 = currentVal
                    If currentVal < minVpp3 Then minVpp3 = currentVal
                End If
            End If

            ' VnRead1
            cleanVal = CleanNumericValue(CStr(readVals("VnRead1")))
            If IsNumeric(cleanVal) And cleanVal <> "" Then
                currentVal = CDbl(cleanVal)
                If firstVn1 Then
                    maxVn1 = currentVal: minVn1 = currentVal: firstVn1 = False
                Else
                    If currentVal > maxVn1 Then maxVn1 = currentVal
                    If currentVal < minVn1 Then minVn1 = currentVal
                End If
            End If

            ' VnRead2
            cleanVal = CleanNumericValue(CStr(readVals("VnRead2")))
            If IsNumeric(cleanVal) And cleanVal <> "" Then
                currentVal = CDbl(cleanVal)
                If firstVn2 Then
                    maxVn2 = currentVal: minVn2 = currentVal: firstVn2 = False
                Else
                    If currentVal > maxVn2 Then maxVn2 = currentVal
                    If currentVal < minVn2 Then minVn2 = currentVal
                End If
            End If

            ' VnRead3
            cleanVal = CleanNumericValue(CStr(readVals("VnRead3")))
            If IsNumeric(cleanVal) And cleanVal <> "" Then
                currentVal = CDbl(cleanVal)
                If firstVn3 Then
                    maxVn3 = currentVal: minVn3 = currentVal: firstVn3 = False
                Else
                    If currentVal > maxVn3 Then maxVn3 = currentVal
                    If currentVal < minVn3 Then minVn3 = currentVal
                End If
            End If

            ' dV21
            cleanVal = CleanNumericValue(CStr(readVals("dV21")))
            If IsNumeric(cleanVal) And cleanVal <> "" Then
                currentVal = CDbl(cleanVal)
                If firstDv21 Then
                    maxDv21 = currentVal: minDv21 = currentVal: firstDv21 = False
                Else
                    If currentVal > maxDv21 Then maxDv21 = currentVal
                    If currentVal < minDv21 Then minDv21 = currentVal
                End If
            End If

            ' dV31
            cleanVal = CleanNumericValue(CStr(readVals("dV31")))
            If IsNumeric(cleanVal) And cleanVal <> "" Then
                currentVal = CDbl(cleanVal)
                If firstDv31 Then
                    maxDv31 = currentVal: minDv31 = currentVal: firstDv31 = False
                Else
                    If currentVal > maxDv31 Then maxDv31 = currentVal
                    If currentVal < minDv31 Then minDv31 = currentVal
                End If
            End If

            idx = idx + 1
        Next snKey

        ' 一次性寫入所有資料
        ws.Range(ws.Cells(startRow, col1), ws.Cells(startRow + readData.count - 1, col2 + 10)).Value = dataArray

        ' 批量設定格式
        With ws.Range(ws.Cells(startRow, col1), ws.Cells(startRow + readData.count - 1, col2 + 10))
            .Interior.Color = RGB(225, 245, 254)
            .HorizontalAlignment = xlCenter
            .VerticalAlignment = xlCenter
        End With

        ' 標記異常值（??）為紅色
        Dim checkRow As Long
        checkRow = startRow
        For Each snKey In readData.Keys
            Set readVals = readData(snKey)
            Dim colOffset As Integer
            For colOffset = 0 To 10
                Dim cellVal As String
                Select Case colOffset
                    Case 0: cellVal = CStr(readVals("VdcRead1"))
                    Case 1: cellVal = CStr(readVals("VdcRead2"))
                    Case 2: cellVal = CStr(readVals("VdcRead3"))
                    Case 3: cellVal = CStr(readVals("VppRead1"))
                    Case 4: cellVal = CStr(readVals("VppRead2"))
                    Case 5: cellVal = CStr(readVals("VppRead3"))
                    Case 6: cellVal = CStr(readVals("VnRead1"))
                    Case 7: cellVal = CStr(readVals("VnRead2"))
                    Case 8: cellVal = CStr(readVals("VnRead3"))
                    Case 9: cellVal = CStr(readVals("dV21"))
                    Case 10: cellVal = CStr(readVals("dV31"))
                End Select
                If InStr(cellVal, "?") > 0 Then
                    ws.Cells(checkRow, col2 + colOffset).Font.Color = RGB(255, 0, 0)
                    ws.Cells(checkRow, col2 + colOffset).Font.Bold = True
                End If
            Next colOffset
            checkRow = checkRow + 1
        Next snKey

        row = startRow + readData.count
    End If

    ' Maximum 行
    ws.Cells(row, col1).Value = "Maximum"
    If Not firstVdc1 Then ws.Cells(row, col2).Value = maxVdc1
    If Not firstVdc2 Then ws.Cells(row, col2 + 1).Value = maxVdc2
    If Not firstVdc3 Then ws.Cells(row, col2 + 2).Value = maxVdc3
    If Not firstVpp1 Then ws.Cells(row, col2 + 3).Value = maxVpp1
    If Not firstVpp2 Then ws.Cells(row, col2 + 4).Value = maxVpp2
    If Not firstVpp3 Then ws.Cells(row, col2 + 5).Value = maxVpp3
    If Not firstVn1 Then ws.Cells(row, col2 + 6).Value = maxVn1
    If Not firstVn2 Then ws.Cells(row, col2 + 7).Value = maxVn2
    If Not firstVn3 Then ws.Cells(row, col2 + 8).Value = maxVn3
    If Not firstDv21 Then ws.Cells(row, col2 + 9).Value = maxDv21
    If Not firstDv31 Then ws.Cells(row, col2 + 10).Value = maxDv31
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col2 + 10))
        .Font.Bold = True
        .Interior.Color = RGB(255, 218, 224)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    row = row + 1

    ' Minimum 行
    ws.Cells(row, col1).Value = "Minimum"
    If Not firstVdc1 Then ws.Cells(row, col2).Value = minVdc1
    If Not firstVdc2 Then ws.Cells(row, col2 + 1).Value = minVdc2
    If Not firstVdc3 Then ws.Cells(row, col2 + 2).Value = minVdc3
    If Not firstVpp1 Then ws.Cells(row, col2 + 3).Value = minVpp1
    If Not firstVpp2 Then ws.Cells(row, col2 + 4).Value = minVpp2
    If Not firstVpp3 Then ws.Cells(row, col2 + 5).Value = minVpp3
    If Not firstVn1 Then ws.Cells(row, col2 + 6).Value = minVn1
    If Not firstVn2 Then ws.Cells(row, col2 + 7).Value = minVn2
    If Not firstVn3 Then ws.Cells(row, col2 + 8).Value = minVn3
    If Not firstDv21 Then ws.Cells(row, col2 + 9).Value = minDv21
    If Not firstDv31 Then ws.Cells(row, col2 + 10).Value = minDv31
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col2 + 10))
        .Font.Bold = True
        .Interior.Color = RGB(198, 224, 180)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With

    ' 邊框
    With ws.Range(ws.Cells(1, col1), ws.Cells(row, col2 + 10))
        .Borders.LineStyle = xlContinuous
        .Borders.Weight = xlThin
    End With
End Sub

Sub CreateOneInputOutputSection(ws As Worksheet, seqInfo As Object, lines() As String, unitCount As Long, startCol As Integer, snRowTarget As Long)
    Dim row As Long, col1 As Integer
    Dim seqTitle As String, seqStartLine As Long, params As Object
    
    seqTitle = seqInfo("title")
    seqStartLine = seqInfo("startLine")
    Set params = seqInfo("params")  ' 直接使用快取的參數
    col1 = startCol
    
    ws.Columns(col1).ColumnWidth = 18
    Dim i As Integer
    For i = 1 To 8
        ws.Columns(col1 + i).ColumnWidth = 18
    Next i
    ws.Columns(col1 + 9).ColumnWidth = 2
    
    ' ========== 標題區（保持不變）==========
    row = 1
    ws.Range(ws.Cells(row, col1), ws.Cells(row, col1 + 8)).Merge
    ws.Cells(row, col1).Value = seqTitle
    With ws.Cells(row, col1)
        .Font.Size = 11
        .Font.Bold = True
        .Interior.Color = RGB(255, 235, 205)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
        .WrapText = True
    End With
    ws.Rows(row).RowHeight = 35
    row = row + 1
    
    ws.Cells(row, col1).Value = "Condition"
    ws.Cells(row, col1 + 1).Value = "Value"
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col1 + 1))
        .Font.Bold = True
        .Interior.Color = RGB(252, 228, 214)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    row = row + 1
    
    ' ========== 參數區（分組美化）==========
    Dim actualLoadName As String
    actualLoadName = params("LoadName")
    Dim seqType As String
    seqType = seqInfo("type")
    
    ' ?? 組1：輸入設定（淺藍色）
    Dim group1Params As Variant, group1Keys As Variant
    group1Params = Array("Vin", "Fin")
    group1Keys = Array("Vin", "Fin")
    Call AddParamGroupIO(ws, row, col1, col1 + 1, group1Params, group1Keys, params, RGB(232, 244, 248))
    
    ' ?? 組2：負載參數（淺綠色）
    Dim group2Params As Variant, group2Keys As Variant
    group2Params = Array(actualLoadName & "_Load Name", actualLoadName & "_MODE", _
                         actualLoadName & "_Ifs", actualLoadName & "_Vfs")
    group2Keys = Array("LoadName", "Mode", "Ifs", "Vfs")
    Call AddParamGroupIO(ws, row, col1, col1 + 1, group2Params, group2Keys, params, RGB(232, 248, 240))
    
    ' ?? 組3：濾波設定（淺黃色）
    Dim group3Params As Variant, group3Keys As Variant
    group3Params = Array(actualLoadName & "_Noise Filter")
    group3Keys = Array("NoiseFilter")
    Call AddParamGroupIO(ws, row, col1, col1 + 1, group3Params, group3Keys, params, RGB(255, 249, 230))
    
    ' ?? 組4：測試規格（淺橙色）
    Dim group4Params As Variant, group4Keys As Variant
    If seqType = "InputOutput_Iin" Or seqType = "InputOutput_General" Then
        If seqType = "InputOutput_General" Then
            group4Params = Array(actualLoadName & "_Iinrms Max", actualLoadName & "_I/R")
            group4Keys = Array("IinrmsMax", "IR")
        Else
            group4Params = Array(actualLoadName & "_Iinrms Max", actualLoadName & "_I/R")
            group4Keys = Array("IinrmsMax", "IR")
        End If
    ElseIf seqType = "InputOutput_Pin" Then
        group4Params = Array(actualLoadName & "_Pin Max", actualLoadName & "_I/R")
        group4Keys = Array("PinMax", "IR")
    ElseIf seqType = "InputOutput_Eff" Then
        group4Params = Array(actualLoadName & "_Eff Min", actualLoadName & "_I/R")
        group4Keys = Array("EffMin", "IR")
    End If
    Call AddParamGroupIO(ws, row, col1, col1 + 1, group4Params, group4Keys, params, RGB(255, 232, 214))
    
    ' ?? 組5：電壓規格（淺粉色）
    Dim group5Params As Variant, group5Keys As Variant
    If seqType = "InputOutput_General" Or seqType = "InputOutput_Eff" Then
        ' ===== Eff 和 General 類型都顯示 Vin Max/Min =====
        group5Params = Array(actualLoadName & "_Vin Max", actualLoadName & "_Vin Min", _
                            actualLoadName & "_Vdc Max", actualLoadName & "_Vdc Min", _
                            actualLoadName & "_Vpp Max")
        group5Keys = Array("VinMax", "VinMin", "VdcMax", "VdcMin", "VppMax")
    Else
        ' Iin 和 Pin 類型只顯示 Vdc/Vpp
        group5Params = Array(actualLoadName & "_Vdc Max", actualLoadName & "_Vdc Min", _
                            actualLoadName & "_Vpp Max")
        group5Keys = Array("VdcMax", "VdcMin", "VppMax")
    End If
    Call AddParamGroupIO(ws, row, col1, col1 + 1, group5Params, group5Keys, params, RGB(255, 232, 240))
    
    ' ========== 讀值區（Load Name 前綴）==========
    row = snRowTarget
    Dim loadPrefix As String
    loadPrefix = actualLoadName & "_"  ' 例如："5.3_"

    ws.Cells(row, col1).Value = "S/N"
    ws.Cells(row, col1 + 1).Value = loadPrefix & "Iinrms"
    ws.Cells(row, col1 + 2).Value = loadPrefix & "Pin"
    ws.Cells(row, col1 + 3).Value = loadPrefix & "Pdc"
    ws.Cells(row, col1 + 4).Value = loadPrefix & "Eff"
    ws.Cells(row, col1 + 5).Value = loadPrefix & "Pf"

    If seqType = "InputOutput_General" Then
        ws.Cells(row, col1 + 6).Value = loadPrefix & "Vin Read"
    Else
        ws.Cells(row, col1 + 6).Value = loadPrefix & "Idc Read"
    End If

    ws.Cells(row, col1 + 7).Value = loadPrefix & "Vdc Read"
    ws.Cells(row, col1 + 8).Value = loadPrefix & "Vpp Read"
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col1 + 8))
        .Font.Bold = True
        .Interior.Color = RGB(189, 215, 238)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    row = row + 1
    
    ' 讀值數據（批量寫入優化）
    Dim ioData As Object
    Set ioData = ExtractAllInputOutputReads(lines, seqTitle, seqType)

    Dim maxIinrms As Double, minIinrms As Double
    Dim maxPin As Double, minPin As Double
    Dim maxPdc As Double, minPdc As Double
    Dim maxEff As Double, minEff As Double
    Dim maxPf As Double, minPf As Double
    Dim maxIdc As Double, minIdc As Double
    Dim maxVdc As Double, minVdc As Double
    Dim maxVpp As Double, minVpp As Double
    Dim firstValue As Boolean
    firstValue = True

    Dim snKey As Variant

    ' ========== 優化：使用批量陣列寫入 ==========
    If ioData.count > 0 Then
        ' 建立 9 欄陣列 (S/N + 8 讀值)
        Dim dataArray() As Variant
        ReDim dataArray(1 To ioData.count, 1 To 9)

        Dim idx As Long
        idx = 1
        Dim startRow As Long
        startRow = row

        For Each snKey In ioData.Keys
            Dim readVals As Object
            Set readVals = ioData(snKey)

            ' 填充陣列
            dataArray(idx, 1) = snKey
            dataArray(idx, 2) = readVals("Iinrms")
            dataArray(idx, 3) = readVals("Pin")
            dataArray(idx, 4) = readVals("Pdc")
            dataArray(idx, 5) = readVals("Eff")
            dataArray(idx, 6) = readVals("Pf")

            ' 第 6 欄根據類型不同
            If seqType = "InputOutput_General" Then
                dataArray(idx, 7) = readVals("VinRead")
            Else
                dataArray(idx, 7) = readVals("Idc")
            End If

            dataArray(idx, 8) = readVals("Vdc")
            dataArray(idx, 9) = readVals("Vpp")

            ' 清理數值並計算最大最小值
            Dim cleanIinrms As String, cleanPin As String, cleanPdc As String
            Dim cleanEff As String, cleanPf As String, cleanIdc As String
            Dim cleanVdc As String, cleanVpp As String

            cleanIinrms = CleanNumericValue(CStr(readVals("Iinrms")))
            cleanPin = CleanNumericValue(CStr(readVals("Pin")))
            cleanPdc = CleanNumericValue(CStr(readVals("Pdc")))
            cleanEff = CleanNumericValue(CStr(readVals("Eff")))
            cleanPf = CleanNumericValue(CStr(readVals("Pf")))
            cleanIdc = CleanNumericValue(CStr(readVals("Idc")))
            cleanVdc = CleanNumericValue(CStr(readVals("Vdc")))
            cleanVpp = CleanNumericValue(CStr(readVals("Vpp")))

            If IsNumeric(cleanIinrms) And cleanIinrms <> "" Then
                If firstValue Then
                    maxIinrms = CDbl(cleanIinrms): minIinrms = CDbl(cleanIinrms)
                    If IsNumeric(cleanPin) And cleanPin <> "" Then maxPin = CDbl(cleanPin): minPin = CDbl(cleanPin)
                    If IsNumeric(cleanPdc) And cleanPdc <> "" Then maxPdc = CDbl(cleanPdc): minPdc = CDbl(cleanPdc)
                    If IsNumeric(cleanEff) And cleanEff <> "" Then maxEff = CDbl(cleanEff): minEff = CDbl(cleanEff)
                    If IsNumeric(cleanPf) And cleanPf <> "" Then maxPf = CDbl(cleanPf): minPf = CDbl(cleanPf)
                    If IsNumeric(cleanIdc) And cleanIdc <> "" Then maxIdc = CDbl(cleanIdc): minIdc = CDbl(cleanIdc)
                    If IsNumeric(cleanVdc) And cleanVdc <> "" Then maxVdc = CDbl(cleanVdc): minVdc = CDbl(cleanVdc)
                    If IsNumeric(cleanVpp) And cleanVpp <> "" Then maxVpp = CDbl(cleanVpp): minVpp = CDbl(cleanVpp)
                    firstValue = False
                Else
                    If IsNumeric(cleanIinrms) And cleanIinrms <> "" Then
                        If CDbl(cleanIinrms) > maxIinrms Then maxIinrms = CDbl(cleanIinrms)
                        If CDbl(cleanIinrms) < minIinrms Then minIinrms = CDbl(cleanIinrms)
                    End If
                    If IsNumeric(cleanPin) And cleanPin <> "" Then
                        If CDbl(cleanPin) > maxPin Then maxPin = CDbl(cleanPin)
                        If CDbl(cleanPin) < minPin Then minPin = CDbl(cleanPin)
                    End If
                    If IsNumeric(cleanPdc) And cleanPdc <> "" Then
                        If CDbl(cleanPdc) > maxPdc Then maxPdc = CDbl(cleanPdc)
                        If CDbl(cleanPdc) < minPdc Then minPdc = CDbl(cleanPdc)
                    End If
                    If IsNumeric(cleanEff) And cleanEff <> "" Then
                        If CDbl(cleanEff) > maxEff Then maxEff = CDbl(cleanEff)
                        If CDbl(cleanEff) < minEff Then minEff = CDbl(cleanEff)
                    End If
                    If IsNumeric(cleanPf) And cleanPf <> "" Then
                        If CDbl(cleanPf) > maxPf Then maxPf = CDbl(cleanPf)
                        If CDbl(cleanPf) < minPf Then minPf = CDbl(cleanPf)
                    End If
                    If IsNumeric(cleanIdc) And cleanIdc <> "" Then
                        If CDbl(cleanIdc) > maxIdc Then maxIdc = CDbl(cleanIdc)
                        If CDbl(cleanIdc) < minIdc Then minIdc = CDbl(cleanIdc)
                    End If
                    If IsNumeric(cleanVdc) And cleanVdc <> "" Then
                        If CDbl(cleanVdc) > maxVdc Then maxVdc = CDbl(cleanVdc)
                        If CDbl(cleanVdc) < minVdc Then minVdc = CDbl(cleanVdc)
                    End If
                    If IsNumeric(cleanVpp) And cleanVpp <> "" Then
                        If CDbl(cleanVpp) > maxVpp Then maxVpp = CDbl(cleanVpp)
                        If CDbl(cleanVpp) < minVpp Then minVpp = CDbl(cleanVpp)
                    End If
                End If
            End If

            idx = idx + 1
        Next snKey

        ' 一次性寫入所有資料
        ws.Range(ws.Cells(startRow, col1), ws.Cells(startRow + ioData.count - 1, col1 + 8)).Value = dataArray

        ' 批量設定格式
        With ws.Range(ws.Cells(startRow, col1), ws.Cells(startRow + ioData.count - 1, col1 + 8))
            .Interior.Color = RGB(217, 225, 242)
            .HorizontalAlignment = xlCenter
            .VerticalAlignment = xlCenter
        End With

        ' 僅在必要時標記異常值（紅色）
        Dim checkRow As Long
        checkRow = startRow
        Dim colIdx As Integer
        For Each snKey In ioData.Keys
            For colIdx = 1 To 8
                If InStr(CStr(ws.Cells(checkRow, col1 + colIdx).Value), "?") > 0 Then
                    ws.Cells(checkRow, col1 + colIdx).Font.Color = RGB(255, 0, 0)
                    ws.Cells(checkRow, col1 + colIdx).Font.Bold = True
                End If
            Next colIdx
            checkRow = checkRow + 1
        Next snKey

        row = startRow + ioData.count
    End If
    
    ws.Cells(row, col1).Value = "Maximum"
    If Not firstValue Then
        ws.Cells(row, col1 + 1).Value = maxIinrms
        ws.Cells(row, col1 + 2).Value = maxPin
        ws.Cells(row, col1 + 3).Value = maxPdc
        ws.Cells(row, col1 + 4).Value = maxEff
        ws.Cells(row, col1 + 5).Value = maxPf
        ws.Cells(row, col1 + 6).Value = maxIdc
        ws.Cells(row, col1 + 7).Value = maxVdc
        ws.Cells(row, col1 + 8).Value = maxVpp
    End If
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col1 + 8))
        .Font.Bold = True
        .Interior.Color = RGB(255, 218, 224)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    row = row + 1
    
    ws.Cells(row, col1).Value = "Minimum"
    If Not firstValue Then
        ws.Cells(row, col1 + 1).Value = minIinrms
        ws.Cells(row, col1 + 2).Value = minPin
        ws.Cells(row, col1 + 3).Value = minPdc
        ws.Cells(row, col1 + 4).Value = minEff
        ws.Cells(row, col1 + 5).Value = minPf
        ws.Cells(row, col1 + 6).Value = minIdc
        ws.Cells(row, col1 + 7).Value = minVdc
        ws.Cells(row, col1 + 8).Value = minVpp
    End If
    With ws.Range(ws.Cells(row, col1), ws.Cells(row, col1 + 8))
        .Font.Bold = True
        .Interior.Color = RGB(198, 224, 180)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
    End With
    
    With ws.Range(ws.Cells(1, col1), ws.Cells(row, col1 + 8))
        .Borders.LineStyle = xlContinuous
        .Borders.Weight = xlThin
    End With
End Sub

Function ExtractOLPParams(lines() As String, startLine As Long, loadName As String) As Object
    Dim params As Object
    Set params = CreateObject("Scripting.Dictionary")
    
    params.Add "Vin", ""
    params.Add "Fin", ""
    params.Add "TestOnLoad", ""
    params.Add "LoadName", loadName
    params.Add "Mode", ""
    params.Add "Ifs", ""
    params.Add "Vfs", ""
    params.Add "IR", ""
    params.Add "TripPointMax", ""
    params.Add "TripPointMin", ""
    
    Dim i As Long, lineText As String, parts() As String
    Dim foundLoadParams As Boolean
    foundLoadParams = False
    
    Dim seqEndLine As Long
    seqEndLine = startLine + 50
    For i = startLine + 1 To UBound(lines)
        If InStr(lines(i), "SEQ.") > 0 And i > startLine Then
            seqEndLine = i - 1
            Exit For
        End If
    Next i
    
    For i = startLine To seqEndLine
        If i > UBound(lines) Then Exit For
        lineText = lines(i)
        
        If InStr(lineText, "Vin") > 0 And InStr(lineText, "Fin") > 0 And InStr(lineText, "Vin Port") = 0 Then
            params("Vin") = ExtractNumericValue(lineText, "Vin")
            params("Fin") = ExtractNumericValue(lineText, "Fin")
        End If
        
        If InStr(lineText, "Test on LOAD") > 0 Then
            Dim colonPos As Long
            colonPos = InStr(lineText, ":")
            If colonPos > 0 Then
                Dim loadValue As String
                loadValue = Trim(Mid(lineText, colonPos + 1))
                Dim j As Long
                Dim numStr As String
                numStr = ""
                For j = 1 To Len(loadValue)
                    If Mid(loadValue, j, 1) >= "0" And Mid(loadValue, j, 1) <= "9" Then
                        numStr = numStr & Mid(loadValue, j, 1)
                    ElseIf numStr <> "" Then
                        Exit For
                    End If
                Next j
                If numStr <> "" Then params("TestOnLoad") = numStr
            End If
        End If
        
        If InStr(lineText, "Load Name") > 0 And InStr(lineText, "MODE") > 0 And Not foundLoadParams Then
            If i + 1 <= seqEndLine Then
                Dim nextLine As String
                nextLine = lines(i + 1)
                If Trim(Left(nextLine, 2)) = "1." Then
                    parts = SplitLine(nextLine)
                    If UBound(parts) >= 2 Then
                        params("Mode") = parts(2)
                    End If
                    If UBound(parts) >= 3 Then
                        params("Ifs") = parts(3)
                    End If
                    If UBound(parts) >= 4 Then
                        params("Vfs") = parts(4)
                    End If
                    If UBound(parts) >= 9 Then
                        params("IR") = parts(9)
                    ElseIf UBound(parts) >= 8 Then
                        params("IR") = parts(8)
                    End If
                    foundLoadParams = True
                End If
            End If
        End If
        
        If InStr(lineText, "Max") > 0 And InStr(lineText, "Min") > 0 And InStr(lineText, "Reading") > 0 Then
            If i + 1 <= seqEndLine Then
                Dim tripLine As String
                tripLine = lines(i + 1)
                If InStr(Trim(tripLine), "Trip Point") = 1 Then
                    parts = SplitLine(tripLine)
                    If UBound(parts) >= 3 Then
                        If parts(0) = "Trip" And UBound(parts) >= 4 Then
                            params("TripPointMax") = parts(2)
                            params("TripPointMin") = parts(3)
                        ElseIf UBound(parts) >= 3 Then
                            params("TripPointMax") = parts(1)
                            params("TripPointMin") = parts(2)
                        End If
                    End If
                End If
            End If
        End If
    Next i
    
    Set ExtractOLPParams = params
End Function

Function ExtractAllOLPReads(lines() As String, seqTitle As String) As Object
    Dim olpReads As Object
    Set olpReads = CreateObject("Scripting.Dictionary")
    
    Dim i As Long, currentSerial As String, inTargetSeq As Boolean
    Dim lineText As String, parts() As String, seqStartLine As Long, seqEndLine As Long
    
    currentSerial = ""
    inTargetSeq = False
    seqStartLine = -1
    
    For i = 0 To UBound(lines)
        lineText = lines(i)
        
        If InStr(lineText, "Serial No") > 0 Then
            currentSerial = ExtractSerialNumber(lineText)
        End If
        
        If InStr(lineText, seqTitle) > 0 Then
            inTargetSeq = True
            seqStartLine = i
            seqEndLine = i + 50
            Dim j As Long
            For j = i + 1 To UBound(lines)
                If InStr(lines(j), "SEQ.") > 0 Then
                    seqEndLine = j - 1
                    Exit For
                End If
            Next j
        End If
        
        If inTargetSeq And currentSerial <> "" And i <= seqEndLine Then
            If InStr(lineText, "Max") > 0 And InStr(lineText, "Min") > 0 And InStr(lineText, "Reading") > 0 Then
                If i + 1 <= seqEndLine Then
                    Dim readLine As String
                    readLine = lines(i + 1)
                    If InStr(Trim(readLine), "Trip Point") = 1 Then
                        parts = SplitLine(readLine)
                        If Not olpReads.Exists(currentSerial) Then
                            If parts(0) = "Trip" And UBound(parts) >= 4 Then
                                olpReads.Add currentSerial, parts(4)
                            ElseIf UBound(parts) >= 3 Then
                                olpReads.Add currentSerial, parts(3)
                            End If
                        End If
                    End If
                End If
            End If
        End If
        
        If inTargetSeq And i > seqEndLine Then
            inTargetSeq = False
        End If
    Next i
    
    Set ExtractAllOLPReads = olpReads
End Function

Function ExtractCombineParams(lines() As String, startLine As Long, loadName As String) As Object
    Dim params As Object
    Set params = CreateObject("Scripting.Dictionary")
    
    params.Add "Vin1", ""
    params.Add "Fac1", ""
    params.Add "Vin2", ""
    params.Add "Fac2", ""
    params.Add "Vin3", ""
    params.Add "Fac3", ""
    params.Add "LoadName", loadName
    params.Add "Mode", ""
    params.Add "Ifs", ""
    params.Add "Vfs", ""
    params.Add "NoiseFilter", ""
    params.Add "IR1", ""
    params.Add "IR2", ""
    params.Add "IR3", ""
    params.Add "VdcMax", ""
    params.Add "VdcMin", ""
    params.Add "VppMax", ""
    
    Dim i As Long, lineText As String, parts() As String
    Dim foundLoadLine As Boolean, foundBitsLine As Boolean
    foundLoadLine = False
    foundBitsLine = False
    
    Dim seqEndLine As Long
    seqEndLine = startLine + 50
    For i = startLine + 1 To UBound(lines)
        If InStr(lines(i), "SEQ.") > 0 And i > startLine Then
            seqEndLine = i - 1
            Exit For
        End If
    Next i
    
    For i = startLine To seqEndLine
        If i > UBound(lines) Then Exit For
        lineText = lines(i)
        
        If InStr(lineText, "Vin Port-1") > 0 And InStr(lineText, "Vin Port-2") > 0 Then
            If i + 1 <= seqEndLine Then
                Dim vinLine As String
                vinLine = lines(i + 1)
                If InStr(vinLine, "Vin-1") > 0 Then
                    params("Vin1") = ExtractNumericValue(vinLine, "Vin-1")
                    params("Vin2") = ExtractNumericValue(vinLine, "Vin-2")
                    params("Vin3") = ExtractNumericValue(vinLine, "Vin-3")
                End If
            End If
        End If
        
        If InStr(lineText, "Fac") > 0 And InStr(lineText, "Fac-2") > 0 Then
            params("Fac1") = ExtractNumericValue(lineText, "Fac")
            params("Fac2") = ExtractNumericValue(lineText, "Fac-2")
            params("Fac3") = ExtractNumericValue(lineText, "Fac-3")
        End If
        
        If InStr(lineText, "Load Name") > 0 And InStr(lineText, "MODE") > 0 And InStr(lineText, "Ifs") > 0 And Not foundLoadLine Then
            If i + 1 <= seqEndLine Then
                Dim loadLine As String
                loadLine = lines(i + 1)
                If Trim(Left(loadLine, 2)) = "1." Then
                    parts = SplitLine(loadLine)
                    If UBound(parts) >= 7 Then
                        params("Mode") = parts(2)
                        params("Ifs") = parts(3)
                        params("Vfs") = parts(4)
                        params("NoiseFilter") = parts(7)
                        foundLoadLine = True
                    End If
                End If
            End If
        End If
        
        If InStr(lineText, "BITS-1") > 0 And InStr(lineText, "BITS-2") > 0 And Not foundBitsLine Then
            If i + 1 <= seqEndLine Then
                Dim irLine As String
                irLine = lines(i + 1)
                If Trim(Left(irLine, 2)) = "1." Then
                    parts = SplitLine(irLine)
                    If UBound(parts) >= 7 Then
                        params("IR1") = parts(5)
                        params("IR2") = parts(6)
                        params("IR3") = parts(7)
                        foundBitsLine = True
                    End If
                End If
            End If
        End If
        
        If InStr(lineText, "Vdc Max") > 0 And InStr(lineText, "Vdc Min") > 0 Then
            If i + 1 <= seqEndLine Then
                Dim vdcLine As String
                vdcLine = lines(i + 1)
                If Trim(Left(vdcLine, 2)) = "1." Then
                    parts = SplitLine(vdcLine)
                    If UBound(parts) >= 2 Then
                        params("VdcMax") = parts(1)
                        params("VdcMin") = parts(2)
                    End If
                End If
            End If
        End If
        
        If InStr(lineText, "Vpp Max") > 0 Then
            If i + 1 <= seqEndLine Then
                Dim vppLine As String
                vppLine = lines(i + 1)
                If Trim(Left(vppLine, 2)) = "1." Then
                    parts = SplitLine(vppLine)
                    If UBound(parts) >= 1 Then
                        params("VppMax") = parts(1)
                    End If
                End If
            End If
        End If
    Next i
    
    Set ExtractCombineParams = params
End Function

Function ExtractAllCombineReads(lines() As String, seqTitle As String) As Object
    Dim combineData As Object
    Set combineData = CreateObject("Scripting.Dictionary")
    
    Dim i As Long, currentSerial As String, inTargetSeq As Boolean
    Dim lineText As String, parts() As String, seqStartLine As Long, seqEndLine As Long
    
    currentSerial = ""
    inTargetSeq = False
    seqStartLine = -1
    
    For i = 0 To UBound(lines)
        lineText = lines(i)
        
        If InStr(lineText, "Serial No") > 0 Then
            currentSerial = ExtractSerialNumber(lineText)
        End If
        
        If InStr(lineText, seqTitle) > 0 Then
            inTargetSeq = True
            seqStartLine = i
            seqEndLine = i + 50
            Dim j As Long
            For j = i + 1 To UBound(lines)
                If InStr(lines(j), "SEQ.") > 0 Then
                    seqEndLine = j - 1
                    Exit For
                End If
            Next j
        End If
        
        If inTargetSeq And currentSerial <> "" And i <= seqEndLine Then
            If InStr(lineText, "Vdc Max") > 0 And InStr(lineText, "Vdc-1 RD") > 0 Then
                If i + 1 <= seqEndLine Then
                    Dim vdcLine As String
                    vdcLine = lines(i + 1)
                    If Trim(Left(vdcLine, 2)) = "1." Then
                        parts = SplitLine(vdcLine)
                        If UBound(parts) >= 5 And Not combineData.Exists(currentSerial) Then
                            Dim readings As Object
                            Set readings = CreateObject("Scripting.Dictionary")
                            readings.Add "Vdc1", parts(3)
                            readings.Add "Vdc2", parts(4)
                            readings.Add "Vdc3", parts(5)
                            readings.Add "Vpp1", ""
                            readings.Add "Vpp2", ""
                            readings.Add "Vpp3", ""
                            combineData.Add currentSerial, readings
                        End If
                    End If
                End If
            End If
            
            If InStr(lineText, "Vpp Max") > 0 And InStr(lineText, "Vpp-1 RD") > 0 Then
                If i + 1 <= seqEndLine Then
                    Dim vppLine As String
                    vppLine = lines(i + 1)
                    If Trim(Left(vppLine, 2)) = "1." Then
                        parts = SplitLine(vppLine)
                        If UBound(parts) >= 5 Then
                            If combineData.Exists(currentSerial) Then
                                combineData(currentSerial)("Vpp1") = parts(3)
                                combineData(currentSerial)("Vpp2") = parts(4)
                                combineData(currentSerial)("Vpp3") = parts(5)
                            End If
                        End If
                    End If
                End If
            End If
        End If
        
        If inTargetSeq And i > seqEndLine Then
            inTargetSeq = False
        End If
    Next i
    
    Set ExtractAllCombineReads = combineData
End Function

Function ExtractShortCircuitParams(lines() As String, startLine As Long, loadName As String) As Object
    Dim params As Object
    Set params = CreateObject("Scripting.Dictionary")
    
    params.Add "Vin", ""
    params.Add "Fin", ""
    params.Add "WhichLoad", ""
    params.Add "LoadName", loadName
    params.Add "Mode", ""
    params.Add "Ifs", ""
    params.Add "Vfs", ""
    params.Add "IR", ""
    
    Dim i As Long, lineText As String, parts() As String
    Dim foundParams As Boolean
    foundParams = False
    
    Dim seqEndLine As Long
    seqEndLine = startLine + 50
    For i = startLine + 1 To UBound(lines)
        If InStr(lines(i), "SEQ.") > 0 And i > startLine Then
            seqEndLine = i - 1
            Exit For
        End If
    Next i
    
    For i = startLine To seqEndLine
        If i > UBound(lines) Then Exit For
        lineText = lines(i)
        
        If InStr(lineText, "Vin") > 0 And InStr(lineText, "Fin") > 0 And InStr(lineText, "Delay Time") > 0 Then
            params("Vin") = ExtractNumericValue(lineText, "Vin")
            params("Fin") = ExtractNumericValue(lineText, "Fin")
        End If
        
        If InStr(lineText, "Which Load") > 0 Then
            params("WhichLoad") = ExtractNumericValue(lineText, "Which Load")
        End If
        
        If InStr(lineText, "Load Name") > 0 And InStr(lineText, "MODE") > 0 And Not foundParams Then
            If i + 1 <= seqEndLine Then
                Dim nextLine As String
                nextLine = lines(i + 1)
                If Trim(Left(nextLine, 2)) = "1." Then
                    parts = SplitLine(nextLine)
                    If UBound(parts) >= 2 Then
                        params("Mode") = parts(2)
                    End If
                    If UBound(parts) >= 3 Then
                        params("Ifs") = parts(3)
                    End If
                    If UBound(parts) >= 4 Then
                        params("Vfs") = parts(4)
                    End If
                    If UBound(parts) >= 9 Then
                        params("IR") = parts(9)
                    ElseIf UBound(parts) >= 8 Then
                        params("IR") = parts(8)
                    End If
                    foundParams = True
                End If
            End If
        End If
    Next i
    
    Set ExtractShortCircuitParams = params
End Function

Function ExtractAllPinReads(lines() As String, seqTitle As String) As Object
    Dim pinReads As Object
    Set pinReads = CreateObject("Scripting.Dictionary")
    
    Dim i As Long, currentSerial As String, inTargetSeq As Boolean
    Dim lineText As String, seqStartLine As Long, seqEndLine As Long
    
    currentSerial = ""
    inTargetSeq = False
    seqStartLine = -1
    
    For i = 0 To UBound(lines)
        lineText = lines(i)
        
        If InStr(lineText, "Serial No") > 0 Then
            currentSerial = ExtractSerialNumber(lineText)
        End If
        
        If InStr(lineText, seqTitle) > 0 Then
            inTargetSeq = True
            seqStartLine = i
            seqEndLine = i + 50
            Dim j As Long
            For j = i + 1 To UBound(lines)
                If InStr(lines(j), "SEQ.") > 0 Then
                    seqEndLine = j - 1
                    Exit For
                End If
            Next j
        End If
        
        If inTargetSeq And currentSerial <> "" And i <= seqEndLine Then
            If InStr(lineText, "Pin") > 0 And Left(Trim(lineText), 3) = "Pin" Then
                Dim pinValue As String
                pinValue = ExtractReadingAfterStars(lineText)
                If pinValue <> "" And Not pinReads.Exists(currentSerial) Then
                    pinReads.Add currentSerial, pinValue
                End If
            End If
        End If
        
        If inTargetSeq And i > seqEndLine Then
            inTargetSeq = False
        End If
    Next i
    
    Set ExtractAllPinReads = pinReads
End Function

Function ExtractHoldUpParams(lines() As String, startLine As Long, loadName As String) As Object
    Dim params As Object
    Set params = CreateObject("Scripting.Dictionary")
    
    params.Add "Vin", ""
    params.Add "Fin", ""
    params.Add "LoadName", loadName
    params.Add "Mode", ""
    params.Add "Ifs", ""
    params.Add "Vfs", ""
    params.Add "Von", ""
    params.Add "IR", ""
    params.Add "Va", ""
    params.Add "ThdMin", ""
    
    Dim i As Long, lineText As String, parts() As String
    
    Dim seqEndLine As Long
    seqEndLine = startLine + 50
    For i = startLine + 1 To UBound(lines)
        If InStr(lines(i), "SEQ.") > 0 And i > startLine Then
            seqEndLine = i - 1
            Exit For
        End If
    Next i
    
    For i = startLine To seqEndLine
        If i > UBound(lines) Then Exit For
        lineText = lines(i)
        
        If InStr(lineText, "Vin") > 0 And InStr(lineText, "Fin") > 0 And InStr(lineText, "Delay Time") > 0 Then
            params("Vin") = ExtractNumericValue(lineText, "Vin")
            params("Fin") = ExtractNumericValue(lineText, "Fin")
        End If
        
        If Trim(Left(lineText, 2)) = "1." And InStr(lineText, "Load Name") = 0 And InStr(lineText, "TRIGG") = 0 Then
            parts = SplitLine(lineText)
            If UBound(parts) >= 9 Then
                params("Mode") = parts(2)
                params("Ifs") = parts(3)
                params("Vfs") = parts(4)
                params("Von") = parts(6)
                params("IR") = parts(9)
            End If
        End If
        
        If InStr(lineText, "Va") > 0 And InStr(lineText, "Vb") > 0 And InStr(lineText, "TRIGG") > 0 Then
            If i + 2 <= seqEndLine Then
                Dim vaVbLine As String
                vaVbLine = lines(i + 2)
                If Trim(Left(vaVbLine, 2)) = "1." Then
                    Dim vaParts() As String
                    vaParts = SplitLine(vaVbLine)
                    If UBound(vaParts) >= 6 Then
                        params("Va") = vaParts(5)
                    ElseIf UBound(vaParts) >= 5 Then
                        params("Va") = vaParts(5)
                    End If
                End If
            End If
        End If
        
        If InStr(lineText, "Thd Max") > 0 And InStr(lineText, "Thd Min") > 0 And InStr(lineText, "Thd Read") > 0 Then
            If i + 1 <= seqEndLine Then
                Dim thdLine As String
                thdLine = lines(i + 1)
                If Trim(Left(thdLine, 3)) = "Ld" Or Trim(Left(thdLine, 2)) = "1." Then
                    parts = SplitLine(thdLine)
                    If UBound(parts) >= 2 Then
                        params("ThdMin") = parts(2)
                    End If
                End If
            End If
        End If
    Next i
    
    Set ExtractHoldUpParams = params
End Function

Function ExtractAllHoldUpReads(lines() As String, seqTitle As String) As Object
    Dim readData As Object
    Set readData = CreateObject("Scripting.Dictionary")
    
    Dim i As Long, currentSerial As String, inTargetSeq As Boolean
    Dim lineText As String, seqStartLine As Long, seqEndLine As Long
    
    currentSerial = ""
    inTargetSeq = False
    seqStartLine = -1
    
    For i = 0 To UBound(lines)
        lineText = lines(i)
        
        If InStr(lineText, "Serial No") > 0 Then
            currentSerial = ExtractSerialNumber(lineText)
        End If
        
        If InStr(lineText, seqTitle) > 0 Then
            inTargetSeq = True
            seqStartLine = i
            seqEndLine = i + 50
            Dim j As Long
            For j = i + 1 To UBound(lines)
                If InStr(lines(j), "SEQ.") > 0 Then
                    seqEndLine = j - 1
                    Exit For
                End If
            Next j
        End If
        
        If inTargetSeq And currentSerial <> "" And i <= seqEndLine Then
            Dim tdsValue As String, tdlValue As String
            tdsValue = ""
            tdlValue = ""
            
            If InStr(lineText, "Tds") > 0 And Left(Trim(lineText), 3) = "Tds" Then
                tdsValue = ExtractReadingAfterStars(lineText)
            End If
            
            If InStr(lineText, "Tdl") > 0 And Left(Trim(lineText), 3) = "Tdl" Then
                tdlValue = ExtractReadingAfterStars(lineText)
            End If
            
            If (tdsValue <> "" Or tdlValue <> "") And Not readData.Exists(currentSerial) Then
                Dim values As Object
                Set values = CreateObject("Scripting.Dictionary")
                values.Add "Tds", tdsValue
                values.Add "Tdl", tdlValue
                readData.Add currentSerial, values
            ElseIf readData.Exists(currentSerial) Then
                If tdsValue <> "" Then readData(currentSerial)("Tds") = tdsValue
                If tdlValue <> "" Then readData(currentSerial)("Tdl") = tdlValue
            End If
        End If
        
        If inTargetSeq And i > seqEndLine Then
            inTargetSeq = False
        End If
    Next i
    
    Set ExtractAllHoldUpReads = readData
End Function

Function ExtractReadingAfterStars(lineText As String) As String
    Dim parts() As String
    parts = SplitLine(lineText)
    
    Dim i As Integer, starCount As Integer
    starCount = 0
    
    For i = 0 To UBound(parts)
        If parts(i) = "*" Then
            starCount = starCount + 1
        ElseIf starCount = 2 Then
            ExtractReadingAfterStars = parts(i)
            Exit Function
        End If
    Next i
    
    ExtractReadingAfterStars = ""
End Function

Function ExtractTurnOnParams(lines() As String, startLine As Long, loadName As String) As Object
    Dim params As Object
    Set params = CreateObject("Scripting.Dictionary")
    
    params.Add "ONPhaseDelay", ""
    params.Add "OFFPhaseDelay", ""
    params.Add "Vin", ""
    params.Add "Fin", ""
    params.Add "LoadName", loadName
    params.Add "Mode", ""
    params.Add "Ifs", ""
    params.Add "Vfs", ""
    params.Add "Von", ""
    params.Add "IR", ""
    params.Add "Va", ""
    params.Add "TonMax", ""
    
    Dim i As Long, lineText As String, parts() As String
    
    Dim seqEndLine As Long
    seqEndLine = startLine + 50
    For i = startLine + 1 To UBound(lines)
        If InStr(lines(i), "SEQ.") > 0 Then
            seqEndLine = i - 1
            Exit For
        End If
    Next i
    
    For i = startLine To seqEndLine
        If i > UBound(lines) Then Exit For
        lineText = lines(i)
        
        If InStr(lineText, "ON Phase delay") > 0 And InStr(lineText, "OFF Phase delay") > 0 Then
            params("ONPhaseDelay") = ExtractNumericValue(lineText, "ON Phase delay")
            params("OFFPhaseDelay") = ExtractNumericValue(lineText, "OFF Phase delay")
        End If
        
        If InStr(lineText, "Vin") > 0 And InStr(lineText, "Fin") > 0 And InStr(lineText, "Vin Port") = 0 Then
            params("Vin") = ExtractNumericValue(lineText, "Vin")
            params("Fin") = ExtractNumericValue(lineText, "Fin")
        End If
        
        If Trim(Left(lineText, 2)) = "1." And InStr(lineText, "Load Name") = 0 And InStr(lineText, "TRIGG") = 0 Then
            parts = SplitLine(lineText)
            If UBound(parts) >= 9 Then
                params("Mode") = parts(2)
                params("Ifs") = parts(3)
                params("Vfs") = parts(4)
                If UBound(parts) >= 6 Then params("Von") = parts(6)
                If UBound(parts) >= 9 Then params("IR") = parts(9)
            End If
        End If
        
        If InStr(lineText, "Va") > 0 And InStr(lineText, "Vb") > 0 And InStr(lineText, "TRIGG") > 0 Then
            If i + 2 <= seqEndLine Then
                Dim vaVbLine As String
                vaVbLine = lines(i + 2)
                If Trim(Left(vaVbLine, 2)) = "1." Then
                    Dim vaParts() As String
                    vaParts = SplitLine(vaVbLine)
                    If UBound(vaParts) >= 5 Then
                        params("Va") = vaParts(5)
                    End If
                End If
            End If
        End If
        
        If Trim(Left(lineText, 2)) = "1." And i > 0 Then
            If InStr(lines(i - 1), "Ton Max") > 0 Then
                parts = SplitLine(lineText)
                If UBound(parts) >= 1 Then
                    params("TonMax") = parts(1)
                End If
            End If
        End If
    Next i
    
    Set ExtractTurnOnParams = params
End Function

Function ExtractNumericValue(text As String, keyword As String) As String
    Dim startPos As Long, equalPos As Long, result As String
    Dim i As Long, char As String, foundNumber As Boolean
    
    startPos = InStr(text, keyword)
    If startPos = 0 Then
        ExtractNumericValue = ""
        Exit Function
    End If
    
    equalPos = InStr(startPos, text, "=")
    If equalPos = 0 Then
        ExtractNumericValue = ""
        Exit Function
    End If
    
    result = ""
    foundNumber = False
    
    For i = equalPos + 1 To Len(text)
        char = Mid(text, i, 1)
        If char >= "0" And char <= "9" Or char = "." Or (char = "-" And result = "") Then
            result = result & char
            foundNumber = True
        ElseIf foundNumber And (char = " " Or char = vbTab) Then
            Exit For
        End If
    Next i
    
    ExtractNumericValue = Trim(result)
End Function

Function ExtractAllTonReads(lines() As String, seqTitle As String) As Object
    Dim tonReads As Object
    Set tonReads = CreateObject("Scripting.Dictionary")
    
    Dim i As Long, currentSerial As String, inTargetSeq As Boolean
    Dim lineText As String, parts() As String, seqStartLine As Long, seqEndLine As Long
    
    currentSerial = ""
    inTargetSeq = False
    seqStartLine = -1
    
    For i = 0 To UBound(lines)
        lineText = lines(i)
        
        If InStr(lineText, "Serial No") > 0 Then
            currentSerial = ExtractSerialNumber(lineText)
        End If
        
        If InStr(lineText, seqTitle) > 0 Then
            inTargetSeq = True
            seqStartLine = i
            seqEndLine = i + 50
            Dim j As Long
            For j = i + 1 To UBound(lines)
                If InStr(lines(j), "SEQ.") > 0 Then
                    seqEndLine = j - 1
                    Exit For
                End If
            Next j
        End If
        
        If inTargetSeq And currentSerial <> "" And i <= seqEndLine Then
            If Trim(Left(lineText, 2)) = "1." And i > 0 Then
                If InStr(lines(i - 1), "Ton Max") > 0 Then
                    parts = SplitLine(lineText)
                    If UBound(parts) >= 3 Then
                        If Not tonReads.Exists(currentSerial) Then
                            tonReads.Add currentSerial, parts(3)
                        End If
                    End If
                    inTargetSeq = False
                End If
            End If
        End If
        
        If inTargetSeq And i > seqEndLine Then
            inTargetSeq = False
        End If
    Next i
    
    Set ExtractAllTonReads = tonReads
End Function

Function ExtractSerialNumber(lineText As String) As String
    Dim startPos As Long, serial As String, i As Integer, char As String

    startPos = InStr(lineText, "Serial No")
    If startPos > 0 Then
        ' 提取 "Serial No" 之後的所有內容
        serial = Trim(Mid(lineText, startPos + 9))

        ' 跳過 "Serial No" 本身和冒號
        If Left(serial, 1) = ":" Then serial = Trim(Mid(serial, 2))

        ' 提取字母、數字、連字符、底線組成的序號
        Dim result As String
        result = ""
        For i = 1 To Len(serial)
            char = Mid(serial, i, 1)
            ' 接受字母、數字、連字符、底線
            If (char >= "A" And char <= "Z") Or _
               (char >= "a" And char <= "z") Or _
               (char >= "0" And char <= "9") Or _
               char = "-" Or char = "_" Then
                result = result & char
            Else
                ' 遇到空格或其他字符則停止
                Exit For
            End If
        Next i
        ExtractSerialNumber = result
    Else
        ExtractSerialNumber = ""
    End If
End Function

Function SplitLine(lineText As String) As String()
    Dim cleanedLine As String
    cleanedLine = lineText
    Do While InStr(cleanedLine, "  ") > 0
        cleanedLine = Replace(cleanedLine, "  ", " ")
    Loop
    SplitLine = Split(Trim(cleanedLine), " ")
End Function

Sub ExtractHeaderInfo(lines() As String, ByRef modelName As String, ByRef customer As String, ByRef inspector As String, ByRef testDate As String, ByRef unitCount As Long)
    Dim i As Long

    ' 初始化 unitCount
    unitCount = 0

    For i = 0 To UBound(lines)
        ' 提取 Model Name
        If InStr(lines(i), "Model Name") > 0 Then
            modelName = Trim(ExtractValue(lines(i), "Model Name", "Customer"))
            If modelName = "" Then
                modelName = Trim(ExtractValue(lines(i), "Model Name", vbCrLf))
            End If
        End If

        ' 提取 Customer
        If InStr(lines(i), "Customer") > 0 Then
            customer = Trim(ExtractValue(lines(i), "Customer", "Serial"))
        End If
        
        ' 提取 Inspector
        If InStr(lines(i), "Inspector") > 0 Then
            inspector = Trim(ExtractValue(lines(i), "Inspector", ""))
        End If
        
        ' 提取 Date
        If InStr(lines(i), "YYYY_MM_DD") > 0 Then
            testDate = Trim(ExtractValue(lines(i), "YYYY_MM_DD", "Begin"))
            testDate = Replace(testDate, "/", "-")
        End If
        
        ' ? 統計 Serial No 出現次數
        If InStr(lines(i), "Serial No") > 0 Then
            unitCount = unitCount + 1
        End If
    Next i
    
    ' 如果沒有找到任何 Serial No，設定預設值為 0
    If unitCount = 0 Then
        unitCount = 0
    End If
End Sub

Function ReadTextFile(filePath As String) As String
    Dim fileNum As Integer, fileContent As String
    On Error GoTo ErrorHandler
    fileNum = FreeFile
    Open filePath For Binary As #fileNum
    fileContent = Space$(LOF(fileNum))
    Get #fileNum, , fileContent
    Close #fileNum
    ReadTextFile = fileContent
    Exit Function
ErrorHandler:
    ReadTextFile = ""
    If fileNum <> 0 Then Close #fileNum
End Function

' Merge multiple TXT files into one large dataset
' First file: Keep complete content (including header info)
' Files 2+: Keep only test data (skip header info until first Serial No appears)
Function MergeMultipleFiles(filePathArray As Variant) As String
    Dim mergedContent As String
    Dim currentContent As String
    Dim lines() As String
    Dim i As Long, j As Long
    Dim firstSerialNoLine As Long
    Dim filePath As Variant
    Dim fileIndex As Long
    Dim fileCount As Long

    mergedContent = ""
    fileIndex = 0
    fileCount = UBound(filePathArray) - LBound(filePathArray) + 1

    For Each filePath In filePathArray
        fileIndex = fileIndex + 1

        ' Update status bar with current file
        Application.StatusBar = "Reading file " & fileIndex & "/" & fileCount & ": " & Dir(CStr(filePath))
        Debug.Print "Processing file " & fileIndex & ": " & filePath

        ' Read file content
        currentContent = ReadTextFile(CStr(filePath))

        If currentContent = "" Then
            Debug.Print "Warning: Failed to read file " & filePath
            GoTo NextFile
        End If

        ' First file: Keep complete content
        If fileIndex = 1 Then
            mergedContent = currentContent
            Debug.Print "First file: Preserving complete content"
        Else
            ' Files 2+: Skip header info, keep only test data
            lines = Split(currentContent, vbCrLf)
            firstSerialNoLine = -1

            ' Find first line containing "Serial No"
            For i = 0 To UBound(lines)
                If InStr(lines(i), "Serial No") > 0 Then
                    firstSerialNoLine = i
                    Debug.Print "Found first Serial No at line " & i
                    Exit For
                End If
            Next i

            ' If Serial No found, merge from before that line (usually SEQ title line)
            If firstSerialNoLine > 0 Then
                ' Find the SEQ title line belonging to this Serial No
                Dim seqLineStart As Long
                seqLineStart = firstSerialNoLine

                ' Search backward for the nearest SEQ title line
                For i = firstSerialNoLine - 1 To 0 Step -1
                    If InStr(lines(i), "SEQ.") > 0 Then
                        seqLineStart = i
                        Debug.Print "Found SEQ title at line " & i
                        Exit For
                    End If
                Next i

                ' Merge from SEQ title line
                mergedContent = mergedContent & vbCrLf & vbCrLf
                For i = seqLineStart To UBound(lines)
                    mergedContent = mergedContent & lines(i)
                    If i < UBound(lines) Then
                        mergedContent = mergedContent & vbCrLf
                    End If
                Next i

                Debug.Print "File " & fileIndex & ": Merged from line " & seqLineStart
            Else
                Debug.Print "Warning: Serial No not found in file " & filePath & ", skipping"
            End If
        End If

NextFile:
    Next filePath

    Debug.Print "Merge complete, total length: " & Len(mergedContent) & " characters"
    MergeMultipleFiles = mergedContent
End Function

Function ExtractValue(text As String, startDelim As String, endDelim As String) As String
    Dim startPos As Long, endPos As Long, result As String
    startPos = InStr(text, startDelim)
    If startPos = 0 Then
        ExtractValue = ""
        Exit Function
    End If
    startPos = startPos + Len(startDelim)
    If endDelim = "" Then
        result = Mid(text, startPos)
    Else
        endPos = InStr(startPos, text, endDelim)
        If endPos = 0 Then
            result = Mid(text, startPos)
        Else
            result = Mid(text, startPos, endPos - startPos)
        End If
    End If
    ExtractValue = Trim(result)
End Function

' ===== 驗證欄位值是否有效（不為空且不只包含非法字元） =====
Function IsValidFieldValue(fieldValue As String) As Boolean
    ' 檢查是否為空或只包含空白
    If Trim(fieldValue) = "" Then
        IsValidFieldValue = False
        Exit Function
    End If

    ' 移除所有非法字元後檢查是否還有內容
    Dim cleaned As String
    cleaned = fieldValue
    cleaned = Replace(cleaned, "/", "")
    cleaned = Replace(cleaned, "\", "")
    cleaned = Replace(cleaned, ":", "")
    cleaned = Replace(cleaned, "*", "")
    cleaned = Replace(cleaned, "?", "")
    cleaned = Replace(cleaned, """", "")
    cleaned = Replace(cleaned, "<", "")
    cleaned = Replace(cleaned, ">", "")
    cleaned = Trim(cleaned)

    ' 如果清理後沒有內容，視為無效
    If cleaned = "" Then
        IsValidFieldValue = False
    Else
        IsValidFieldValue = True
    End If
End Function

Function SaveWithCustomName(wb As Workbook, modelName As String, customer As String, testDate As String, unitCount As Long) As String
    ' 返回存檔路徑，如果失敗或取消則返回空字串
    Dim fileName As String, savePath As String, baseFileName As String
    Dim dirPath As String, finalPath As String
    Dim parts() As String
    Dim partCount As Integer

    ' 動態組合檔案名稱，只包含有效欄位
    partCount = 0
    ReDim parts(0 To 3)

    ' 檢查 Model Name
    If IsValidFieldValue(modelName) Then
        parts(partCount) = Trim(modelName)
        partCount = partCount + 1
    End If

    ' 檢查 Customer
    If IsValidFieldValue(customer) Then
        parts(partCount) = Trim(customer)
        partCount = partCount + 1
    End If

    ' 日期和數量永遠包含
    parts(partCount) = Trim(testDate)
    partCount = partCount + 1
    parts(partCount) = CStr(unitCount) & "pcs"
    partCount = partCount + 1

    ' 組合檔名
    ReDim Preserve parts(0 To partCount - 1)
    baseFileName = Join(parts, "_")
    baseFileName = CleanFileName(baseFileName)
    fileName = baseFileName & ".xlsx"

    savePath = Application.GetSaveAsFilename( _
        InitialFileName:=fileName, _
        FileFilter:="Excel Files (*.xlsx), *.xlsx", _
        Title:="Save Test Report As")

    If savePath = "False" Then
        SaveWithCustomName = ""  ' 使用者取消
        Exit Function
    End If

    ' 取出目錄路徑和檔案名
    Dim lastSlash As Long
    lastSlash = InStrRev(savePath, "\")
    If lastSlash = 0 Then lastSlash = InStrRev(savePath, "/")

    If lastSlash > 0 Then
        dirPath = Left(savePath, lastSlash)
        fileName = Mid(savePath, lastSlash + 1)
    Else
        dirPath = ""
        fileName = savePath
    End If

    ' 只清理檔案名部分，不包括路徑
    fileName = CleanFileName(fileName)
    finalPath = dirPath & fileName
    savePath = finalPath

    Dim counter As Integer, basePath As String, ext As String
    basePath = Left(savePath, InStrRev(savePath, ".") - 1)
    ext = Mid(savePath, InStrRev(savePath, "."))
    counter = 1

    While Dir(savePath) <> ""
        counter = counter + 1
        savePath = basePath & "_" & counter & ext
    Wend

    On Error Resume Next
    wb.SaveAs fileName:=savePath, FileFormat:=xlOpenXMLWorkbook

    If Err.Number = 0 Then
        SaveWithCustomName = savePath  ' 成功，返回路徑
    Else
        MsgBox "存檔錯誤: " & Err.Description, vbCritical, "Error"
        SaveWithCustomName = ""  ' 失敗
    End If
    On Error GoTo 0
End Function

Function CleanFileName(fileName As String) As String
    Dim invalidChars As String, i As Integer, result As String
    
    ' 先 Trim 移除頭尾空白
    result = Trim(fileName)
    
    ' 先去掉非法字符
    invalidChars = "\/:*?""<>|"
    For i = 1 To Len(invalidChars)
        result = Replace(result, Mid(invalidChars, i, 1), "_")
    Next i
    
    ' 移除連續的空格（替換為單一空格）
    While InStr(result, "  ") > 0
        result = Replace(result, "  ", " ")
    Wend
    
    ' 移除連續的下滑線（替換為單一下滑線）
    While InStr(result, "__") > 0
        result = Replace(result, "__", "_")
    Wend
    
    ' 移除空格和下滑線組合（如"_ "或" _"）
    result = Replace(result, "_ ", "_")
    result = Replace(result, " _", "_")
    
    ' 最後移除開頭和結尾的下滑線
    While Left(result, 1) = "_"
        result = Mid(result, 2)
    Wend
    While Right(result, 1) = "_"
        result = Left(result, Len(result) - 1)
    Wend
    
    ' 長度限制
    If Len(result) > 100 Then result = Left(result, 100)
    
    CleanFileName = result
End Function

Function CleanSheetName(sheetName As String) As String
    Dim invalidChars As String, i As Integer, result As String
    invalidChars = "\/:*?[]"
    result = sheetName
    For i = 1 To Len(invalidChars)
        result = Replace(result, Mid(invalidChars, i, 1), "_")
    Next i
    If Len(result) > 31 Then result = Left(result, 31)
    result = Trim(result)
    If result = "" Then result = "Sheet1"
    CleanSheetName = result
End Function

Function ExtractDynamicParams(lines() As String, startLine As Long, loadName As String) As Object
    Dim params As Object
    Set params = CreateObject("Scripting.Dictionary")
    
    params.Add "Vin", ""
    params.Add "Fin", ""
    params.Add "LoadName", loadName
    params.Add "Mode", ""
    params.Add "Ifs", ""
    params.Add "Vfs", ""
    params.Add "NoiseFilter", ""
    params.Add "Period1", ""
    params.Add "Period2", ""
    params.Add "Rise", ""
    params.Add "Fall", ""
    params.Add "IR1", ""
    params.Add "IR2", ""
    params.Add "VsMax", ""
    params.Add "VsMin", ""
    
    Dim i As Long, lineText As String, parts() As String
    Dim foundLoadParams As Boolean
    foundLoadParams = False
    
    Dim seqEndLine As Long
    seqEndLine = startLine + 50
    For i = startLine + 1 To UBound(lines)
        If InStr(lines(i), "SEQ.") > 0 And i > startLine Then
            seqEndLine = i - 1
            Exit For
        End If
    Next i
    
    For i = startLine To seqEndLine
        If i > UBound(lines) Then Exit For
        lineText = lines(i)
        
        If InStr(lineText, "Vin") > 0 And InStr(lineText, "Fin") > 0 And InStr(lineText, "Delay Time") > 0 Then
            params("Vin") = ExtractNumericValue(lineText, "Vin")
            params("Fin") = ExtractNumericValue(lineText, "Fin")
        End If
        
        If InStr(lineText, "Load Name") > 0 And InStr(lineText, "MODE") > 0 And Not foundLoadParams Then
            If i + 1 <= seqEndLine Then
                Dim nextLine As String
                nextLine = lines(i + 1)
                If Trim(Left(nextLine, 2)) = "1." Then
                    parts = SplitLine(nextLine)
                    If UBound(parts) >= 2 Then
                        params("Mode") = parts(2)
                    End If
                    If UBound(parts) >= 3 Then
                        params("Ifs") = parts(3)
                    End If
                    If UBound(parts) >= 4 Then
                        params("Vfs") = parts(4)
                    End If
                    If UBound(parts) >= 6 Then
                        params("NoiseFilter") = parts(6)
                    End If
                    foundLoadParams = True
                End If
            End If
        End If
        
        If InStr(lineText, "Period-1") > 0 And InStr(lineText, "Period-2") > 0 And InStr(lineText, "Rise") > 0 Then
            If i + 1 <= seqEndLine Then
                Dim periodLine As String
                periodLine = lines(i + 1)
                If Trim(Left(periodLine, 2)) = "1." Then
                    parts = SplitLine(periodLine)
                    If UBound(parts) >= 1 Then params("Period1") = parts(1)
                    If UBound(parts) >= 2 Then params("Period2") = parts(2)
                    If UBound(parts) >= 3 Then params("Rise") = parts(3)
                    If UBound(parts) >= 4 Then params("Fall") = parts(4)
                End If
            End If
        End If
        
        If InStr(lineText, "I/R-1") > 0 And InStr(lineText, "Reading") > 0 And InStr(lineText, "I/R-2") > 0 Then
            If i + 1 <= seqEndLine Then
                Dim irLine As String
                irLine = lines(i + 1)
                If Trim(Left(irLine, 2)) = "1." Then
                    parts = SplitLine(irLine)
                    If UBound(parts) >= 1 Then params("IR1") = parts(1)
                    If UBound(parts) >= 3 Then params("IR2") = parts(3)
                End If
            End If
        End If
        
        If InStr(lineText, "Vs Max") > 0 And InStr(lineText, "Vs Min") > 0 Then
            If i + 1 <= seqEndLine Then
                Dim vsLine As String
                vsLine = lines(i + 1)
                If Trim(Left(vsLine, 2)) = "1." Then
                    parts = SplitLine(vsLine)
                    If UBound(parts) >= 1 Then params("VsMax") = parts(1)
                    If UBound(parts) >= 2 Then params("VsMin") = parts(2)
                End If
            End If
        End If
    Next i
    
    Set ExtractDynamicParams = params
End Function

Function ExtractLoadRegulationParams(lines() As String, startLine As Long, loadName As String) As Object
    Dim params As Object
    Set params = CreateObject("Scripting.Dictionary")

    ' 添加所有 22 個參數
    params.Add "Vin", ""
    params.Add "Fin", ""
    params.Add "DelayTime", ""
    params.Add "MeasTime", ""
    params.Add "LoadName", loadName
    params.Add "Mode", ""
    params.Add "Ifs", ""
    params.Add "Vfs", ""
    params.Add "Meas", ""
    params.Add "VdcFilter", ""
    params.Add "NoiseFilter", ""
    params.Add "Von", ""
    params.Add "Bits1", ""
    params.Add "Bits2", ""
    params.Add "Bits3", ""
    params.Add "SlewRate", ""
    params.Add "IR1", ""
    params.Add "IR2", ""
    params.Add "IR3", ""
    params.Add "VdcMax", ""
    params.Add "VdcMin", ""
    params.Add "VppMax", ""

    Dim i As Long, lineText As String, parts() As String
    Dim seqEndLine As Long
    seqEndLine = startLine + 50

    For i = startLine + 1 To UBound(lines)
        If InStr(lines(i), "SEQ.") > 0 And i > startLine Then
            seqEndLine = i - 1
            Exit For
        End If
    Next i

    For i = startLine To seqEndLine
        If i > UBound(lines) Then Exit For
        lineText = lines(i)

        ' 提取 Vin, Fin, Delay Time, Meas. Time
        If InStr(lineText, "Vin") > 0 And InStr(lineText, "Fin") > 0 And InStr(lineText, "Delay Time") > 0 Then
            params("Vin") = ExtractNumericValue(lineText, "Vin")
            params("Fin") = ExtractNumericValue(lineText, "Fin")
            params("DelayTime") = ExtractNumericValue(lineText, "Delay Time")
            params("MeasTime") = ExtractNumericValue(lineText, "Meas. Time")
        End If

        ' 提取 Load Name, MODE, Ifs, Vfs, Meas., Vdc Filter, Noise Filter, Von
        If InStr(lineText, "Load Name") > 0 And InStr(lineText, "MODE") > 0 And InStr(lineText, "Vdc Filter") > 0 Then
            If i + 1 <= seqEndLine Then
                Dim loadLine As String
                loadLine = lines(i + 1)
                If Trim(Left(loadLine, 2)) = "1." Then
                    parts = SplitLine(loadLine)
                    If UBound(parts) >= 1 Then params("LoadName") = parts(1)
                    If UBound(parts) >= 2 Then params("Mode") = parts(2)
                    If UBound(parts) >= 3 Then params("Ifs") = parts(3)
                    If UBound(parts) >= 4 Then params("Vfs") = parts(4)
                    If UBound(parts) >= 5 Then params("Meas") = parts(5)
                    If UBound(parts) >= 6 Then params("VdcFilter") = parts(6)
                    If UBound(parts) >= 7 Then params("NoiseFilter") = parts(7)
                    If UBound(parts) >= 8 Then params("Von") = parts(8)
                End If
            End If
        End If

        ' 提取 BITS-1, BITS-2, BITS-3, SLEW Rate, I/R-1, I/R-2, I/R-3
        If InStr(lineText, "BITS-1") > 0 And InStr(lineText, "BITS-2") > 0 And InStr(lineText, "I/R-1") > 0 Then
            If i + 1 <= seqEndLine Then
                Dim bitsLine As String
                bitsLine = lines(i + 1)
                If Trim(Left(bitsLine, 2)) = "1." Then
                    parts = SplitLine(bitsLine)
                    If UBound(parts) >= 1 Then params("Bits2") = parts(1)
                    If UBound(parts) >= 2 Then params("Bits2") = parts(2)
                    If UBound(parts) >= 3 Then params("Bits3") = parts(3)
                    If UBound(parts) >= 4 Then params("SlewRate") = parts(4)
                    If UBound(parts) >= 5 Then params("IR1") = parts(5)
                    If UBound(parts) >= 6 Then params("IR2") = parts(6)
                    If UBound(parts) >= 7 Then params("IR3") = parts(7)
                End If
            End If
        End If

        ' 提取 Vdc Max, Vdc Min, Vpp Max
        If InStr(lineText, "Max") > 0 And InStr(lineText, "Min") > 0 And InStr(lineText, "Read-1") > 0 Then
            If i + 1 <= seqEndLine Then
                Dim vdcLine As String
                vdcLine = lines(i + 1)
                If InStr(vdcLine, "Vdc") > 0 Then
                    parts = SplitLine(vdcLine)
                    If UBound(parts) >= 1 Then params("VdcMax") = parts(1)
                    If UBound(parts) >= 2 Then params("VdcMin") = parts(2)
                End If
                If i + 2 <= seqEndLine Then
                    Dim vppLine As String
                    vppLine = lines(i + 2)
                    If InStr(vppLine, "Vpp") > 0 Then
                        parts = SplitLine(vppLine)
                        If UBound(parts) >= 1 Then params("VppMax") = parts(1)
                    End If
                End If
            End If
        End If
    Next i

    Set ExtractLoadRegulationParams = params
End Function

Function ExtractAllDynamicReads(lines() As String, seqTitle As String) As Object
    Dim readData As Object
    Set readData = CreateObject("Scripting.Dictionary")
    
    Dim i As Long, currentSerial As String, inTargetSeq As Boolean
    Dim lineText As String, seqStartLine As Long, seqEndLine As Long
    
    currentSerial = ""
    inTargetSeq = False
    seqStartLine = -1
    
    For i = 0 To UBound(lines)
        lineText = lines(i)
        
        If InStr(lineText, "Serial No") > 0 Then
            currentSerial = ExtractSerialNumber(lineText)
        End If
        
        If InStr(lineText, seqTitle) > 0 Then
            inTargetSeq = True
            seqStartLine = i
            seqEndLine = i + 50
            Dim j As Long
            For j = i + 1 To UBound(lines)
                If InStr(lines(j), "SEQ.") > 0 Then
                    seqEndLine = j - 1
                    Exit For
                End If
            Next j
        End If
        
        If inTargetSeq And currentSerial <> "" And i <= seqEndLine Then
            If InStr(lineText, "Vs Max") > 0 And InStr(lineText, "Vs-1 Rd") > 0 And InStr(lineText, "Vs-2 Rd") > 0 Then
                If i + 1 <= seqEndLine Then
                    Dim vsLine As String
                    vsLine = lines(i + 1)
                    If Trim(Left(vsLine, 2)) = "1." Then
                        Dim parts() As String
                        parts = SplitLine(vsLine)
                        If UBound(parts) >= 4 And Not readData.Exists(currentSerial) Then
                            Dim values As Object
                            Set values = CreateObject("Scripting.Dictionary")
                            values.Add "Vs1", parts(3)
                            values.Add "Vs2", parts(4)
                            readData.Add currentSerial, values
                        End If
                    End If
                End If
            End If
        End If
        
        If inTargetSeq And i > seqEndLine Then
            inTargetSeq = False
        End If
    Next i
    
    Set ExtractAllDynamicReads = readData
End Function

Function ExtractAllLoadRegulationReads(lines() As String, seqTitle As String) As Object
    Dim readData As Object
    Set readData = CreateObject("Scripting.Dictionary")

    Dim i As Long, currentSerial As String, inTargetSeq As Boolean
    Dim lineText As String, seqStartLine As Long, seqEndLine As Long

    currentSerial = ""
    inTargetSeq = False
    seqStartLine = -1

    For i = 0 To UBound(lines)
        lineText = lines(i)

        If InStr(lineText, "Serial No") > 0 Then
            currentSerial = ExtractSerialNumber(lineText)
        End If

        If InStr(lineText, seqTitle) > 0 Then
            inTargetSeq = True
            seqStartLine = i
            seqEndLine = i + 50
            Dim j As Long
            For j = i + 1 To UBound(lines)
                If InStr(lines(j), "SEQ.") > 0 Then
                    seqEndLine = j - 1
                    Exit For
                End If
            Next j
        End If

        If inTargetSeq And currentSerial <> "" And i <= seqEndLine Then
            ' 尋找讀值區域：Max, Min, Read-1, Read-2, Read-3
            If InStr(lineText, "Max") > 0 And InStr(lineText, "Min") > 0 And InStr(lineText, "Read-1") > 0 Then
                If i + 1 <= seqEndLine And Not readData.Exists(currentSerial) Then
                    Dim values As Object
                    Set values = CreateObject("Scripting.Dictionary")

                    ' 讀取 Vdc 行
                    If i + 1 <= seqEndLine Then
                        Dim vdcLine As String
                        vdcLine = lines(i + 1)
                        If InStr(vdcLine, "Vdc") > 0 Then
                            Dim parts() As String
                            parts = SplitLine(vdcLine)
                            ' Vdc       5.500      5.200      5.218        5.237        5.218
                            ' parts(0)=Vdc, parts(1)=Max, parts(2)=Min, parts(3)=Read-1, parts(4)=Read-2, parts(5)=Read-3
                            If UBound(parts) >= 3 Then values.Add "VdcRead1", parts(3)
                            If UBound(parts) >= 4 Then values.Add "VdcRead2", parts(4)
                            If UBound(parts) >= 5 Then values.Add "VdcRead3", parts(5)
                        End If
                    End If

                    ' 讀取 Vpp 行
                    If i + 2 <= seqEndLine Then
                        Dim vppLine As String
                        vppLine = lines(i + 2)
                        If InStr(vppLine, "Vpp") > 0 Then
                            parts = SplitLine(vppLine)
                            If UBound(parts) >= 3 Then values.Add "VppRead1", parts(3)
                            If UBound(parts) >= 4 Then values.Add "VppRead2", parts(4)
                            If UBound(parts) >= 5 Then values.Add "VppRead3", parts(5)
                        End If
                    End If

                    ' 讀取 Vn 行
                    If i + 3 <= seqEndLine Then
                        Dim vnLine As String
                        vnLine = lines(i + 3)
                        If InStr(vnLine, "Vn") > 0 Then
                            parts = SplitLine(vnLine)
                            ' Vn            *                 0.009        0.006        0.006
                            ' parts(0)=Vn, parts(1)=*, parts(2)=0.009, parts(3)=0.006, parts(4)=0.006
                            If UBound(parts) >= 2 Then values.Add "VnRead1", parts(2)
                            If UBound(parts) >= 3 Then values.Add "VnRead2", parts(3)
                            If UBound(parts) >= 4 Then values.Add "VnRead3", parts(4)
                        End If
                    End If

                    ' 讀取 dV21, dV31
                    If i + 5 <= seqEndLine Then
                        Dim dvLine As String
                        dvLine = lines(i + 5)
                        If InStr(dvLine, "dV21") > 0 And InStr(dvLine, "dV31") > 0 Then
                            ' dV(+) =         *  dV(-) =         *  dV21 =     0.018     dV31 =     0.000
                            values.Add "dV21", ExtractNumericValue(dvLine, "dV21")
                            values.Add "dV31", ExtractNumericValue(dvLine, "dV31")
                        End If
                    End If

                    readData.Add currentSerial, values
                End If
            End If
        End If

        If inTargetSeq And i > seqEndLine Then
            inTargetSeq = False
        End If
    Next i

    Set ExtractAllLoadRegulationReads = readData
End Function

Function ExtractInputOutputParams(lines() As String, startLine As Long, Optional loadName As String = "12V", Optional seqType As String = "InputOutput_Iin") As Object
    Dim params As Object
    Set params = CreateObject("Scripting.Dictionary")
    
    params.Add "Vin", ""
    params.Add "Fin", ""
    params.Add "LoadName", loadName
    params.Add "Mode", ""
    params.Add "Ifs", ""
    params.Add "Vfs", ""
    params.Add "NoiseFilter", ""
    
    ' 根據類型新增不同參數
    If seqType = "InputOutput_Iin" Or seqType = "InputOutput_General" Then
        params.Add "IinrmsMax", ""
    ElseIf seqType = "InputOutput_Pin" Then
        params.Add "PinMax", ""
    ElseIf seqType = "InputOutput_Eff" Then
        params.Add "EffMin", ""
    End If

    params.Add "IR", ""
    params.Add "VdcMax", ""
    params.Add "VdcMin", ""
    params.Add "VppMax", ""

    ' ===== 新增:Vin Max/Min (Eff 和 General 類型特有) =====
    If seqType = "InputOutput_General" Or seqType = "InputOutput_Eff" Then
        params.Add "VinMax", ""
        params.Add "VinMin", ""
    End If
    
    Dim i As Long, lineText As String, parts() As String
    Dim foundLoadParams As Boolean
    foundLoadParams = False
    
    Dim seqEndLine As Long
    seqEndLine = startLine + 50
    
    For i = startLine + 1 To UBound(lines)
        If InStr(lines(i), "SEQ.") > 0 And i > startLine Then
            seqEndLine = i - 1
            Exit For
        End If
    Next i
    
    For i = startLine To seqEndLine
        If i > UBound(lines) Then Exit For
        lineText = lines(i)
        
        ' 提取 Vin 和 Fin
        If InStr(lineText, "Vin") > 0 And InStr(lineText, "Fin") > 0 And InStr(lineText, "Delay Time") > 0 Then
            params("Vin") = ExtractNumericValue(lineText, "Vin")
            params("Fin") = ExtractNumericValue(lineText, "Fin")
        End If
        
        ' 提取 Load 參數
        If InStr(lineText, "Load Name") > 0 And InStr(lineText, "MODE") > 0 And Not foundLoadParams Then
            If i + 1 <= seqEndLine Then
                Dim nextLine As String
                nextLine = lines(i + 1)
                If Trim(Left(nextLine, 2)) = "1." Then
                    parts = SplitLine(nextLine)
                    If UBound(parts) >= 2 Then params("Mode") = parts(2)
                    If UBound(parts) >= 3 Then params("Ifs") = parts(3)
                    If UBound(parts) >= 4 Then params("Vfs") = parts(4)
                    If UBound(parts) >= 8 Then params("NoiseFilter") = parts(8)
                    foundLoadParams = True
                End If
            End If
        End If
        
        ' 找到 "Max  Min  Reading" 標題行
        If InStr(lineText, "Max") > 0 And InStr(lineText, "Min") > 0 And InStr(lineText, "Reading") > 0 And InStr(lineText, "=") = 0 Then
            ' ===== 提取 Iinrms Max(第1行,索引[1])=====
            If (seqType = "InputOutput_Iin" Or seqType = "InputOutput_General") And i + 1 <= seqEndLine Then
                Dim iinrmsLine As String
                iinrmsLine = lines(i + 1)
                If InStr(iinrmsLine, "Iinrms") > 0 Then
                    parts = SplitLine(iinrmsLine)
                    If UBound(parts) >= 1 And parts(1) <> "*" Then
                        params("IinrmsMax") = parts(1)
                    End If
                End If
            End If
            
            ' ===== 提取 Pin Max(第2行,索引[1])=====
            If seqType = "InputOutput_Pin" And i + 2 <= seqEndLine Then
                Dim pinLine As String
                pinLine = lines(i + 2)
                If InStr(pinLine, "Pin") > 0 Then
                    parts = SplitLine(pinLine)
                    If UBound(parts) >= 1 And parts(1) <> "*" Then
                        params("PinMax") = parts(1)
                    End If
                End If
            End If
            
            ' ===== 提取 Eff Min(第4行,索引[2],因為是 Min 欄)=====
            If seqType = "InputOutput_Eff" And i + 4 <= seqEndLine Then
                Dim effLine As String
                effLine = lines(i + 4)
                If InStr(effLine, "Eff") > 0 Then
                    parts = SplitLine(effLine)
                    If UBound(parts) >= 2 And parts(2) <> "*" Then
                        params("EffMin") = parts(2)
                    End If
                End If
            End If

            ' ===== 新增:提取 Vin Max/Min (Eff 和 General 類型) =====
            If seqType = "InputOutput_General" Or seqType = "InputOutput_Eff" Then
                ' 在 "Max Min Reading" 區塊中尋找 Vin 行
                Dim vinSearchEnd As Long
                vinSearchEnd = i + 10
                If vinSearchEnd > seqEndLine Then vinSearchEnd = seqEndLine
                
                Dim vinIdx As Long
                For vinIdx = i + 1 To vinSearchEnd
                    If InStr(lines(vinIdx), "Vin") > 0 And InStr(lines(vinIdx), "Fin") = 0 Then
                        parts = SplitLine(lines(vinIdx))
                        ' Vin     102.000   98.000    99.550
                        ' 索引:    0         1        2        3
                        Dim vinPartIdx As Integer
                        For vinPartIdx = 0 To UBound(parts)
                            If parts(vinPartIdx) = "Vin" Then
                                If vinPartIdx + 1 <= UBound(parts) And parts(vinPartIdx + 1) <> "*" Then
                                    params("VinMax") = parts(vinPartIdx + 1)
                                End If
                                If vinPartIdx + 2 <= UBound(parts) And parts(vinPartIdx + 2) <> "*" Then
                                    params("VinMin") = parts(vinPartIdx + 2)
                                End If
                                Exit For
                            End If
                        Next vinPartIdx
                        Exit For
                    End If
                Next vinIdx
            End If
        End If
        
        ' 提取 I/R
        If InStr(lineText, "RISE") > 0 And InStr(lineText, "I/R") > 0 Then
            If i + 1 <= seqEndLine Then
                Dim irLine As String
                irLine = lines(i + 1)
                If Trim(Left(irLine, 2)) = "1." Then
                    parts = SplitLine(irLine)
                    If UBound(parts) >= 2 Then
                        params("IR") = parts(2)
                    End If
                End If
            End If
        End If
        
        ' 提取 Vdc Max/Min 和 Vpp Max
        If InStr(lineText, "Vdc Max") > 0 And InStr(lineText, "Vdc Min") > 0 And InStr(lineText, "Vdc Read") > 0 Then
            If i + 1 <= seqEndLine Then
                Dim vdcLine As String
                vdcLine = lines(i + 1)
                If Trim(Left(vdcLine, 2)) = "1." Then
                    parts = SplitLine(vdcLine)
                    If UBound(parts) >= 1 Then params("VdcMax") = parts(1)
                    If UBound(parts) >= 2 Then params("VdcMin") = parts(2)
                    If UBound(parts) >= 4 Then params("VppMax") = parts(4)
                End If
            End If
        End If
    Next i
    
    Set ExtractInputOutputParams = params
End Function



Function ExtractAllInputOutputReads(lines() As String, seqTitle As String, seqType As String) As Object
    Dim ioData As Object
    Set ioData = CreateObject("Scripting.Dictionary")
    
    Dim i As Long, currentSerial As String, inTargetSeq As Boolean
    Dim lineText As String, parts() As String, seqStartLine As Long, seqEndLine As Long
    
    currentSerial = ""
    inTargetSeq = False
    seqStartLine = -1
    seqEndLine = -1
    
    For i = 0 To UBound(lines)
        lineText = lines(i)
        
        If InStr(lineText, "Serial No") > 0 Then
            currentSerial = ExtractSerialNumber(lineText)
        End If
        
        If InStr(lineText, seqTitle) > 0 Then
            inTargetSeq = True
            seqStartLine = i
            
            seqEndLine = i + 50
            Dim j As Long
            For j = i + 1 To UBound(lines)
                If InStr(lines(j), "SEQ.") > 0 Then
                    seqEndLine = j - 1
                    Exit For
                End If
            Next j
        End If
        
        If inTargetSeq And currentSerial <> "" And i <= seqEndLine Then
            If Not ioData.Exists(currentSerial) Then
                Dim readings As Object
                Set readings = CreateObject("Scripting.Dictionary")
                readings.Add "Iinrms", ""
                readings.Add "Pin", ""
                readings.Add "Pdc", ""
                readings.Add "Eff", ""
                readings.Add "Pf", ""
                
                ' 根據類型決定是否新增 Idc Read
                If seqType <> "InputOutput_Pin" Then
                    readings.Add "Idc", ""
                End If
                
                readings.Add "Vdc", ""
                readings.Add "Vpp", ""
                
                ' ? 新增:通用類型需要 VinRead
                If seqType = "InputOutput_General" Then
                    readings.Add "VinRead", ""
                End If
                
                ioData.Add currentSerial, readings
            End If
            
            If InStr(lineText, "Max") > 0 And InStr(lineText, "Min") > 0 And InStr(lineText, "Reading") > 0 And InStr(lineText, "=") = 0 Then
                If i + 4 <= seqEndLine Then
                    If i + 1 <= seqEndLine And InStr(lines(i + 1), "Iinrms") > 0 Then
                        Dim iinrmsLine As String
                        iinrmsLine = lines(i + 1)
                        parts = SplitLine(iinrmsLine)
                        Dim iinrmsIdx As Integer
                        For iinrmsIdx = 0 To UBound(parts)
                            If parts(iinrmsIdx) = "Iinrms" Then
                                If iinrmsIdx + 3 <= UBound(parts) Then
                                    If parts(iinrmsIdx + 3) <> "*" Then
                                        ioData(currentSerial)("Iinrms") = parts(iinrmsIdx + 3)
                                    End If
                                End If
                                Exit For
                            End If
                        Next iinrmsIdx
                    End If
                    
                    If i + 2 <= seqEndLine And InStr(lines(i + 2), "Pin") > 0 Then
                        Dim pinLine As String
                        pinLine = lines(i + 2)
                        parts = SplitLine(pinLine)
                        Dim pinIdx As Integer
                        For pinIdx = 0 To UBound(parts)
                            If parts(pinIdx) = "Pin" Then
                                If pinIdx + 3 <= UBound(parts) Then
                                    If parts(pinIdx + 3) <> "*" Then
                                        ioData(currentSerial)("Pin") = parts(pinIdx + 3)
                                    End If
                                End If
                                Exit For
                            End If
                        Next pinIdx
                    End If
                    
                    If i + 3 <= seqEndLine And InStr(lines(i + 3), "Pdc") > 0 Then
                        Dim pdcLine As String
                        pdcLine = lines(i + 3)
                        parts = SplitLine(pdcLine)
                        Dim pdcIdx As Integer, pfIdx As Integer
                        For pdcIdx = 0 To UBound(parts)
                            If parts(pdcIdx) = "Pdc" Then
                                If pdcIdx + 3 <= UBound(parts) Then
                                    If parts(pdcIdx + 3) <> "*" Then
                                        ioData(currentSerial)("Pdc") = parts(pdcIdx + 3)
                                    End If
                                End If
                                Exit For
                            End If
                        Next pdcIdx
                        
                        For pfIdx = 0 To UBound(parts)
                            If parts(pfIdx) = "Pf" Then
                                If pfIdx + 3 <= UBound(parts) Then
                                    If parts(pfIdx + 3) <> "*" Then
                                        ioData(currentSerial)("Pf") = parts(pfIdx + 3)
                                    End If
                                End If
                                Exit For
                            End If
                        Next pfIdx
                    End If
                    
                    If i + 4 <= seqEndLine And InStr(lines(i + 4), "Eff") > 0 Then
                        Dim effLine As String
                        effLine = lines(i + 4)
                        parts = SplitLine(effLine)
                        Dim effIdx As Integer
                        For effIdx = 0 To UBound(parts)
                            If parts(effIdx) = "Eff" Then
                                If effIdx + 3 <= UBound(parts) Then
                                    If parts(effIdx + 3) <> "*" Then
                                        ioData(currentSerial)("Eff") = parts(effIdx + 3)
                                    End If
                                End If
                                Exit For
                            End If
                        Next effIdx
                    End If
                    
                    ' ? 新增:提取 Vin Reading (通用類型)
                    If seqType = "InputOutput_General" Then
                        Dim vinSearchEnd As Long
                        vinSearchEnd = i + 10
                        If vinSearchEnd > seqEndLine Then vinSearchEnd = seqEndLine
                        
                        Dim vinIdx As Long
                        For vinIdx = i + 1 To vinSearchEnd
                            If InStr(lines(vinIdx), "Vin") > 0 And InStr(lines(vinIdx), "Fin") = 0 Then
                                parts = SplitLine(lines(vinIdx))
                                ' Vin     102.000   98.000    99.550
                                ' 索引:    0         1        2        3 (Reading)
                                Dim vinPartIdx As Integer
                                For vinPartIdx = 0 To UBound(parts)
                                    If parts(vinPartIdx) = "Vin" Then
                                        If vinPartIdx + 3 <= UBound(parts) And parts(vinPartIdx + 3) <> "*" Then
                                            ioData(currentSerial)("VinRead") = parts(vinPartIdx + 3)
                                        End If
                                        Exit For
                                    End If
                                Next vinPartIdx
                                Exit For
                            End If
                        Next vinIdx
                    End If
                End If
            End If
            
            If InStr(lineText, "RISE") > 0 And InStr(lineText, "I/R") > 0 And InStr(lineText, "Idc Read") > 0 Then
                If i + 1 <= seqEndLine Then
                    Dim idcLine As String
                    idcLine = lines(i + 1)
                    If Trim(Left(idcLine, 2)) = "1." Or InStr(idcLine, "Ld") = 0 Then
                        parts = SplitLine(idcLine)
                        If UBound(parts) >= 5 Then
                            If parts(5) <> "*" Then
                                ioData(currentSerial)("Idc") = parts(5)
                            End If
                        End If
                    End If
                End If
            End If
            
            If InStr(lineText, "Vdc Max") > 0 And InStr(lineText, "Vdc Read") > 0 And InStr(lineText, "Vpp Read") > 0 Then
                If i + 1 <= seqEndLine Then
                    Dim vdcLine As String
                    vdcLine = lines(i + 1)
                    If Trim(Left(vdcLine, 2)) = "1." Or InStr(vdcLine, "Ld") = 0 Then
                        parts = SplitLine(vdcLine)
                        If UBound(parts) >= 3 Then
                            If parts(3) <> "*" Then
                                ioData(currentSerial)("Vdc") = parts(3)
                            End If
                        End If
                        If UBound(parts) >= 6 Then
                            If parts(6) <> "*" Then
                                ioData(currentSerial)("Vpp") = parts(6)
                            End If
                        End If
                    End If
                End If
            End If
        End If
        
        If inTargetSeq And i > seqEndLine Then
            inTargetSeq = False
        End If
    Next i
    
    Set ExtractAllInputOutputReads = ioData
End Function

' ============================================
' 步驟1：新增輔助函數（複製到代碼最底部）
' ============================================

' 計算每種測試的參數行數
Function GetParamRowCount(testType As String) As Long
    Select Case testType
        Case "TurnOn"
            GetParamRowCount = 12
        Case "HoldUp"
            GetParamRowCount = 10
        Case "ShortCircuit"
            GetParamRowCount = 8
        Case "Combine"
            GetParamRowCount = 17
        Case "OLP"
            GetParamRowCount = 10
        Case "Dynamic"
            GetParamRowCount = 15
        Case "LoadRegulation"
            GetParamRowCount = 21  ' 1 標題 + 1 Condition/Value 標題 + 19 參數（已移除 BITS-1/2/3）
        Case "InputOutput_Iin", "InputOutput_Pin"
            GetParamRowCount = 12  ' 不含 Vin Max/Min
        Case "InputOutput_Eff", "InputOutput_General"
            GetParamRowCount = 15  ' ===== Eff 和 General 都包含 Vin Max/Min =====
        Case Else
            GetParamRowCount = 10
    End Select
End Function
Function CleanNumericValue(Value As String) As String
    Dim cleaned As String
    cleaned = Trim(Value)
    cleaned = Replace(cleaned, "?", "")
    cleaned = Trim(cleaned)
    CleanNumericValue = cleaned
End Function
' ========================================
' 輔助函數：為兩列式參數添加分組背景
' ========================================
Sub AddParamGroup(ws As Worksheet, ByRef row As Long, col1 As Integer, col2 As Integer, _
                  paramNames As Variant, paramKeys As Variant, params As Object, bgColor As Long)
    Dim i As Integer
    For i = 0 To UBound(paramNames)
        ws.Cells(row, col1).Value = paramNames(i)
        ws.Cells(row, col2).Value = params(paramKeys(i))
        With ws.Range(ws.Cells(row, col1), ws.Cells(row, col2))
            .Interior.Color = bgColor
            .HorizontalAlignment = xlCenter
            .VerticalAlignment = xlCenter
        End With
        row = row + 1
    Next i
End Sub

Sub AddParamGroupIO(ws As Worksheet, ByRef row As Long, col1 As Integer, col2 As Integer, _
                    paramNames As Variant, paramKeys As Variant, params As Object, bgColor As Long)
    Dim i As Integer
    For i = 0 To UBound(paramNames)
        ws.Cells(row, col1).Value = paramNames(i)
        ws.Cells(row, col2).Value = params(paramKeys(i))
        With ws.Range(ws.Cells(row, col1), ws.Cells(row, col2))
            .Interior.Color = bgColor
            .HorizontalAlignment = xlCenter
            .VerticalAlignment = xlCenter
        End With
        row = row + 1
    Next i
End Sub

' ========== InputOutput 類型檢測（數據內容判斷） ==========
Function DetectInputOutputTypeFromData(lines() As String, startLine As Long) As String
    ' 預設為 General 類型
    DetectInputOutputTypeFromData = "InputOutput_General"

    Dim i As Long
    Dim seqEndLine As Long
    seqEndLine = startLine + 50

    ' 找到序列結束行
    For i = startLine + 1 To UBound(lines)
        If InStr(lines(i), "SEQ.") > 0 And i > startLine Then
            seqEndLine = i - 1
            Exit For
        End If
    Next i

    ' 在序列範圍內搜索關鍵字
    For i = startLine To seqEndLine
        If i > UBound(lines) Then Exit For

        ' 檢查是否包含 Iinrms 參數
        If InStr(lines(i), "Iinrms Max") > 0 Then
            DetectInputOutputTypeFromData = "InputOutput_Iin"
            Exit Function
        End If

        ' 檢查是否包含 Pin 參數
        If InStr(lines(i), "Pin Max") > 0 Then
            DetectInputOutputTypeFromData = "InputOutput_Pin"
            Exit Function
        End If

        ' 檢查是否包含 Eff 參數
        If InStr(lines(i), "Eff Min") > 0 Or InStr(lines(i), "Eff.") > 0 Then
            DetectInputOutputTypeFromData = "InputOutput_Eff"
            Exit Function
        End If
    Next i
End Function

' ========== 第2部分：分佈圖生成功能 ==========

'   ? 圖表名稱 = 讀值名稱（例如："Vdc1"、"Tds"）
'   ? 自動智能匹配參數 Max/Min
'   ? Spec 線條智能顯示：
'       - 只有當讀值 ? Min 時才顯示綠線
'       - 只有當讀值 ? Max 時才顯示紅線
'       - 圖例永遠顯示 Spec 值
'   ? 左側完整參數表（Condition/Value）
'   ? 計算數據自動隱藏（A-E 欄）
'   ? 每個 SEQ 獨立區塊，互不干涉
'
' 使用方式：
'   1. 複製全部程式碼到 Excel VBA 編輯器（Alt+F11）
'   2. 執行 GenerateSEQDistributionCharts 函數
'   3. 選擇 TXT 測試報告檔案
'   4. 自動生成分佈圖
' ============================================================

' ========== 主控函數 ==========

