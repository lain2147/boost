' ========================================
' 分布圖功能 - 完整獨立版(直接貼上即可)
' 版本:2.2 完整版
' 最後更新:2025-12-08
' ========================================
'
' 【使用方式】
' 1. 全選此檔案內容(Ctrl+A)
' 2. 複製(Ctrl+C)
' 3. 打開 Excel VBA 編輯器(Alt+F11)
' 4. 在 Module 底部貼上(Ctrl+V)
' 5. 存檔(Ctrl+S)
' 6. 在主處理流程最後加入:
'    Call CreateDistributionChartsForAllSequences_New(allSequences, lines)
'
' 【重要】本版本包含所有必要函數,可獨立運行
' ========================================


' ========== 輔助函數:清理數值(移除 ?? 標記) ==========

Function CleanNumericValue_Dist(Value As String) As String
    ' 移除 ?? 標記和多餘空白
    CleanNumericValue_Dist = Replace(Value, "?", "")
    CleanNumericValue_Dist = Trim(CleanNumericValue_Dist)
End Function


' ========== 輔助函數:智能四捨五入 ==========

Function RoundByValueRange_Dist(Value As Double) As Double
    Dim absValue As Double
    absValue = Abs(Value)

    If absValue >= 1 Then
        RoundByValueRange_Dist = Round(Value, 2)
    Else
        Dim valueStr As String
        valueStr = CStr(Value)

        If InStr(valueStr, ".") = 0 Then
            RoundByValueRange_Dist = Value
            Exit Function
        End If

        Dim decimalPart As String
        decimalPart = Split(valueStr, ".")(1)

        If Len(decimalPart) <= 3 Then
            RoundByValueRange_Dist = Value
        Else
            RoundByValueRange_Dist = Round(Value, 3)
        End If
    End If
End Function


' ========== 輔助函數:排序 Collection ==========

Function SortCollection_Dist(coll As Collection) As Collection
    Dim sorted As New Collection

    If coll.Count = 0 Then
        Set SortCollection_Dist = sorted
        Exit Function
    End If

    Dim arr() As Double
    Dim i As Long, j As Long, temp As Double
    ReDim arr(1 To coll.Count)

    For i = 1 To coll.Count
        arr(i) = coll(i)
    Next i

    For i = 1 To UBound(arr) - 1
        For j = i + 1 To UBound(arr)
            If arr(i) > arr(j) Then
                temp = arr(i)
                arr(i) = arr(j)
                arr(j) = temp
            End If
        Next j
    Next i

    For i = 1 To UBound(arr)
        sorted.Add arr(i)
    Next i

    Set SortCollection_Dist = sorted
End Function


' ========== 輔助函數:收集讀值數據 ==========

Function CollectReadingValues_Dist(readData As Object, readingName As String) As Collection
    Dim values As New Collection
    Dim snKey As Variant

    For Each snKey In readData.Keys
        Dim Value As Variant
        Dim cleanValue As String

        On Error Resume Next
        Dim isDict As Boolean
        isDict = False
        If TypeName(readData(snKey)) = "Dictionary" Then
            isDict = True
        End If
        On Error GoTo 0

        If isDict Then
            If readData(snKey).Exists(readingName) Then
                Value = readData(snKey)(readingName)
                If Not IsEmpty(Value) And Value <> "" Then
                    cleanValue = CleanNumericValue_Dist(CStr(Value))
                    If IsNumeric(cleanValue) And cleanValue <> "" Then
                        values.Add CDbl(cleanValue)
                    End If
                End If
            End If
        Else
            Value = readData(snKey)
            If Not IsEmpty(Value) And Value <> "" Then
                cleanValue = CleanNumericValue_Dist(CStr(Value))
                If IsNumeric(cleanValue) And cleanValue <> "" Then
                    values.Add CDbl(cleanValue)
                End If
            End If
        End If
    Next snKey

    Set CollectReadingValues_Dist = values
End Function


' ========== 輔助函數:處理讀值 ==========

Function ProcessReadingValues_Dist(values As Collection) As Collection
    Dim processed As New Collection
    Dim uniqueDict As Object
    Set uniqueDict = CreateObject("Scripting.Dictionary")

    Dim Value As Variant
    For Each Value In values
        Dim rounded As Double
        rounded = RoundByValueRange_Dist(CDbl(Value))

        If Not uniqueDict.Exists(rounded) Then
            uniqueDict.Add rounded, True
            processed.Add rounded
        End If
    Next Value

    Set ProcessReadingValues_Dist = SortCollection_Dist(processed)
End Function


' ========== 輔助函數:計算頻率 ==========

Function CalculateFrequencyData_Dist(originalValues As Collection, uniqueValues As Collection) As Object
    Dim freqDict As Object
    Set freqDict = CreateObject("Scripting.Dictionary")

    Dim uniqueVal As Variant, origVal As Variant, Count As Long
    For Each uniqueVal In uniqueValues
        Count = 0
        For Each origVal In originalValues
            Dim roundedOrigVal As Double
            roundedOrigVal = RoundByValueRange_Dist(CDbl(origVal))
            If Abs(roundedOrigVal - CDbl(uniqueVal)) < 0.0001 Then
                Count = Count + 1
            End If
        Next origVal
        freqDict.Add uniqueVal, Count
    Next uniqueVal

    Set CalculateFrequencyData_Dist = freqDict
End Function


' ========== 輔助函數:參數匹配 ==========

Sub GetSpecForReading_Dist(readingName As String, params As Object, ByRef specMax As Variant, ByRef specMin As Variant)
    Dim baseName As String
    baseName = readingName
    Dim i As Integer

    For i = Len(baseName) To 1 Step -1
        If Not IsNumeric(Mid(baseName, i, 1)) Then
            baseName = Left(baseName, i)
            Exit For
        End If
    Next i

    If Right(baseName, 4) = "Read" Then
        baseName = Left(baseName, Len(baseName) - 4)
    End If

    Dim maxKeys As Collection
    Dim minKeys As Collection
    Set maxKeys = New Collection
    Set minKeys = New Collection

    Select Case baseName
        Case "Vdc", "VdcRead"
            maxKeys.Add "VdcMax"
            maxKeys.Add "Vdc Max"
            minKeys.Add "VdcMin"
            minKeys.Add "Vdc Min"
        Case "Vpp", "VppRead"
            maxKeys.Add "VppMax"
            maxKeys.Add "Vpp Max"
            minKeys.Add "VppMin"
            minKeys.Add "Vpp Min"
        Case "Vn", "VnRead"
            maxKeys.Add "VnMax"
            maxKeys.Add "Vn Max"
            minKeys.Add "VnMin"
            minKeys.Add "Vn Min"
        Case "Tds"
            maxKeys.Add "TdsMax"
            maxKeys.Add "Tds Max"
            minKeys.Add "TdsMin"
            minKeys.Add "Tds Min"
        Case "Tdl"
            maxKeys.Add "TdlMax"
            maxKeys.Add "Tdl Max"
            minKeys.Add "TdlMin"
            minKeys.Add "Tdl Min"
        Case "Pin"
            maxKeys.Add "PinMax"
            maxKeys.Add "Pin Max"
            minKeys.Add "PinMin"
            minKeys.Add "Pin Min"
        Case "Vs"
            maxKeys.Add "VsMax"
            maxKeys.Add "Vs Max"
            minKeys.Add "VsMin"
            minKeys.Add "Vs Min"
        Case "Reading"
            maxKeys.Add "ReadingMax"
            maxKeys.Add "Reading Max"
            minKeys.Add "ReadingMin"
            minKeys.Add "Reading Min"
        Case "Idc"
            maxKeys.Add "IinrmsMax"
            maxKeys.Add "Iinrms Max"
            maxKeys.Add "IdcMax"
            maxKeys.Add "Idc Max"
        Case "Eff"
            minKeys.Add "EffMin"
            minKeys.Add "Eff Min"
        Case "Vin", "VinRead"
            maxKeys.Add "VinMax"
            maxKeys.Add "Vin Max"
            minKeys.Add "VinMin"
            minKeys.Add "Vin Min"
        Case Else
            maxKeys.Add baseName & "Max"
            maxKeys.Add baseName & " Max"
            minKeys.Add baseName & "Min"
            minKeys.Add baseName & " Min"
    End Select

    Dim key As Variant
    For Each key In maxKeys
        If params.Exists(CStr(key)) Then
            specMax = params(CStr(key))
            Exit For
        End If
    Next key

    For Each key In minKeys
        If params.Exists(CStr(key)) Then
            specMin = params(CStr(key))
            Exit For
        End If
    Next key
End Sub


' ========== 核心函數:寫入數據表 ==========

Sub WriteDistributionDataToSheet_New(ws As Worksheet, _
                                      freqData As Object, _
                                      specMax As Variant, _
                                      specMin As Variant, _
                                      startRow As Long, _
                                      startCol As Long, _
                                      readingName As String)

    Dim allData As Object
    Set allData = CreateObject("Scripting.Dictionary")

    Dim key As Variant
    For Each key In freqData.Keys
        Dim valueLabel As String
        valueLabel = CStr(CDbl(key))
        allData.Add valueLabel, Array(CDbl(key), freqData(key), "normal")
    Next key

    If specMax <> "" And specMax <> "*" Then
        Dim maxLabel As String
        maxLabel = CStr(CDbl(specMax)) & "_MAX"

        Dim maxExists As Boolean
        maxExists = False
        For Each key In freqData.Keys
            If Abs(CDbl(key) - CDbl(specMax)) < 0.0001 Then
                maxExists = True
                Exit For
            End If
        Next key

        If Not maxExists Then
            allData.Add maxLabel, Array(CDbl(specMax), Empty, "max")
        End If
    End If

    If specMin <> "" And specMin <> "*" Then
        Dim minLabel As String
        minLabel = CStr(CDbl(specMin)) & "_Min"

        Dim minExists As Boolean
        minExists = False
        For Each key In freqData.Keys
            If Abs(CDbl(key) - CDbl(specMin)) < 0.0001 Then
                minExists = True
                Exit For
            End If
        Next key

        If Not minExists Then
            allData.Add minLabel, Array(CDbl(specMin), Empty, "min")
        End If
    End If

    Dim sortedLabels() As String
    Dim sortedValues() As Double
    ReDim sortedLabels(1 To allData.Count)
    ReDim sortedValues(1 To allData.Count)

    Dim idx As Long
    idx = 1
    For Each key In allData.Keys
        sortedLabels(idx) = CStr(key)
        sortedValues(idx) = allData(key)(0)
        idx = idx + 1
    Next key

    Dim i As Long, j As Long
    Dim tempLabel As String, tempValue As Double
    For i = 1 To UBound(sortedValues) - 1
        For j = i + 1 To UBound(sortedValues)
            If sortedValues(i) < sortedValues(j) Then
                tempLabel = sortedLabels(i)
                sortedLabels(i) = sortedLabels(j)
                sortedLabels(j) = tempLabel

                tempValue = sortedValues(i)
                sortedValues(i) = sortedValues(j)
                sortedValues(j) = tempValue
            End If
        Next j
    Next i

    ws.Cells(startRow, startCol).Value = readingName
    ws.Cells(startRow, startCol + 1).Value = "Frequency"

    With ws.Range(ws.Cells(startRow, startCol), ws.Cells(startRow, startCol + 1))
        .Font.Bold = True
        .Interior.Color = RGB(68, 114, 196)
        .Font.Color = RGB(255, 255, 255)
        .HorizontalAlignment = xlCenter
        .VerticalAlignment = xlCenter
        .Borders.LineStyle = xlContinuous
        .Borders.Weight = xlThin
    End With

    ws.Columns(startCol).ColumnWidth = 15
    ws.Columns(startCol + 1).ColumnWidth = 12

    Dim row As Long
    row = startRow + 1

    For i = 1 To UBound(sortedLabels)
        Dim dataLabel As String
        dataLabel = sortedLabels(i)

        Dim dataInfo As Variant
        dataInfo = allData(dataLabel)

        Dim dataType As String
        dataType = dataInfo(2)

        ws.Cells(row, startCol).Value = dataLabel

        If IsEmpty(dataInfo(1)) Then
            ws.Cells(row, startCol + 1).Value = ""
        Else
            ws.Cells(row, startCol + 1).Value = dataInfo(1)
        End If

        Select Case dataType
            Case "max"
                ws.Cells(row, startCol).Font.Color = RGB(255, 0, 0)
                ws.Cells(row, startCol).Font.Bold = True
                ws.Cells(row, startCol).Interior.Color = RGB(255, 230, 230)
            Case "min"
                ws.Cells(row, startCol).Font.Color = RGB(0, 176, 80)
                ws.Cells(row, startCol).Font.Bold = True
                ws.Cells(row, startCol).Interior.Color = RGB(230, 255, 230)
            Case "normal"
                ws.Cells(row, startCol).Font.Color = RGB(0, 0, 0)
                ws.Cells(row, startCol + 1).Font.Color = RGB(0, 0, 0)
        End Select

        With ws.Range(ws.Cells(row, startCol), ws.Cells(row, startCol + 1))
            .HorizontalAlignment = xlCenter
            .VerticalAlignment = xlCenter
            .Borders.LineStyle = xlContinuous
            .Borders.Weight = xlThin
        End With

        row = row + 1
    Next i
End Sub


' ========== 核心函數:配置圖表 ==========

Sub ConfigureDistributionChart_New(ch As Chart, _
                                    ws As Worksheet, _
                                    readingName As String, _
                                    dataStartRow As Long, _
                                    dataStartCol As Long, _
                                    specMax As Variant, _
                                    specMin As Variant)

    On Error GoTo ErrorHandler

    Dim lastRow As Long
    lastRow = dataStartRow

    Dim i As Long
    For i = dataStartRow + 1 To dataStartRow + 200
        If ws.Cells(i, dataStartCol).Value = "" Then
            lastRow = i - 1
            Exit For
        End If
        lastRow = i
    Next i

    If lastRow <= dataStartRow Then Exit Sub

    Dim labelRng As Range
    Dim freqRng As Range

    Set labelRng = ws.Range(ws.Cells(dataStartRow + 1, dataStartCol), ws.Cells(lastRow, dataStartCol))
    Set freqRng = ws.Range(ws.Cells(dataStartRow + 1, dataStartCol + 1), ws.Cells(lastRow, dataStartCol + 1))

    Do While ch.SeriesCollection.Count > 0
        ch.SeriesCollection(1).Delete
    Loop

    Dim s As Series
    Set s = ch.SeriesCollection.NewSeries
    s.Name = "Frequency"
    s.Values = freqRng
    s.XValues = labelRng
    s.ChartType = xlColumnClustered
    s.AxisGroup = xlPrimary
    s.Format.Fill.ForeColor.RGB = RGB(68, 114, 196)

    Dim trendValues() As Variant
    Dim trendLabels() As Variant
    Dim trendCount As Long
    trendCount = 0

    For i = dataStartRow + 1 To lastRow
        Dim cellValue As String
        cellValue = CStr(ws.Cells(i, dataStartCol).Value)
        If InStr(cellValue, "_MAX") = 0 And InStr(cellValue, "_Min") = 0 Then
            If ws.Cells(i, dataStartCol + 1).Value <> "" Then
                trendCount = trendCount + 1
            End If
        End If
    Next i

    If trendCount > 0 Then
        ReDim trendValues(1 To trendCount)
        ReDim trendLabels(1 To trendCount)

        Dim trendIdx As Long
        trendIdx = 1
        For i = dataStartRow + 1 To lastRow
            cellValue = CStr(ws.Cells(i, dataStartCol).Value)
            If InStr(cellValue, "_MAX") = 0 And InStr(cellValue, "_Min") = 0 Then
                If ws.Cells(i, dataStartCol + 1).Value <> "" Then
                    trendLabels(trendIdx) = ws.Cells(i, dataStartCol).Value
                    trendValues(trendIdx) = ws.Cells(i, dataStartCol + 1).Value
                    trendIdx = trendIdx + 1
                End If
            End If
        Next i

        Set s = ch.SeriesCollection.NewSeries
        s.Name = "Trend"
        s.XValues = trendLabels
        s.Values = trendValues
        s.ChartType = xlLine
        s.AxisGroup = xlPrimary
        With s.Format.Line
            .Weight = 2
            .ForeColor.RGB = RGB(237, 125, 49)
        End With
        s.MarkerStyle = xlMarkerStyleCircle
        s.MarkerSize = 5
    End If

    ch.HasTitle = True
    ch.ChartTitle.Text = readingName & " 分佈圖"
    With ch.ChartTitle.Font
        .Size = 14
        .Bold = True
        .Color = RGB(68, 114, 196)
    End With

    With ch.Axes(xlCategory)
        .HasTitle = True
        .AxisTitle.Text = "測試值 (Value)"
        .AxisTitle.Font.Size = 11
        .TickLabelSpacing = 1
        .TickMarkSpacing = 1
        .TickLabels.Orientation = 45
    End With

    With ch.Axes(xlValue, xlPrimary)
        .HasTitle = True
        .AxisTitle.Text = "出現次數 (Frequency)"
        .AxisTitle.Font.Size = 11
        .MinimumScale = 0
    End With

    ch.HasLegend = True
    With ch.Legend
        .Position = xlLegendPositionBottom
        .Font.Size = 10
    End With

    ch.PlotArea.Format.Fill.Visible = msoTrue
    ch.PlotArea.Format.Fill.ForeColor.RGB = RGB(255, 255, 255)

    ch.ChartArea.Format.Fill.Visible = msoTrue
    ch.ChartArea.Format.Fill.ForeColor.RGB = RGB(242, 242, 242)

    Exit Sub

ErrorHandler:
    Debug.Print "圖表配置錯誤:" & Err.Description
End Sub


' ========== 核心函數:創建單個分布圖 ==========

Function CreateSingleDistributionChart_New(ws As Worksheet, _
                                           readingName As String, _
                                           readData As Object, _
                                           blockRow As Long, _
                                           blockCol As Long, _
                                           params As Object) As Long

    Dim readingValues As Collection
    Set readingValues = CollectReadingValues_Dist(readData, readingName)

    If readingValues.Count = 0 Then
        CreateSingleDistributionChart_New = 0
        Exit Function
    End If

    Dim specMax As Variant, specMin As Variant
    specMax = ""
    specMin = ""
    Call GetSpecForReading_Dist(readingName, params, specMax, specMin)

    Dim processedData As Collection
    Set processedData = ProcessReadingValues_Dist(readingValues)

    If processedData.Count = 0 Then
        CreateSingleDistributionChart_New = 0
        Exit Function
    End If

    Dim freqData As Object
    Set freqData = CalculateFrequencyData_Dist(readingValues, processedData)

    Call WriteDistributionDataToSheet_New(ws, freqData, specMax, specMin, blockRow, blockCol, readingName)

    Dim dataTableHeight As Long
    dataTableHeight = freqData.Count + 1

    If specMax <> "" And specMax <> "*" Then
        Dim maxExists As Boolean
        maxExists = False
        Dim key As Variant
        For Each key In freqData.Keys
            If Abs(CDbl(key) - CDbl(specMax)) < 0.0001 Then
                maxExists = True
                Exit For
            End If
        Next key
        If Not maxExists Then dataTableHeight = dataTableHeight + 1
    End If

    If specMin <> "" And specMin <> "*" Then
        Dim minExists As Boolean
        minExists = False
        For Each key In freqData.Keys
            If Abs(CDbl(key) - CDbl(specMin)) < 0.0001 Then
                minExists = True
                Exit For
            End If
        Next key
        If Not minExists Then dataTableHeight = dataTableHeight + 1
    End If

    Dim chartObj As ChartObject
    On Error Resume Next

    Set chartObj = ws.ChartObjects.Add( _
        Left:=ws.Cells(blockRow, blockCol + 3).Left, _
        Top:=ws.Cells(blockRow, blockCol + 3).Top, _
        Width:=500, _
        Height:=320)

    If Err.Number <> 0 Then
        Err.Clear
        CreateSingleDistributionChart_New = dataTableHeight
        Exit Function
    End If
    On Error GoTo 0

    Call ConfigureDistributionChart_New(chartObj.Chart, ws, readingName, blockRow, blockCol, specMax, specMin)

    Dim chartRowHeight As Long
    chartRowHeight = 20

    If chartRowHeight > dataTableHeight Then
        CreateSingleDistributionChart_New = chartRowHeight
    Else
        CreateSingleDistributionChart_New = dataTableHeight
    End If
End Function


' ========== 各測試類型分布圖函數 ==========

Function CreateLoadRegulationDistributionCharts_New(ws As Worksheet, seqInfo As Object, lines() As String, startCol As Long, seqColor As Long) As Long
    Dim params As Object
    Set params = ExtractLoadRegulationParams(lines, seqInfo("startLine"), seqInfo("loadName"))

    Dim readData As Object
    Set readData = ExtractAllLoadRegulationReads(lines, seqInfo("title"))

    If readData.Count = 0 Then
        CreateLoadRegulationDistributionCharts_New = 0
        Exit Function
    End If

    ws.Cells(1, startCol).Value = seqInfo("title")
    ws.Cells(1, startCol).Font.Bold = True
    ws.Cells(1, startCol).Font.Size = 14
    ws.Cells(1, startCol).Interior.Color = seqColor
    ws.Cells(1, startCol).Font.Color = RGB(255, 255, 255)
    ws.Range(ws.Cells(1, startCol), ws.Cells(1, startCol + 9)).Merge
    ws.Cells(1, startCol).HorizontalAlignment = xlCenter
    ws.Cells(1, startCol).VerticalAlignment = xlCenter

    Dim currentRow As Long
    currentRow = 3

    Dim readingNames As Variant
    readingNames = Array("VdcRead1", "VppRead1", "VdcRead2", "VppRead2", "VdcRead3", "VppRead3", "VnRead1", "VnRead2", "VnRead3", "dV21", "dV31")

    Dim i As Integer
    For i = LBound(readingNames) To UBound(readingNames)
        Dim blockHeight As Long
        blockHeight = CreateSingleDistributionChart_New(ws, CStr(readingNames(i)), readData, currentRow, startCol, params)
        If blockHeight > 0 Then currentRow = currentRow + blockHeight + 2
    Next i

    CreateLoadRegulationDistributionCharts_New = 10
End Function


Function CreateTurnOnDistributionCharts_New(ws As Worksheet, seqInfo As Object, lines() As String, startCol As Long, seqColor As Long) As Long
    Dim params As Object
    Set params = ExtractTurnOnParams(lines, seqInfo("startLine"), seqInfo("loadName"))

    Dim readData As Object
    Set readData = ExtractAllTonReads(lines, seqInfo("title"))

    If readData.Count = 0 Then
        CreateTurnOnDistributionCharts_New = 0
        Exit Function
    End If

    ws.Cells(1, startCol).Value = seqInfo("title")
    ws.Cells(1, startCol).Font.Bold = True
    ws.Cells(1, startCol).Font.Size = 14
    ws.Cells(1, startCol).Interior.Color = seqColor
    ws.Cells(1, startCol).Font.Color = RGB(255, 255, 255)
    ws.Range(ws.Cells(1, startCol), ws.Cells(1, startCol + 9)).Merge
    ws.Cells(1, startCol).HorizontalAlignment = xlCenter

    Dim blockHeight As Long
    blockHeight = CreateSingleDistributionChart_New(ws, "Reading", readData, 3, startCol, params)

    CreateTurnOnDistributionCharts_New = 10
End Function


Function CreateHoldUpDistributionCharts_New(ws As Worksheet, seqInfo As Object, lines() As String, startCol As Long, seqColor As Long) As Long
    Dim params As Object
    Set params = ExtractHoldUpParams(lines, seqInfo("startLine"), seqInfo("loadName"))

    Dim readData As Object
    Set readData = ExtractAllHoldUpReads(lines, seqInfo("title"))

    If readData.Count = 0 Then
        CreateHoldUpDistributionCharts_New = 0
        Exit Function
    End If

    ws.Cells(1, startCol).Value = seqInfo("title")
    ws.Cells(1, startCol).Font.Bold = True
    ws.Cells(1, startCol).Font.Size = 14
    ws.Cells(1, startCol).Interior.Color = seqColor
    ws.Cells(1, startCol).Font.Color = RGB(255, 255, 255)
    ws.Range(ws.Cells(1, startCol), ws.Cells(1, startCol + 9)).Merge
    ws.Cells(1, startCol).HorizontalAlignment = xlCenter

    Dim currentRow As Long
    currentRow = 3

    Dim blockHeight As Long
    blockHeight = CreateSingleDistributionChart_New(ws, "Tds", readData, currentRow, startCol, params)
    If blockHeight > 0 Then currentRow = currentRow + blockHeight + 2

    blockHeight = CreateSingleDistributionChart_New(ws, "Tdl", readData, currentRow, startCol, params)

    CreateHoldUpDistributionCharts_New = 10
End Function


Function CreateCombineDistributionCharts_New(ws As Worksheet, seqInfo As Object, lines() As String, startCol As Long, seqColor As Long) As Long
    Dim params As Object
    Set params = ExtractCombineParams(lines, seqInfo("startLine"), seqInfo("loadName"))

    Dim readData As Object
    Set readData = ExtractAllCombineReads(lines, seqInfo("startLine"))

    If readData.Count = 0 Then
        CreateCombineDistributionCharts_New = 0
        Exit Function
    End If

    ws.Cells(1, startCol).Value = seqInfo("title")
    ws.Cells(1, startCol).Font.Bold = True
    ws.Cells(1, startCol).Font.Size = 14
    ws.Cells(1, startCol).Interior.Color = seqColor
    ws.Cells(1, startCol).Font.Color = RGB(255, 255, 255)
    ws.Range(ws.Cells(1, startCol), ws.Cells(1, startCol + 9)).Merge
    ws.Cells(1, startCol).HorizontalAlignment = xlCenter

    Dim currentRow As Long
    currentRow = 3

    Dim readingNames As Variant
    readingNames = Array("Vdc1", "Vpp1", "Vdc2", "Vpp2", "Vdc3", "Vpp3")

    Dim i As Integer
    For i = LBound(readingNames) To UBound(readingNames)
        Dim blockHeight As Long
        blockHeight = CreateSingleDistributionChart_New(ws, CStr(readingNames(i)), readData, currentRow, startCol, params)
        If blockHeight > 0 Then currentRow = currentRow + blockHeight + 2
    Next i

    CreateCombineDistributionCharts_New = 10
End Function


Function CreateShortCircuitDistributionCharts_New(ws As Worksheet, seqInfo As Object, lines() As String, startCol As Long, seqColor As Long) As Long
    Dim params As Object
    Set params = ExtractShortCircuitParams(lines, seqInfo("startLine"), seqInfo("loadName"))

    Dim readData As Object
    Set readData = ExtractAllPinReads(lines, seqInfo("title"))

    If readData.Count = 0 Then
        CreateShortCircuitDistributionCharts_New = 0
        Exit Function
    End If

    ws.Cells(1, startCol).Value = seqInfo("title")
    ws.Cells(1, startCol).Font.Bold = True
    ws.Cells(1, startCol).Font.Size = 14
    ws.Cells(1, startCol).Interior.Color = seqColor
    ws.Cells(1, startCol).Font.Color = RGB(255, 255, 255)
    ws.Range(ws.Cells(1, startCol), ws.Cells(1, startCol + 9)).Merge
    ws.Cells(1, startCol).HorizontalAlignment = xlCenter

    Dim blockHeight As Long
    blockHeight = CreateSingleDistributionChart_New(ws, "Pin", readData, 3, startCol, params)

    CreateShortCircuitDistributionCharts_New = 10
End Function


Function CreateOLPDistributionCharts_New(ws As Worksheet, seqInfo As Object, lines() As String, startCol As Long, seqColor As Long) As Long
    Dim params As Object
    Set params = ExtractOLPParams(lines, seqInfo("startLine"), seqInfo("loadName"))

    Dim readData As Object
    Set readData = ExtractAllOLPReads(lines, seqInfo("title"))

    If readData.Count = 0 Then
        CreateOLPDistributionCharts_New = 0
        Exit Function
    End If

    ws.Cells(1, startCol).Value = seqInfo("title")
    ws.Cells(1, startCol).Font.Bold = True
    ws.Cells(1, startCol).Font.Size = 14
    ws.Cells(1, startCol).Interior.Color = seqColor
    ws.Cells(1, startCol).Font.Color = RGB(255, 255, 255)
    ws.Range(ws.Cells(1, startCol), ws.Cells(1, startCol + 9)).Merge
    ws.Cells(1, startCol).HorizontalAlignment = xlCenter

    Dim blockHeight As Long
    blockHeight = CreateSingleDistributionChart_New(ws, "Reading", readData, 3, startCol, params)

    CreateOLPDistributionCharts_New = 10
End Function


Function CreateDynamicDistributionCharts_New(ws As Worksheet, seqInfo As Object, lines() As String, startCol As Long, seqColor As Long) As Long
    Dim params As Object
    Set params = ExtractDynamicParams(lines, seqInfo("startLine"), seqInfo("loadName"))

    Dim readData As Object
    Set readData = ExtractAllDynamicReads(lines, seqInfo("title"))

    If readData.Count = 0 Then
        CreateDynamicDistributionCharts_New = 0
        Exit Function
    End If

    ws.Cells(1, startCol).Value = seqInfo("title")
    ws.Cells(1, startCol).Font.Bold = True
    ws.Cells(1, startCol).Font.Size = 14
    ws.Cells(1, startCol).Interior.Color = seqColor
    ws.Cells(1, startCol).Font.Color = RGB(255, 255, 255)
    ws.Range(ws.Cells(1, startCol), ws.Cells(1, startCol + 9)).Merge
    ws.Cells(1, startCol).HorizontalAlignment = xlCenter

    Dim currentRow As Long
    currentRow = 3

    Dim blockHeight As Long
    blockHeight = CreateSingleDistributionChart_New(ws, "Vs1", readData, currentRow, startCol, params)
    If blockHeight > 0 Then currentRow = currentRow + blockHeight + 2

    blockHeight = CreateSingleDistributionChart_New(ws, "Vs2", readData, currentRow, startCol, params)

    CreateDynamicDistributionCharts_New = 10
End Function


Function CreateInputOutputDistributionCharts_New(ws As Worksheet, seqInfo As Object, lines() As String, startCol As Long, seqColor As Long) As Long
    Dim params As Object
    Dim seqType As String
    seqType = seqInfo("type")

    Set params = ExtractInputOutputParams(lines, seqInfo("startLine"), seqInfo("loadName"), seqType)

    Dim readData As Object
    Set readData = ExtractAllInputOutputReads(lines, seqInfo("title"), seqType)

    If readData.Count = 0 Then
        CreateInputOutputDistributionCharts_New = 0
        Exit Function
    End If

    ws.Cells(1, startCol).Value = seqInfo("title")
    ws.Cells(1, startCol).Font.Bold = True
    ws.Cells(1, startCol).Font.Size = 14
    ws.Cells(1, startCol).Interior.Color = seqColor
    ws.Cells(1, startCol).Font.Color = RGB(255, 255, 255)
    ws.Range(ws.Cells(1, startCol), ws.Cells(1, startCol + 9)).Merge
    ws.Cells(1, startCol).HorizontalAlignment = xlCenter

    Dim currentRow As Long
    currentRow = 3

    Dim readingNames As Collection
    Set readingNames = New Collection

    Select Case seqType
        Case "InputOutput_Iin", "InputOutput_Pin", "InputOutput_Eff"
            readingNames.Add "Idc"
            readingNames.Add "Iin"
            readingNames.Add "Pin"
            readingNames.Add "Eff"
        Case "InputOutput_General"
            readingNames.Add "VinRead"
            readingNames.Add "Idc"
            readingNames.Add "Iin"
            readingNames.Add "Pin"
            readingNames.Add "Eff"
    End Select

    Dim readingName As Variant
    For Each readingName In readingNames
        Dim blockHeight As Long
        blockHeight = CreateSingleDistributionChart_New(ws, CStr(readingName), readData, currentRow, startCol, params)
        If blockHeight > 0 Then currentRow = currentRow + blockHeight + 2
    Next readingName

    CreateInputOutputDistributionCharts_New = 10
End Function


' ========== 主控函數 ==========

Sub CreateDistributionChartsForAllSequences_New(allSequences As Collection, lines() As String)
    Dim ws As Worksheet
    On Error Resume Next
    Set ws = ThisWorkbook.Worksheets("分佈圖")
    On Error GoTo 0

    If ws Is Nothing Then
        Set ws = ThisWorkbook.Worksheets.Add
        ws.Name = "分佈圖"
    Else
        ws.Cells.Clear
        On Error Resume Next
        ws.ChartObjects.Delete
        On Error GoTo 0
    End If

    Dim seqColors As Object
    Set seqColors = CreateObject("Scripting.Dictionary")
    seqColors.Add "TurnOn", RGB(68, 114, 196)
    seqColors.Add "HoldUp", RGB(237, 125, 49)
    seqColors.Add "ShortCircuit", RGB(165, 165, 165)
    seqColors.Add "Combine", RGB(255, 192, 0)
    seqColors.Add "OLP", RGB(91, 155, 213)
    seqColors.Add "Dynamic", RGB(112, 48, 160)
    seqColors.Add "LoadRegulation", RGB(0, 176, 80)
    seqColors.Add "InputOutput_Iin", RGB(255, 0, 0)
    seqColors.Add "InputOutput_Pin", RGB(192, 0, 0)
    seqColors.Add "InputOutput_Eff", RGB(146, 208, 80)
    seqColors.Add "InputOutput_General", RGB(0, 176, 240)

    Dim currentCol As Long
    currentCol = 1

    Dim seqInfo As Object
    For Each seqInfo In allSequences
        Dim testType As String
        testType = seqInfo("type")

        Dim seqColor As Long
        If seqColors.Exists(testType) Then
            seqColor = seqColors(testType)
        Else
            seqColor = RGB(100, 100, 100)
        End If

        Dim colsUsed As Long
        colsUsed = 0

        Select Case testType
            Case "TurnOn"
                colsUsed = CreateTurnOnDistributionCharts_New(ws, seqInfo, lines, currentCol, seqColor)
            Case "HoldUp"
                colsUsed = CreateHoldUpDistributionCharts_New(ws, seqInfo, lines, currentCol, seqColor)
            Case "ShortCircuit"
                colsUsed = CreateShortCircuitDistributionCharts_New(ws, seqInfo, lines, currentCol, seqColor)
            Case "Combine"
                colsUsed = CreateCombineDistributionCharts_New(ws, seqInfo, lines, currentCol, seqColor)
            Case "OLP"
                colsUsed = CreateOLPDistributionCharts_New(ws, seqInfo, lines, currentCol, seqColor)
            Case "Dynamic"
                colsUsed = CreateDynamicDistributionCharts_New(ws, seqInfo, lines, currentCol, seqColor)
            Case "LoadRegulation"
                colsUsed = CreateLoadRegulationDistributionCharts_New(ws, seqInfo, lines, currentCol, seqColor)
            Case "InputOutput_Iin", "InputOutput_Pin", "InputOutput_Eff", "InputOutput_General"
                colsUsed = CreateInputOutputDistributionCharts_New(ws, seqInfo, lines, currentCol, seqColor)
        End Select

        If colsUsed > 0 Then
            currentCol = currentCol + colsUsed + 1
        End If
    Next seqInfo

    ws.Columns.AutoFit
    ws.Activate

    MsgBox "分佈圖生成完成!共處理 " & allSequences.Count & " 個測試序列", vbInformation
End Sub


' ========================================
' 使用說明
' ========================================
'
' 【整合步驟】
' 1. 在主處理流程最後加入:
'    Call CreateDistributionChartsForAllSequences_New(allSequences, lines)
'
' 【注意事項】
' - 本版本所有輔助函數都加上 _Dist 後綴,避免與主程式衝突
' - 需要主程式提供 Extract 相關函數(參數提取、讀值提取)
'
' ========================================
