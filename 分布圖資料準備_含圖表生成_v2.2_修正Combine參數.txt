' ======================================================
' 分布圖資料準備與圖表生成模組
' 功能：在多檔案處理完成後，建立 Distribution Data 工作表
'      從第一頁複製 SEQ 標題和參數，自動讀取測試數據並計算頻率分布
'      自動生成分布圖（柱狀圖 + 折線圖 + Spec Max/Min 線）
' 版本：2.2
' 日期：2025-12-10
' 更新：修正 Combine 測試參數讀取，根據讀值索引正確對應 Value-1/2/3
' ======================================================

' ------------------------------------------------------
' 函數：RoundByValueRange
' 功能：智能四捨五入（根據數值大小決定保留位數）
' ------------------------------------------------------
Function RoundByValueRange(val As Double) As Double
    On Error Resume Next
    Dim absValue As Double
    absValue = Abs(val)

    If absValue >= 1 Then
        RoundByValueRange = Round(val, 2)
        Exit Function
    End If

    Dim valStr As String
    valStr = CStr(val)

    If InStr(valStr, ".") = 0 Then
        RoundByValueRange = val
        Exit Function
    End If

    Dim decimalPart As String
    decimalPart = Split(valStr, ".")(1)

    If Len(decimalPart) <= 3 Then
        RoundByValueRange = val
    Else
        RoundByValueRange = Round(val, 3)
    End If
End Function

' ------------------------------------------------------
' 函數：CleanNumericValue
' 功能：清除數值中的 ?? 標記
' ------------------------------------------------------
Function CleanNumericValue(val As Variant) As String
    On Error Resume Next
    Dim strVal As String
    strVal = CStr(val)
    strVal = Replace(strVal, "?", "")
    strVal = Trim(strVal)
    CleanNumericValue = strVal
End Function

' ------------------------------------------------------
' 函數：ReadTestDataFromSheet
' 功能：從工作表讀取測試數據
' ------------------------------------------------------
Function ReadTestDataFromSheet(ws As Worksheet, seqStartCol As Long, readingColIndex As Long) As Collection
    On Error Resume Next

    Dim dataCollection As Collection
    Set dataCollection = New Collection

    Dim snRow As Long
    Dim i As Long
    Dim cellValue As Variant

    snRow = 0
    For i = 3 To 50
        cellValue = ws.Cells(i, seqStartCol).Value
        If cellValue = "S/N" Then
            snRow = i
            Exit For
        End If
    Next i

    If snRow = 0 Then
        Set ReadTestDataFromSheet = dataCollection
        Exit Function
    End If

    Dim readingCol As Long
    readingCol = seqStartCol + 1 + readingColIndex

    Dim currentRow As Long
    currentRow = snRow + 1

    Do While currentRow < snRow + 500
        Dim snValue As Variant
        snValue = ws.Cells(currentRow, seqStartCol).Value

        If snValue = "Maximum" Or snValue = "Minimum" Or snValue = "" Then
            Exit Do
        End If

        cellValue = ws.Cells(currentRow, readingCol).Value

        Dim cleanedValue As String
        cleanedValue = CleanNumericValue(cellValue)

        If IsNumeric(cleanedValue) And cleanedValue <> "" Then
            Dim numValue As Double
            numValue = CDbl(cleanedValue)
            dataCollection.Add numValue
        End If

        currentRow = currentRow + 1
    Loop

    Set ReadTestDataFromSheet = dataCollection
End Function

' ------------------------------------------------------
' 函數：CalculateFrequencyDistribution
' 功能：計算頻率分布（使用智能四捨五入）
' ------------------------------------------------------
Function CalculateFrequencyDistribution(values As Collection) As Object
    On Error Resume Next

    Dim freqDict As Object
    Set freqDict = CreateObject("Scripting.Dictionary")

    Dim val As Variant
    For Each val In values
        Dim roundedVal As Double
        roundedVal = RoundByValueRange(CDbl(val))

        Dim keyStr As String
        keyStr = CStr(roundedVal)

        If freqDict.exists(keyStr) Then
            freqDict(keyStr) = freqDict(keyStr) + 1
        Else
            freqDict.Add keyStr, 1
        End If
    Next val

    Dim keys() As String
    Dim keyCount As Long
    keyCount = freqDict.Count

    If keyCount = 0 Then
        Set CalculateFrequencyDistribution = freqDict
        Exit Function
    End If

    ReDim keys(0 To keyCount - 1)
    Dim i As Long
    i = 0
    For Each val In freqDict.keys
        keys(i) = val
        i = i + 1
    Next val

    Dim j As Long
    Dim temp As String
    For i = 0 To keyCount - 2
        For j = i + 1 To keyCount - 1
            If CDbl(keys(i)) > CDbl(keys(j)) Then
                temp = keys(i)
                keys(i) = keys(j)
                keys(j) = temp
            End If
        Next j
    Next i

    Dim sortedDict As Object
    Set sortedDict = CreateObject("Scripting.Dictionary")

    For i = 0 To keyCount - 1
        sortedDict.Add keys(i), freqDict(keys(i))
    Next i

    Set CalculateFrequencyDistribution = sortedDict
End Function

' ------------------------------------------------------
' 函數：GetSpecMaxMinForCombine
' 功能：從 Combine 測試的參數表中提取對應讀值的 Spec Max/Min
' 參數：
'   sourceWs - 來源工作表
'   seqStartCol - SEQ 起始欄位
'   readingName - 讀值名稱（例如 "12V_Vdc-2 RD"）
'   readingColIndex - 讀值欄位索引（0-5）
'   paramRows - 參數行數
' 返回：Array(SpecMax, SpecMin)
' 說明：
'   - Combine 測試每個 Value 組佔 2 欄
'   - readingColIndex 0,1 → Value-1 (col+1)
'   - readingColIndex 2,3 → Value-2 (col+3)
'   - readingColIndex 4,5 → Value-3 (col+5)
' ------------------------------------------------------
Function GetSpecMaxMinForCombine(sourceWs As Worksheet, seqStartCol As Long, _
                                readingName As String, readingColIndex As Long, _
                                paramRows As Long) As Variant
    On Error Resume Next

    Dim specMax As Variant
    Dim specMin As Variant
    Dim i As Long
    Dim conditionValue As String
    Dim valueCell As Variant
    Dim isVdc As Boolean
    Dim isVpp As Boolean
    Dim valueCol As Long

    specMax = Empty
    specMin = Empty

    ' 判斷讀值類型（Vdc 或 Vpp）
    isVdc = (InStr(1, readingName, "Vdc", vbTextCompare) > 0)
    isVpp = (InStr(1, readingName, "Vpp", vbTextCompare) > 0)

    ' 根據 readingColIndex 計算對應的 Value 欄位
    ' readingColIndex: 0,1 → Value-1 (col+1)
    '                  2,3 → Value-2 (col+3)
    '                  4,5 → Value-3 (col+5)
    Select Case readingColIndex
        Case 0, 1  ' Vdc-1, Vpp-1
            valueCol = seqStartCol + 1
        Case 2, 3  ' Vdc-2, Vpp-2
            valueCol = seqStartCol + 3
        Case 4, 5  ' Vdc-3, Vpp-3
            valueCol = seqStartCol + 5
        Case Else
            valueCol = seqStartCol + 1  ' 預設使用 Value-1
    End Select

    ' 掃描參數表（從第 3 行開始，共 paramRows 行）
    For i = 1 To paramRows
        conditionValue = Trim(CStr(sourceWs.Cells(2 + i, seqStartCol).Value))

        ' Vdc 讀值：查找 Vdc Max 和 Vdc Min（通用參數，跨所有欄）
        If isVdc Then
            ' 檢查 Vdc Max
            If InStr(1, conditionValue, "Vdc", vbTextCompare) > 0 And _
               InStr(1, conditionValue, "Max", vbTextCompare) > 0 Then
                ' 通用參數值在 seqStartCol+1 欄位（跨所有 Value 欄合併）
                valueCell = sourceWs.Cells(2 + i, seqStartCol + 1).Value
                If IsNumeric(valueCell) Then
                    specMax = CDbl(valueCell)
                End If
            End If

            ' 檢查 Vdc Min
            If InStr(1, conditionValue, "Vdc", vbTextCompare) > 0 And _
               InStr(1, conditionValue, "Min", vbTextCompare) > 0 Then
                valueCell = sourceWs.Cells(2 + i, seqStartCol + 1).Value
                If IsNumeric(valueCell) Then
                    specMin = CDbl(valueCell)
                End If
            End If
        End If

        ' Vpp 讀值：查找 Vpp Max（通用參數，跨所有欄）
        If isVpp Then
            If InStr(1, conditionValue, "Vpp", vbTextCompare) > 0 And _
               InStr(1, conditionValue, "Max", vbTextCompare) > 0 Then
                valueCell = sourceWs.Cells(2 + i, seqStartCol + 1).Value
                If IsNumeric(valueCell) Then
                    specMax = CDbl(valueCell)
                End If
            End If
        End If
    Next i

    GetSpecMaxMinForCombine = Array(specMax, specMin)
End Function

' ------------------------------------------------------
' 函數：GetSpecMaxMin
' 功能：從參數表中提取 Spec Max 和 Spec Min 值
' ------------------------------------------------------
Function GetSpecMaxMin(sourceWs As Worksheet, seqStartCol As Long, paramRows As Long, _
                      testType As String, readingName As String, _
                      readingColIndex As Long) As Variant
    On Error Resume Next

    ' Combine 測試使用特殊邏輯
    If testType = "Combine" Then
        GetSpecMaxMin = GetSpecMaxMinForCombine(sourceWs, seqStartCol, readingName, readingColIndex, paramRows)
        Exit Function
    End If

    ' 一般測試類型的邏輯
    Dim specMax As Variant
    Dim specMin As Variant
    Dim i As Long
    Dim conditionValue As String
    Dim valueCell As Variant

    specMax = Empty
    specMin = Empty

    For i = 1 To paramRows
        conditionValue = Trim(CStr(sourceWs.Cells(2 + i, seqStartCol).Value))

        If InStr(1, conditionValue, "Spec", vbTextCompare) > 0 And _
           InStr(1, conditionValue, "Max", vbTextCompare) > 0 Then
            valueCell = sourceWs.Cells(2 + i, seqStartCol + 1).Value
            If IsNumeric(valueCell) Then
                specMax = CDbl(valueCell)
            End If
        End If

        If InStr(1, conditionValue, "Spec", vbTextCompare) > 0 And _
           InStr(1, conditionValue, "Min", vbTextCompare) > 0 Then
            valueCell = sourceWs.Cells(2 + i, seqStartCol + 1).Value
            If IsNumeric(valueCell) Then
                specMin = CDbl(valueCell)
            End If
        End If
    Next i

    GetSpecMaxMin = Array(specMax, specMin)
End Function

' ------------------------------------------------------
' 函數：CreateDistributionChart
' 功能：建立分布圖（柱狀圖 + 折線圖 + Spec 線）
' ------------------------------------------------------
Function CreateDistributionChart(distWs As Worksheet, readingName As String, _
                                dataStartRow As Long, dataEndRow As Long, _
                                dataCol As Long, freqCol As Long, _
                                chartTopRow As Long, chartLeftCol As Long, _
                                chartHeight As Double, _
                                specMax As Variant, specMin As Variant) As Chart
    On Error Resume Next

    Dim chartObj As ChartObject
    Dim cht As Chart
    Dim dataRange As Range
    Dim freqRange As Range
    Dim avgValue As Double
    Dim maxFreq As Long
    Dim i As Long

    Dim chartLeft As Double
    Dim chartTop As Double
    Dim chartWidth As Double

    chartLeft = distWs.Cells(chartTopRow, chartLeftCol).Left
    chartTop = distWs.Cells(chartTopRow, chartLeftCol).Top
    chartWidth = 480

    Set chartObj = distWs.ChartObjects.Add(chartLeft, chartTop, chartWidth, chartHeight)
    Set cht = chartObj.Chart

    cht.ChartType = xlColumnClustered

    Do While cht.SeriesCollection.Count > 0
        cht.SeriesCollection(1).Delete
    Loop

    Set freqRange = distWs.Range(distWs.Cells(dataStartRow, freqCol), distWs.Cells(dataEndRow, freqCol))
    Set dataRange = distWs.Range(distWs.Cells(dataStartRow, dataCol), distWs.Cells(dataEndRow, dataCol))

    With cht.SeriesCollection.NewSeries
        .Name = "Frequency"
        .Values = freqRange
        .XValues = dataRange
        .ChartType = xlColumnClustered
        .Format.Fill.ForeColor.RGB = RGB(68, 114, 196)
        .Format.Line.Visible = msoTrue
        .Format.Line.ForeColor.RGB = RGB(30, 60, 120)
    End With

    Dim totalValue As Double
    Dim totalCount As Long
    totalValue = 0
    totalCount = 0

    For i = dataStartRow To dataEndRow
        If IsNumeric(distWs.Cells(i, dataCol).Value) And _
           IsNumeric(distWs.Cells(i, freqCol).Value) Then
            totalValue = totalValue + CDbl(distWs.Cells(i, dataCol).Value) * CDbl(distWs.Cells(i, freqCol).Value)
            totalCount = totalCount + CLng(distWs.Cells(i, freqCol).Value)
        End If
    Next i

    If totalCount > 0 Then
        avgValue = totalValue / totalCount
    Else
        avgValue = 0
    End If

    maxFreq = 0
    For i = dataStartRow To dataEndRow
        If IsNumeric(distWs.Cells(i, freqCol).Value) Then
            Dim freq As Long
            freq = CLng(distWs.Cells(i, freqCol).Value)
            If freq > maxFreq Then maxFreq = freq
        End If
    Next i

    Dim avgDataCount As Long
    avgDataCount = dataEndRow - dataStartRow + 1

    Dim avgArray() As Double
    ReDim avgArray(1 To avgDataCount)
    For i = 1 To avgDataCount
        avgArray(i) = avgValue
    Next i

    With cht.SeriesCollection.NewSeries
        .Name = "Average"
        .Values = avgArray
        .XValues = dataRange
        .ChartType = xlLine
        .Format.Line.ForeColor.RGB = RGB(255, 0, 0)
        .Format.Line.Weight = 2
        .Format.Line.DashStyle = msoLineDash
        .MarkerStyle = xlMarkerStyleNone
    End With

    Dim minValue As Double
    Dim maxValue As Double
    minValue = 1E+30
    maxValue = -1E+30

    For i = dataStartRow To dataEndRow
        If IsNumeric(distWs.Cells(i, dataCol).Value) Then
            Dim val As Double
            val = CDbl(distWs.Cells(i, dataCol).Value)
            If val < minValue Then minValue = val
            If val > maxValue Then maxValue = val
        End If
    Next i

    If Not IsEmpty(specMax) Then
        If CDbl(specMax) >= minValue And CDbl(specMax) <= maxValue Then
            Dim specMaxArray() As Double
            ReDim specMaxArray(1 To avgDataCount)
            For i = 1 To avgDataCount
                specMaxArray(i) = CDbl(specMax)
            Next i

            With cht.SeriesCollection.NewSeries
                .Name = "Spec Max"
                .Values = specMaxArray
                .XValues = dataRange
                .ChartType = xlLine
                .Format.Line.ForeColor.RGB = RGB(255, 0, 0)
                .Format.Line.Weight = 1.5
                .Format.Line.DashStyle = msoLineDot
                .MarkerStyle = xlMarkerStyleNone
            End With
        End If
    End If

    If Not IsEmpty(specMin) Then
        If CDbl(specMin) >= minValue And CDbl(specMin) <= maxValue Then
            Dim specMinArray() As Double
            ReDim specMinArray(1 To avgDataCount)
            For i = 1 To avgDataCount
                specMinArray(i) = CDbl(specMin)
            Next i

            With cht.SeriesCollection.NewSeries
                .Name = "Spec Min"
                .Values = specMinArray
                .XValues = dataRange
                .ChartType = xlLine
                .Format.Line.ForeColor.RGB = RGB(0, 176, 80)
                .Format.Line.Weight = 1.5
                .Format.Line.DashStyle = msoLineDot
                .MarkerStyle = xlMarkerStyleNone
            End With
        End If
    End If

    cht.HasTitle = True
    cht.ChartTitle.Text = readingName & " Distribution"
    cht.ChartTitle.Font.Size = 12
    cht.ChartTitle.Font.Bold = True

    With cht.Axes(xlCategory)
        .HasTitle = True
        .AxisTitle.Text = readingName
        .AxisTitle.Font.Size = 10
        .TickLabels.Font.Size = 8
        .TickLabels.Orientation = 45
    End With

    With cht.Axes(xlValue)
        .HasTitle = True
        .AxisTitle.Text = "Frequency"
        .AxisTitle.Font.Size = 10
        .TickLabels.Font.Size = 8
        .MaximumScale = maxFreq + 2
        .MinimumScale = 0
        .MajorUnit = Application.WorksheetFunction.Max(1, Int(maxFreq / 5))
    End With

    cht.HasLegend = True
    cht.Legend.Position = xlLegendPositionBottom
    cht.Legend.Font.Size = 8

    cht.PlotArea.Format.Fill.Visible = msoFalse
    cht.PlotArea.Format.Line.Visible = msoTrue

    cht.ChartArea.Format.Fill.Visible = msoTrue
    cht.ChartArea.Format.Fill.ForeColor.RGB = RGB(255, 255, 255)

    Set CreateDistributionChart = cht
End Function

' ------------------------------------------------------
' 函數：GetReadingColumnNamesFromSheet
' 功能：從工作表的 S/N 行讀取實際的讀值欄位名稱
' ------------------------------------------------------
Function GetReadingColumnNamesFromSheet(ws As Worksheet, seqStartCol As Long, testType As String) As Variant
    On Error Resume Next

    Dim snRow As Long
    Dim col As Long
    Dim readingNames() As String
    Dim readingCount As Long
    Dim i As Long
    Dim cellValue As Variant

    snRow = 0
    For i = 3 To 50
        cellValue = ws.Cells(i, seqStartCol).Value
        If cellValue = "S/N" Then
            snRow = i
            Exit For
        End If
    Next i

    If snRow = 0 Then
        GetReadingColumnNamesFromSheet = GetDefaultReadingNames(testType)
        Exit Function
    End If

    readingCount = GetReadingCountByType(testType)

    ReDim readingNames(0 To readingCount - 1)
    For i = 0 To readingCount - 1
        col = seqStartCol + 1 + i
        cellValue = ws.Cells(snRow, col).Value

        If cellValue = "" Or IsEmpty(cellValue) Then
            readingNames(i) = "Reading" & (i + 1)
        Else
            readingNames(i) = CStr(cellValue)
        End If
    Next i

    GetReadingColumnNamesFromSheet = readingNames
End Function

' ------------------------------------------------------
' 函數：GetReadingCountByType
' 功能：根據測試類型返回讀值數量
' ------------------------------------------------------
Function GetReadingCountByType(testType As String) As Long
    Select Case testType
        Case "TurnOn", "ShortCircuit", "OLP"
            GetReadingCountByType = 1
        Case "HoldUp", "Dynamic"
            GetReadingCountByType = 2
        Case "Combine"
            GetReadingCountByType = 6
        Case "LoadRegulation"
            GetReadingCountByType = 11
        Case "InputOutput_Iin", "InputOutput_Pin", "InputOutput_Eff", "InputOutput_General"
            GetReadingCountByType = 1
        Case Else
            GetReadingCountByType = 1
    End Select
End Function

' ------------------------------------------------------
' 函數：GetDefaultReadingNames
' 功能：返回預設的讀值名稱
' ------------------------------------------------------
Function GetDefaultReadingNames(testType As String) As Variant
    Select Case testType
        Case "TurnOn"
            GetDefaultReadingNames = Array("Reading")
        Case "HoldUp"
            GetDefaultReadingNames = Array("Tds", "Tdl")
        Case "ShortCircuit"
            GetDefaultReadingNames = Array("Pin")
        Case "Combine"
            GetDefaultReadingNames = Array("Vdc1", "Vpp1", "Vdc2", "Vpp2", "Vdc3", "Vpp3")
        Case "OLP"
            GetDefaultReadingNames = Array("Reading")
        Case "Dynamic"
            GetDefaultReadingNames = Array("Vs1", "Vs2")
        Case "LoadRegulation"
            GetDefaultReadingNames = Array("V-0", "V-1", "V-2", "V-3", "V-4", "V-5", "V-6", "V-7", "V-8", "V-9", "V-10")
        Case "InputOutput_Iin", "InputOutput_Pin", "InputOutput_Eff", "InputOutput_General"
            GetDefaultReadingNames = Array("Read")
        Case Else
            GetDefaultReadingNames = Array("Reading")
    End Select
End Function

' ------------------------------------------------------
' 函數：FindSeqStartCol
' 功能：從工作表掃描找出指定 SEQ 的起始欄位
' ------------------------------------------------------
Function FindSeqStartCol(ws As Worksheet, seqTitle As String) As Long
    On Error Resume Next

    Dim col As Long
    Dim maxCol As Long
    Dim cellValue As Variant
    Dim titleValue As Variant

    maxCol = ws.UsedRange.Columns.Count + ws.UsedRange.Column + 10

    For col = 2 To maxCol
        cellValue = ws.Cells(2, col).Value

        If cellValue = "Condition" Then
            titleValue = ws.Cells(1, col).Value

            If titleValue <> "" Then
                If InStr(1, CStr(titleValue), seqTitle, vbTextCompare) > 0 Or _
                   InStr(1, seqTitle, CStr(titleValue), vbTextCompare) > 0 Then
                    FindSeqStartCol = col
                    Exit Function
                End If
            End If
        End If
    Next col

    FindSeqStartCol = 0
End Function

' ------------------------------------------------------
' 函數：CreateReadingBlock
' 功能：建立單一讀值區塊（參數表 + 數據表 + 圖表）
' ------------------------------------------------------
Function CreateReadingBlock(distWs As Worksheet, sourceWs As Worksheet, _
                      seqName As String, readingName As String, _
                      seqStartCol As Long, paramRows As Long, _
                      targetRow As Long, targetCol As Long, _
                      readingColIndex As Long, testType As String) As Long

    Dim r As Long
    Dim chartStartRow As Long, chartEndRow As Long
    Dim chartStartCol As Long, chartEndCol As Long
    Dim dataRowCount As Long
    Dim blockHeight As Long

    ' === 1. 複製參數表（Condition/Value）===
    distWs.Cells(targetRow, targetCol).Value = "Condition"
    distWs.Cells(targetRow, targetCol + 1).Value = "Value"

    With distWs.Range(distWs.Cells(targetRow, targetCol), distWs.Cells(targetRow, targetCol + 1))
        .Interior.Color = RGB(255, 224, 178)
        .Font.Bold = True
        .HorizontalAlignment = xlCenter
        .Borders.LineStyle = xlContinuous
    End With

    For r = 1 To paramRows
        distWs.Cells(targetRow + r, targetCol).Value = _
            sourceWs.Cells(2 + r, seqStartCol).Value

        distWs.Cells(targetRow + r, targetCol + 1).Value = _
            sourceWs.Cells(2 + r, seqStartCol + 1).Value

        With distWs.Range(distWs.Cells(targetRow + r, targetCol), distWs.Cells(targetRow + r, targetCol + 1))
            .Interior.Color = RGB(255, 249, 196)
            .Borders.LineStyle = xlContinuous
        End With
    Next r

    ' === 2. 建立數據表欄位並填入頻率分布數據 ===
    distWs.Cells(targetRow, targetCol + 2).Value = readingName
    distWs.Cells(targetRow, targetCol + 3).Value = "Frequency"

    With distWs.Range(distWs.Cells(targetRow, targetCol + 2), distWs.Cells(targetRow, targetCol + 3))
        .Interior.Color = RGB(179, 229, 252)
        .Font.Bold = True
        .HorizontalAlignment = xlCenter
        .Borders.LineStyle = xlContinuous
    End With

    Dim testData As Collection
    Set testData = ReadTestDataFromSheet(sourceWs, seqStartCol, readingColIndex)

    Dim freqData As Object
    Set freqData = CalculateFrequencyDistribution(testData)

    Dim dataRow As Long
    dataRow = targetRow + 1
    Dim key As Variant

    For Each key In freqData.Keys
        distWs.Cells(dataRow, targetCol + 2).Value = CDbl(key)
        distWs.Cells(dataRow, targetCol + 3).Value = freqData(key)

        With distWs.Range(distWs.Cells(dataRow, targetCol + 2), distWs.Cells(dataRow, targetCol + 3))
            .Interior.Color = RGB(225, 245, 254)
            .Borders.LineStyle = xlContinuous
        End With

        dataRow = dataRow + 1
    Next key

    dataRowCount = dataRow - targetRow - 1

    For r = dataRow To targetRow + paramRows
        With distWs.Range(distWs.Cells(r, targetCol + 2), distWs.Cells(r, targetCol + 3))
            .Interior.Color = RGB(225, 245, 254)
            .Borders.LineStyle = xlContinuous
        End With
    Next r

    blockHeight = Application.WorksheetFunction.Max(paramRows, dataRowCount)

    ' === 4. 建立圖表（只在有數據時）===
    If dataRowCount > 0 Then
        chartStartRow = targetRow
        chartStartCol = targetCol + 4
        chartEndCol = targetCol + 13

        ' 取得 Spec Max/Min（傳入 readingColIndex）
        Dim specValues As Variant
        specValues = GetSpecMaxMin(sourceWs, seqStartCol, paramRows, testType, readingName, readingColIndex)

        Dim chartHeightPoints As Double
        chartHeightPoints = blockHeight * 15
        If chartHeightPoints < 180 Then chartHeightPoints = 180

        Dim cht As Chart
        Set cht = CreateDistributionChart(distWs, readingName, _
                                         targetRow + 1, targetRow + dataRowCount, _
                                         targetCol + 2, targetCol + 3, _
                                         chartStartRow, chartStartCol, _
                                         chartHeightPoints, _
                                         specValues(0), specValues(1))
    Else
        chartStartRow = targetRow
        chartEndRow = targetRow + blockHeight
        chartStartCol = targetCol + 4
        chartEndCol = targetCol + 13

        With distWs.Range(distWs.Cells(chartStartRow, chartStartCol), distWs.Cells(chartEndRow, chartEndCol))
            .Interior.Color = RGB(240, 240, 240)
            .Borders.LineStyle = xlContinuous
            .HorizontalAlignment = xlCenter
            .VerticalAlignment = xlCenter
        End With

        Dim midRow As Long
        midRow = chartStartRow + (blockHeight \ 2)
        distWs.Cells(midRow, chartStartCol + 5).Value = "[No Data for " & readingName & "]"
        distWs.Cells(midRow, chartStartCol + 5).Font.Color = RGB(128, 128, 128)
        distWs.Cells(midRow, chartStartCol + 5).Font.Italic = True
    End If

    ' === 5. 設定欄寬 ===
    distWs.Columns(targetCol).ColumnWidth = 12
    distWs.Columns(targetCol + 1).ColumnWidth = 12
    distWs.Columns(targetCol + 2).ColumnWidth = 12
    distWs.Columns(targetCol + 3).ColumnWidth = 12

    For r = chartStartCol To chartEndCol
        distWs.Columns(r).ColumnWidth = 8
    Next r

    CreateReadingBlock = blockHeight + 1
End Function

' ------------------------------------------------------
' 主函數：PrepareDistributionChartData
' 功能：建立 Distribution Data 工作表
' ------------------------------------------------------
Sub PrepareDistributionChartData(newWb As Workbook, seqList As Object)
    On Error Resume Next

    Dim distWs As Worksheet
    Dim sourceWs As Worksheet
    Dim seqKey As Variant
    Dim seqInfo As Object
    Dim readingNames As Variant
    Dim i As Long
    Dim currentCol As Long
    Dim currentRow As Long
    Dim seqStartCol As Long
    Dim testType As String
    Dim paramRows As Long
    Dim seqName As String
    Dim blockWidth As Long
    Dim blockHeight As Long

    Application.ScreenUpdating = False
    Application.Calculation = xlCalculationManual

    Set distWs = newWb.Worksheets.Add(After:=newWb.Worksheets(newWb.Worksheets.Count))
    distWs.Name = "Distribution Data"

    Set sourceWs = newWb.Worksheets(1)

    currentCol = 2
    blockWidth = 2 + 2 + 10

    For Each seqKey In seqList.Keys
        Set seqInfo = seqList(seqKey)

        seqName = seqInfo("title")
        testType = seqInfo("type")

        seqStartCol = FindSeqStartCol(sourceWs, seqName)

        If seqStartCol = 0 Then
            Debug.Print "警告：未找到 SEQ - " & seqName
            GoTo NextSeq
        End If

        paramRows = GetParamRowCount(testType)

        readingNames = GetReadingColumnNamesFromSheet(sourceWs, seqStartCol, testType)

        currentRow = 2

        For i = LBound(readingNames) To UBound(readingNames)
            If i = LBound(readingNames) Then
                distWs.Range(distWs.Cells(1, currentCol), distWs.Cells(1, currentCol + blockWidth - 1)).Merge
                distWs.Cells(1, currentCol).Value = seqName

                With distWs.Cells(1, currentCol)
                    .Interior.Color = RGB(189, 215, 238)
                    .Font.Bold = True
                    .Font.Size = 12
                    .HorizontalAlignment = xlCenter
                    .VerticalAlignment = xlCenter
                    .Borders.LineStyle = xlContinuous
                End With
                distWs.Rows(1).RowHeight = 24
            End If

            blockHeight = CreateReadingBlock(distWs, sourceWs, seqName, CStr(readingNames(i)), _
                                            seqStartCol, paramRows, currentRow, currentCol, i, testType)

            currentRow = currentRow + blockHeight + 1
        Next i

NextSeq:
        currentCol = currentCol + blockWidth + 2
    Next seqKey

    distWs.Activate
    distWs.Range("B2").Select
    ActiveWindow.FreezePanes = True

    Application.Calculation = xlCalculationAutomatic
    Application.ScreenUpdating = True

    MsgBox "Distribution Data 工作表已成功建立！" & vbCrLf & _
           "共處理 " & seqList.Count & " 個 SEQ，並自動生成分布圖。", vbInformation, "分布圖資料準備完成"

End Sub

' ======================================================
' 使用說明：
' 1. 此模組需要與主程式的 GetParamRowCount() 函數配合使用
' 2. 主程式需在 CreateAllSectionsInSheet 後加入：
'    Call PrepareDistributionChartData(newWb, seqList)
' 3. Combine 測試會根據 readingColIndex 正確對應 Value-1/2/3 參數
'    - readingColIndex 0,1 (Vdc-1, Vpp-1) → Value-1 參數
'    - readingColIndex 2,3 (Vdc-2, Vpp-2) → Value-2 參數
'    - readingColIndex 4,5 (Vdc-3, Vpp-3) → Value-3 參數
' ======================================================
